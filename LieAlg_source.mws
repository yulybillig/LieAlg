{VERSION 2016 0 "Linux" "2016.0" }
{USTYLETAB {PSTYLE "Heading 1" -1 3 1 {CSTYLE "" -1 -1 "Times" 1 18 0
 0 0 1 2 1 2 2 2 2 1 0 0 1 }1 1 0 0 8 4 2 0 2 0 2 2 -1 1 }{PSTYLE "War
ning" -1 7 1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0
 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Left Justified Maple Outp
ut" -1 12 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 
}1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Fixed Width" -1 17 1 {CSTYLE "
" -1 -1 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 
0 2 2 -1 1 }{PSTYLE "Help" -1 10 1 {CSTYLE "" -1 -1 "Courier" 1 9 0 0 
255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Head
ing 4" -1 20 1 {CSTYLE "" -1 -1 "Times" 1 10 0 0 0 1 1 1 2 2 2 2 1 0 0
 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Line Printed Output" -1 6 1
 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 
0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 2" -1 4 1 {CSTYLE "" -1 -1 "T
imes" 1 14 0 0 0 1 2 1 2 2 2 2 1 0 0 1 }1 1 0 0 8 2 2 0 2 0 2 2 -1 1 }
{PSTYLE "Maple Output" -1 11 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2
 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Heading 3" 
-1 5 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 1 1 2 2 2 2 1 0 0 1 }1 1 
0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Diagnostic" -1 9 1 {CSTYLE "" -1 -1
 "Courier" 1 10 64 128 64 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2
 2 -1 1 }{PSTYLE "Ordered List 1" -1 200 1 {CSTYLE "" -1 -1 "Times" 1 
12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE 
"Text Output" -1 2 1 {CSTYLE "" -1 -1 "Courier" 1 10 0 0 255 1 2 2 2 2
 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Ordered List 2" 
-1 201 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 
1 0 0 3 3 2 36 2 0 2 2 -1 1 }{PSTYLE "Ordered List 3" -1 202 1 {CSTYLE
 "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 72 2
 0 2 2 -1 1 }{PSTYLE "Ordered List 4" -1 203 1 {CSTYLE "" -1 -1 "Times
" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 108 2 0 2 2 -1 1 }
{PSTYLE "Ordered List 5" -1 204 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 
1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 144 2 0 2 2 -1 1 }{PSTYLE "Annota
tion Title" -1 205 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 2 2 2 2
 1 0 0 1 }3 1 0 0 12 12 2 0 2 0 2 2 -1 1 }{PSTYLE "HyperlinkError" -1 
206 1 {CSTYLE "" -1 -1 "Courier New" 1 12 255 0 255 1 2 2 1 2 2 1 1 0 
0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "HyperlinkWarning" -1 207 1
 {CSTYLE "" -1 -1 "Courier New" 1 12 0 0 255 1 2 2 1 2 2 1 1 0 0 1 }1 
1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Bullet Item" -1 15 1 {CSTYLE "" 
-1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 2 
2 -1 1 }{PSTYLE "Maple Plot" -1 13 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0
 0 1 2 2 2 2 2 2 1 0 0 1 }3 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "List \+
Item" -1 14 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 
1 }1 1 0 0 3 3 2 0 2 0 2 2 -1 1 }{PSTYLE "Dash Item" -1 16 1 {CSTYLE "
" -1 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 3 3 2 0 2 0 
2 2 -1 1 }{PSTYLE "Error" -1 8 1 {CSTYLE "" -1 -1 "Courier" 1 10 255 0
 255 1 2 2 2 2 2 1 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 -1 1 }{PSTYLE "Tit
le" -1 18 1 {CSTYLE "" -1 -1 "Times" 1 18 0 0 0 1 2 1 1 2 2 2 1 0 0 1 
}3 1 0 0 12 12 2 0 2 0 2 2 -1 1 }{PSTYLE "Normal" -1 0 1 {CSTYLE "" -1
 -1 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 1 0 0 1 }1 1 0 0 0 0 2 0 2 0 2 2 
-1 1 }{PSTYLE "Author" -1 19 1 {CSTYLE "" -1 -1 "Times" 1 12 0 0 0 1 2
 2 2 2 2 2 1 0 0 1 }3 1 0 0 8 8 2 0 2 0 2 2 -1 1 }{CSTYLE "Help Variab
le" -1 25 "Courier" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Un
derlined Bold" -1 41 "Times" 1 12 0 0 0 1 1 1 2 2 2 2 0 0 0 1 }{CSTYLE
 "Copyright" -1 34 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "
Maple Comment" -1 21 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }
{CSTYLE "Popup" -1 31 "Times" 1 12 0 128 128 1 1 2 1 2 2 2 0 0 0 1 }
{CSTYLE "Atomic Variable" -1 200 "Times" 1 12 175 0 175 1 1 2 2 2 2 2 
0 0 0 1 }{CSTYLE "Dictionary Hyperlink" -1 45 "Times" 1 12 147 0 15 1 
2 2 1 2 2 2 0 0 0 1 }{CSTYLE "Plot Text" -1 28 "Times" 1 8 0 0 0 1 2 2
 2 2 2 2 0 0 0 1 }{CSTYLE "2D Input" -1 19 "Times" 1 12 255 0 0 1 2 2 
2 2 1 2 0 0 0 1 }{CSTYLE "Code" -1 201 "Courier New" 1 12 255 0 0 1 2 
2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic" -1 3 "Times" 1 12 0 0 0 1 
1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Small" -1 7 "Times" 1 1 0 0 0 1 
2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic Small206206" -1 202 "Time
s" 1 1 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Bold Small" -1 10
 "Times" 1 1 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Bold" -1 39 "T
imes" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Menus" -1 36 "Ti
mes" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Heading" -1 26 "T
imes" 1 14 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "2D Output" -1 20 "Tim
es" 1 12 0 0 255 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Inert Output" -1 
203 "Times" 1 12 144 144 144 1 2 2 2 2 1 2 0 0 0 1 }{CSTYLE "Help Norm
al" -1 30 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Maple Inp
ut" -1 0 "Courier" 1 12 255 0 0 1 2 1 2 2 1 2 0 0 0 1 }{CSTYLE "Page N
umber" -1 33 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Header
 and Footer" -1 204 "Times" 1 10 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE 
"2D Math Italic Small207209" -1 205 "Times" 1 1 0 0 0 1 1 2 2 2 2 2 0 
0 0 1 }{CSTYLE "Help Fixed" -1 23 "Courier" 1 10 0 0 0 1 2 2 2 2 2 2 0
 0 0 1 }{CSTYLE "2D Math Italic Small206" -1 206 "Times" 1 1 0 0 0 1 1
 2 2 2 2 2 0 0 0 1 }{CSTYLE "Output Labels" -1 29 "Times" 1 8 0 0 0 1 
2 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic Small205" -1 207 "Times" 
1 1 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Notes" -1 37 "Times" 1 
12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underlined" -1 44 "Times
" 1 12 0 0 0 1 2 2 1 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic Small" -1 
208 "Times" 1 1 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D Math Italic S
mall208" -1 209 "Times" 1 1 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "2D M
ath Symbol 2" -1 16 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE 
"2D Math Italic Small207" -1 210 "Times" 1 1 0 0 0 1 1 2 2 2 2 2 0 0 0
 1 }{CSTYLE "2D Math" -1 2 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "Help Nonterminal" -1 24 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 
0 0 1 }{CSTYLE "2D Math Italic Small209" -1 211 "Times" 1 1 0 0 0 1 1 
2 2 2 2 2 0 0 0 1 }{CSTYLE "Annotation Text" -1 212 "Times" 1 12 0 0 0
 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Maple Name" -1 35 "Times" 1 12 
104 64 92 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Text" -1 213 "Times" 1 12 0 
0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Plot Title" -1 27 "Times" 1 10 0 0
 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Help Underlined Italic" -1 43 "Time
s" 1 12 0 0 0 1 1 2 1 2 2 2 0 0 0 1 }{CSTYLE "Caption Reference" -1 
214 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 1 }{CSTYLE "Default" -1 38 
"Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }{CSTYLE "Help Italic Bold" 
-1 40 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0 1 }{CSTYLE "Maple Input P
laceholder" -1 215 "Courier New" 1 12 200 0 200 1 2 1 2 2 1 2 0 0 0 1 
}{CSTYLE "LaTeX" -1 32 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 0 0 1 }
{CSTYLE "Help Emphasized" -1 22 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 0 0
 1 }{CSTYLE "Equation Label" -1 216 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0
 0 0 1 }{CSTYLE "2D Comment" -1 18 "Times" 1 12 0 0 0 1 2 2 2 2 2 2 0 
0 0 1 }{CSTYLE "Help Italic" -1 42 "Times" 1 12 0 0 0 1 1 2 2 2 2 2 0 
0 0 1 }{CSTYLE "Prompt" -1 1 "Courier" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "2D Math Bold" -1 5 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 0 0 
1 }{CSTYLE "Hyperlink" -1 17 "Times" 1 12 0 128 128 1 2 2 1 2 2 2 0 0 
0 1 }{CSTYLE "Caption Text" -1 217 "Times" 1 12 0 0 0 1 2 1 2 2 2 2 0 
0 0 1 }{CSTYLE "" -1 218 "Courier" 1 12 255 0 0 1 1 2 2 2 1 2 0 0 0 1 
}}
{SECT 0 {EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "### (C) 1999-2019 b
y Yuly Billig & Matyas Mazzag\n" }{MPLTEXT 1 0 58 "### billig@math.car
leton.ca  and  matyas.mazzag@gmail.com\n" }{MPLTEXT 1 0 53 "### Distri
buted under Open Source GNU AGPLv3 license " }{MPLTEXT 1 218 1 "\n" }
{MPLTEXT 1 0 77 "### For License details, see: https://choosealicense.
com/licenses/agpl-3.0/ \n" }{MPLTEXT 1 0 28 "### Correction in July 20
19\n" }{MPLTEXT 1 0 53 "### Replaced: type(x, constant) with is(x, con
stant)\n" }{MPLTEXT 1 0 31 "### and for products replaced:\n" }
{MPLTEXT 1 0 57 "### if type(x,`*`) then op(1,x) * some_function(op(2,
x))\n" }{MPLTEXT 1 0 10 "### with:\n" }{MPLTEXT 1 0 83 "### if type(x,
`*`) then product(op(i,x), i=1..nops(x)-1) * some_function(op(-1,x))\n
" }{MPLTEXT 1 0 5 "### \n" }{MPLTEXT 1 0 74 "### We had a problem with
 remember tables and implicit use of algebras - \n" }{MPLTEXT 1 0 90 "
### For example, if we call genhallmon with a weight as an argument, b
ut not the algebra,\n" }{MPLTEXT 1 0 98 "### which can be determined f
rom the global variable, then on a second call with the same weight,\n
" }{MPLTEXT 1 0 106 "### but in the context of a different algebra, th
e result will not be calculated, but just looked up from\n" }{MPLTEXT 
1 0 69 "### the remember table, giving the answer with incorrect gener
ators.\n" }{MPLTEXT 1 0 4 "###\n" }{MPLTEXT 1 0 108 "### Another possi
ble bug is that when we store indexed generators, if the corresponding
 variable has value \n" }{MPLTEXT 1 0 57 "### then generator index get
s evaluated (in isgenerator)\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 8 "restart;" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "LieAlg[init] := proc()" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 \+
by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
81 "   description `initializing function, called when the package Lie
Alg is loaded`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 112 "   global GENER
ATORS, ALGEBRA, CHARACTERISTIC, MATRIX_TYPE, MATRIX_LACING, REPRESENTA
TION, IDEAL, USING_HISTORY;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   ### unprotect our functions" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "   unprotect(op(map(op,[indices(Lie
Alg),indices(LieAlg_Hidden)])));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
172 "   unprotect(evaln(ALGEBRA), evaln(CHARACTERISTIC), evaln(MATRIX_
TYPE), evaln(MATRIX_LACING), evaln(GENERATORS), evaln(REPRESENTATION),
 evaln(IDEAL), evaln(USING_HISTORY));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "   ### load other half of \+
the package (functions unseen by the user)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "   with(LieAlg_Hidden);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### init our global \+
variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 202 "   GENERATORS := []; \+
CHARACTERISTIC := 0; ALGEBRA := 'ALGEBRA'; MATRIX_TYPE := 'MATRIX_TYPE
'; MATRIX_LACING := 'MATRIX_LACING'; REPRESENTATION := 'REPRESENTATION
'; IDEAL := 'IDEAL'; USING_HISTORY := [];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   ### define t
he algebra types" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 304 "   NewAlgType(
`ideal`); NewAlgType(`KacMoody`); NewAlgType(`unienv`); NewAlgType(`hw
rep`); NewAlgType(`withrules`); NewAlgType(`algebra`); NewAlgType(`dir
ectsum`); NewAlgType(`quotalg`); NewAlgType(`triangular`); NewAlgType(
`simple`); NewAlgType(`affine`); NewAlgType(`submodule`); NewAlgType(`
quotrep`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "   ### define our operator types" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 53 "   NewOpType(`&*`); NewOpType(`&@`); NewOpType(`&^`)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 28 "   ### protect our functions" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 65 "   protect(op(map(op,[indices(LieAlg),indices(LieAlg_Hidden)])))
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 135 "   protect(ALGEBRA, evaln(CHA
RACTERISTIC), MATRIX_TYPE, MATRIX_LACING, evaln(GENERATORS), REPRESENT
ATION, IDEAL, evaln(USING_HISTORY));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 22 "#   LieAlg[version]();" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:
" }{TEXT 219 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "LieAlg[version] := proc()" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "   print(`#######################
######################################################################
##`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "   print(`LieAlg - Maple 9
 package for computations in infinite dimensional Lie algebras`);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   print(`Version 1.2`);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 116 "   print(`(c) 2001-2019 by Yuly Billig (b
illig@math.carleton.ca) and Matyas Mazzag (matyas.mazzag@pucer.dhis.or
g)`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "   print(`###############
######################################################################
##########`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "#
##################>  type definitions follow" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "LieAlg_Hidden[NewAlgType] := proc(AT::symbol)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   description `Generic function to
 define algebra types.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   opti
on `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, rememb
er;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "   :-`type/`||AT:=(alg)->eva
lb(op(4,eval(AT))<>NULL and member([alg],[indices(op(4,eval(AT)))]));"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "LieAlg
_Hidden[NewOpType] := proc(OP::symbol)" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 60 "   description `Generic function to define operator types.`;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copyright (C) 1999-201
9 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "   :-`type/`||OP:=(e)->evalb(op(0,e)=OP);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "LieAlg_Hidden[`t
ype/generator`] := proc(loe)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   \+
 description `Defines the generator type.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 71 "    option `Copyright (C) 1999-2019 by Yuly Billig an
d Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    isgenerat
or(loe,ALGEBRA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "LieAlg_Hidden[`type/reordexpr`] := proc(e)" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 87 "    description `Defines expressions with \+
the reorder operator types &<<,&>> and &==.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 71 "    option `Copyright (C) 1999-2019 by Yuly Billig an
d Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "    evalb(op(
0,e)=`&<<` or op(0,e)=`&==` or op(0,e)=`&>>`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "LieAlg_Hidden[`type/ADE_mat
rix_truegen`] := proc(adei::list(integer))" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "  description `Defines the indices of true generators
 for ade[n] algebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "  option
 `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "  evalb( type(adei,`homogwt`) and s
cpd(adei,adei,op(4,eval(simple))[ALGEBRA]) = 2 );" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "LieAlg_Hidden[`type/B_matr
ix_truegen`] := proc(bi::list(integer))" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 74 "  description `Defines the indices of true generators for b[n]
 algebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "  option `Copyright
 (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 50 "  evalb( type(bi,`homogwt`) and Bn2Dn(bi) <> [] );"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "LieAlg
_Hidden[`type/C_matrix_truegen`] := proc(ci::list(integer))" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 74 "  description `Defines the indices of true
 generators for c[n] algebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 
"  option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "  evalb( type(ci,`homogwt`) and
 Cn2An(ci) <> [] );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 66 "LieAlg_Hidden[`type/F_matrix_truegen`] := proc(f4i::
list(integer))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "  description `De
fines the indices of true generators for f[4] algebras.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 69 "  option `Copyright (C) 1999-2019 by Yuly Bi
llig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "  eval
b( F42E6(f4i) <> FAIL );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 65 "LieAlg_Hidden[`type/G_matrix_truegen`] := proc(gi::
list(integer))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "  description `De
fines the indices of true generators for g[2] algebras.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 69 "  option `Copyright (C) 1999-2019 by Yuly Bi
llig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "  memb
er(gi,[[1,0],[0,1],[1,1],[2,1],[3,1],[3,2],[-1,0],[0,-1],[-1,-1],[-2,-
1],[-3,-1],[-3,-2]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 57 "LieAlg_Hidden[`type/htruegen`] := proc(hi::list(inte
ger))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "  description `Defines the
 indices of true generators for h's in any simple algebra.`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 69 "  option `Copyright (C) 1999-2019 by Yuly
 Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "  e
valb( hi[] > 0 and hi[] <= LinearAlgebra[RowDimension](op(4,eval(simpl
e))[ALGEBRA]) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "LieAlg_Hidden[`type/mixedwt`] := proc(wts::list(integ
er))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "  description `Defines the \+
mixed weight type.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "  option `C
opyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 59 "  evalb( hastype(wts,positive) and hastype(
wts,negative) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "LieAlg_Hidden[`type/homogwt`] := proc(wts::list(integ
er))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "  description `Defines the \+
homogenous weight type.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "  opti
on `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "  not(type(wts,`mixedwt`));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 37 "######################>  typedefs end" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "##
################################# Correction 2019 ####################
#\n" }{MPLTEXT 1 0 2 "#\n" }{MPLTEXT 1 0 52 "#  Extract constants and \+
other terms from a product\n" }{MPLTEXT 1 0 51 "LieAlg_Hidden[PickCons
tants] := proc(G::algebraic)\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 22 
"local i, term, Const;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 10 "Const
:=1;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 20 "if type(G,`*`) then\n" 
}{MPLTEXT 1 0 31 "    for i from 1 to nops(G) do\n" }{MPLTEXT 1 0 24 "
       term := op(i,G);\n" }{MPLTEXT 1 0 33 "       if is(term,constan
t) then\n" }{MPLTEXT 1 0 30 "           Const:=Const*term;\n" }
{MPLTEXT 1 0 11 "       fi;\n" }{MPLTEXT 1 0 9 "    end;\n" }{MPLTEXT 
1 0 5 "else\n" }{MPLTEXT 1 0 56 "   ERROR(`argument of PickConstants i
s not a product`);\n" }{MPLTEXT 1 0 5 "fi; \n" }{MPLTEXT 1 0 15 "RETUR
N(Const);\n" }{MPLTEXT 1 0 5 "end:\n" }{MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "LieAlg_Hidden[HasConstants] := proc
(G::algebraic)\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 23 "local i, term
, Result;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 17 "Result := false;\n
" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 20 "if type(G,`*`) then\n" }
{MPLTEXT 1 0 31 "    for i from 1 to nops(G) do\n" }{MPLTEXT 1 0 24 " \+
      term := op(i,G);\n" }{MPLTEXT 1 0 33 "       if is(term,constant
) then\n" }{MPLTEXT 1 0 25 "           Result:=true;\n" }{MPLTEXT 1 0 
11 "       fi;\n" }{MPLTEXT 1 0 9 "    end;\n" }{MPLTEXT 1 0 5 "else\n
" }{MPLTEXT 1 0 56 "   ERROR(`argument of PickConstants is not a produ
ct`);\n" }{MPLTEXT 1 0 5 "fi; \n" }{MPLTEXT 1 0 16 "RETURN(Result);\n"
 }{MPLTEXT 1 0 5 "end:\n" }{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 46 "LieAlg_Hidden[PickTerm] := proc(G::algebraic)\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 31 "local i, term, nonconst, Flag;\n
" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 13 "nonconst:=1;\n" }{MPLTEXT 1 
0 11 "Flag := 2;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 20 "if type(G,`
*`) then\n" }{MPLTEXT 1 0 31 "    for i from 1 to nops(G) do\n" }
{MPLTEXT 1 0 24 "       term := op(i,G);\n" }{MPLTEXT 1 0 38 "       i
f not(is(term,constant)) then\n" }{MPLTEXT 1 0 27 "           nonconst
:=term;\n" }{MPLTEXT 1 0 27 "           Flag:=Flag - 1;\n" }{MPLTEXT 
1 0 11 "       fi;\n" }{MPLTEXT 1 0 9 "    end;\n" }{MPLTEXT 1 0 5 "el
se\n" }{MPLTEXT 1 0 51 "   ERROR(`argument of PickTerm is not a produc
t`);\n" }{MPLTEXT 1 0 23 "   if (Flag <= 0) then\n" }{MPLTEXT 1 0 63 "
       ERROR(`more than one non-constant factor in PickTerm`);\n" }
{MPLTEXT 1 0 7 "   fi;\n" }{MPLTEXT 1 0 5 "fi; \n" }{MPLTEXT 1 0 18 "R
ETURN(nonconst);\n" }{MPLTEXT 1 0 5 "end:\n" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 21 "#####################" }{MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "#####################>
  operator definitions follow" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "Li
eAlg[delta] := proc(x::anything,y::anything)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "   description `Krockner delta function.`;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly
 Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   \+
if( type(x,name) or type(y,name) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 32 "      RETURN(evaln(delta(x,y)));" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      if( x = y \+
) then RETURN(1);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      else RET
URN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 45 "LieAlg[`&*`] := proc(A::anything,B::anything)" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "    option `Copyright (C) 1999-20
19 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 109 "    description `Overloaded operator that represents non-comm
unitative multiplication used in lie algebras.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "    local Alg, CheckConst, GetTerms, GetConsts, IsCon
st;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 65 "    IsConst := proc(E::anything, CheckConst::boolean,
 Alg::name)\n" }{MPLTEXT 1 0 18 "        # JUL 2019" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 109 "        # RETURN(evalb(type(E,`constant`) or (typ
e(E,`name`) and CheckConst and not(isgenerator(E, Alg)))));\n" }
{MPLTEXT 1 0 102 "        RETURN(evalb(is(E,`constant`) or (is(E,`name
`) and CheckConst and not(isgenerator(E, Alg)))));" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "    GetTerms := proc(E::anything, C
heckConst::boolean, Alg::name)\n" }{MPLTEXT 1 0 26 "        # Correcti
on 2019\n" }{MPLTEXT 1 0 16 "        local i;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 134 "        RETURN(subsop(map((x,y,z)->if(IsConst(x[2],y
,z)) then return x[1]=1; fi,[seq([i,op(i,E)],i=1..nops(E))],CheckConst
,Alg)[],E));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "    G
etConsts := proc(E::anything, CheckConst::boolean, Alg::name)\n" }
{MPLTEXT 1 0 8 "        " }{MPLTEXT 1 0 18 "# Correction 2019\n" }
{MPLTEXT 1 0 16 "        local i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
148 "        RETURN(subsop(map((x,y,z)->if(not(IsConst(x[2],y,z))) the
n return x[1]=1; fi,[seq([i,op(i,E)],i=1..nops(E))],CheckConst,Alg)[],
E));         " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "    \+
### if a constant on either side, treat &* as *" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "    if(nargs > 2) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 22 "       Alg := args[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 " \+
      CheckConst := true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    els
e" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "       CheckConst := false;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    # A or B is
 a constant" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "    if(  IsConst(A,C
heckConst,Alg) or IsConst(B,CheckConst,Alg) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 21 "       RETURN(A * B);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    ### no sums, no con
stants" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 128 "    elif( (type(A,indexe
d) or type(A,name) or type(A,function)) and (type(B,indexed) or type(B
,function) or type(B,name)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
30 "       if( type(A,`&^`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
68 "          RETURN(evaln((op(1,A) &^ (op(2,A)-1)) &@ (op(1,A) &* B))
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "       elif( type(A,`&*`) and
 type(B,`&^`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "          R
ETURN(evaln((A &* op(1,B)) &@ (op(1,B) &^ (op(2,B)-1))));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 32 "          RETURN(evaln(A &* B));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 46 "    ### if a multiplication, pull constant ou
t" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "    elif( type(A,`*`) ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "       ### we have other things t
han just names in the multiplication" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "       if( not(type([op(A)],list(name))) ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 29 "          if(CheckConst) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 90 "             RETURN(GetConsts(A,CheckConst,Alg) * \+
`&*`(GetTerms(A,CheckConst,Alg),B,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "        \+
     RETURN(GetConsts(A,CheckConst,Alg) * `&*`(GetTerms(A,CheckConst,A
lg),B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 21 "       ### only names" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 " \+
         RETURN(evaln(A &* B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "
       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "    elif( type(B,`*`)
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "       ### we have other
 things than just names in the multiplication" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "       if( not(type([op(B)],list(name))) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "          if(CheckConst) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "             RETURN(GetConsts(B,Che
ckConst,Alg) * `&*`(A,GetTerms(B,CheckConst,Alg),Alg));" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 86 "             RETURN(GetConsts(B,CheckConst,Alg) * `&*`(A,GetTe
rms(B,CheckConst,Alg)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "       \+
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "       ### only names" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "          RETURN(evaln(A &* B));" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "    
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "    ### if sum on either side, \+
expand it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "    elif( type(A,`+`) \+
or type(B,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "       if(
CheckConst) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "          RETUR
N(generalexpand(A,B,`&*`,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "
       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "          RETURN(gen
eralexpand(A,B,`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 37 "    ### garbage in, error message out" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "       \+
ERROR(`%1, %2 are not defined in this context.`, A, B);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "en
d:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 45 "LieAlg[`&@`] := proc(A::anything,B::anything)
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2
019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 98 "   description `Overloaded operator that represents multiplica
tion used in associative algebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 68 "   local Alg, UAlg, HwRep, CheckConst, GetTerms, GetConsts, IsCo
nst;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 83 "    IsConst := proc(E::anything, CheckConst::boolean,
 UAlg::name, HwRep::anything)\n" }{MPLTEXT 1 0 19 "        # JUL 2019
\n" }{MPLTEXT 1 0 130 "        #RETURN(evalb((type(E,`constant`) or (t
ype(E,`name`) and CheckConst and (not(isgenerator(E,UAlg)) and not(E =
 HwRep))))));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 127 "        RETURN(ev
alb((is(E,`constant`) or (type(E,`name`) and CheckConst and (not(isgen
erator(E,UAlg)) and not(E = HwRep))))));" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 8 "    end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 84 "    GetTerms := proc(E::anything, CheckConst::b
oolean, UAlg::name, HwRep::anything)\n" }{MPLTEXT 1 0 4 "    " }
{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 16 "        local \+
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 145 "        RETURN(subsop(map((x
,y,z,w)->if(IsConst(x[2],y,z,w)) then return x[1]=1; fi,[seq([i,op(i,E
)],i=1..nops(E))],CheckConst,UAlg,HwRep)[],E));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "    end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "    GetConsts := proc(E::anything, \+
CheckConst::boolean, UAlg::name, HwRep::anything)\n" }{MPLTEXT 1 0 4 "
    " }{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 16 "       \+
 local i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 150 "        RETURN(subsop
(map((x,y,z,w)->if(not(IsConst(x[2],y,z,w))) then return x[1]=1; fi,[s
eq([i,op(i,E)],i=1..nops(E))],CheckConst,UAlg,HwRep)[],E));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   ### if a constant on eith
er side, treat &* as *" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   if(nar
gs > 2) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      if(type(args[
3],`algebra`)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         Alg
 := args[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "         UAlg := ar
gs[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         CheckConst := tr
ue;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      elif(type(args[3],`hwr
ep`)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         Alg := args[
3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "         UAlg := op(4,eval(`
hwrep`))[(args[3],`algebra`)][1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "         HwRep := op(4,eval(`hwrep`))[args[3]];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 28 "         CheckConst := true;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    \+
     CheckConst := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      f
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      CheckConst := false;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 51 "    ### if a constant on either side, tre
at &@ as *" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "    if( IsConst(A,Che
ckConst,UAlg,HwRep) or IsConst(B,CheckConst,UAlg,HwRep) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "       RETURN(A * B);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "    ###
 if a multiplication, pull constant out" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 28 "    elif( type(A,`*`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 70 "       ### we have other things than just names in the multiplic
ation\n" }{MPLTEXT 1 0 25 "       # Correction 2019\n" }{MPLTEXT 1 0 
9 "       # " }{MPLTEXT 1 0 40 "if( not(type([op(A)],list(name))) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       if HasConstants(A) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "          if(CheckConst) then"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 104 "             RETURN(GetConsts(A
,CheckConst,UAlg,HwRep) * `&@`(GetTerms(A,CheckConst,UAlg,HwRep),B,Alg
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "          else" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 100 "             RETURN(GetConsts(A,CheckConst,U
Alg,HwRep) * `&@`(GetTerms(A,CheckConst,UAlg,HwRep),B));" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 21 "       ### only names" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "  \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "          RETURN(evaln
(A &@ B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 28 "    elif( type(B,`*`) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 70 "       ### we have other things than just nam
es in the multiplication\n" }{MPLTEXT 1 0 25 "       # Correction 2019
\n" }{MPLTEXT 1 0 9 "       # " }{MPLTEXT 1 0 40 "if( not(type([op(B)]
,list(name))) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       if H
asConstants(B) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "          if
(CheckConst) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 104 "             \+
RETURN(GetConsts(B,CheckConst,UAlg,HwRep) * `&@`(A,GetTerms(B,CheckCon
st,UAlg,HwRep),Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "          \+
else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 100 "             RETURN(GetCon
sts(B,CheckConst,UAlg,HwRep) * `&@`(A,GetTerms(B,CheckConst,UAlg,HwRep
)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 21 "       ### only names" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   \+
       RETURN(evaln(A &@ B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "  \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "    " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 40 "    ### if sum on either side, expand it" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 43 "    elif( type(A,`+`) or type(B,`+`) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "       if(CheckConst) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "          RETURN(generalexpand(A,B,
`&@`,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "          RETURN(generalexpand(A,B,
`&@`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "#    ##
# sides are equal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "#    elif( A =
 B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "#       if( type(A,`&^
`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "#          RETURN(op(1
,A) &^ (op(2,A) + op(2,B)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "#  \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "#          RETURN(A &^
 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "#       fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "#    ###
 A&^x &@ A&^y" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "#    elif( type(A,
`&^`) and type(B,`&^`) and op(1,A) = op(1,B) ) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 47 "#       RETURN(op(1,A) &^ (op(2,A) + op(2,B)));" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 18 "#    ### (x&@A)&@A" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "#    el
if( type(A,`&@`) and op(2,A) = B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 37 "#       if( type(op(2,A),`&^`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "#          RETURN(subsop(2=(op(1,op(2,A)) &^ (op(2,op
(2,A)) + op(2,B))),A));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "#       \+
else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "#          RETURN(subsop(2=
(op(1,op(2,A)) &^ 2),A));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "#     \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "#    ### (z&*A&^x) &@ A&^y" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 99 "#    elif( type(A,`&@`) and type(op(2,A),`&^`) and ty
pe(B,`&^`) and op(1,op(2,A)) = op(1,B) ) #then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 73 "#       RETURN(subsop(2=(op(1,op(2,A)) &^ (op(2,op(2,
A)) + op(2,B))),A));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 24 "#    ### everything else" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 9 "#    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "# \+
      ### A&^x &@ A" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "#       if( \+
type(A,`&^`) and op(1,A) = B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
43 "#           RETURN(op(1,A) &^ (op(2,A)+1));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "#       ### (x&@A&^y)&@A" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "#       elif( type(A,`&@`) and type(op(2,A),`&^`) and
 op(1,op(2,A)) = B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "#     \+
      RETURN(subsop(2=(B &^ (op(2,op(2,A))+1)),A));" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "#       ### A &@ B&^x" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "#       elif( type(B,`&^`) and A = op(1,B) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "#           RETURN(A &^ (op(2,B)+1)
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "#       ### (x&@A)&@B&^y" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "#       elif( type(A,`&@`) and type
(B,`&^`) and op(2,A) = op(1,B) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 57 "#           RETURN(subsop(2=(op(1,B) &^ (op(2,B)+1)),A));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
18 "       ### default" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       el
se" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "#            RETURN(convert([
A,allop(B,`keepterms`)],`&@`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "
           RETURN(evaln(A &@ B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
11 "#       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "LieAlg[`&^`] :=
 proc(E::anything,P::nonnegative)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "   description `Overloaded \+
operator that represents powers used in associative algebras.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   local i, temp, Alg, CheckConst;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 19 "   if( 0 = P ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "      \+
RETURN( 1 );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   elif( 1 = P ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "      RETURN( E );" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
53 "      ### if a constant on either side, treat &* as *" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 24 "      if(nargs > 2) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 41 "         if(type(args[3],`algebra`)) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 27 "            Alg := args[3];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 31 "            CheckConst := true;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 32 "            CheckConst := false;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         CheckConst := false;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      if( type(
E,`*`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         if(CheckC
onst) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "            RETURN(ma
p(`&^`,E,P,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "            RETURN(map(`&^`,E,P)
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 30 "      elif( type(E,`+`) ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 19 "         temp := E;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 24 "         for i to P-1 do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
31 "            if(CheckConst) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "               temp := `&@`(temp,E,Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "            else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "               temp := `&@`(temp,E);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "       \+
  od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "         RETURN(temp);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      elif( type(E,`&^`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         RETURN(subsop(2=(op(2,E)*P
),E));\n" }{MPLTEXT 1 0 17 "      # JUL 2019\n" }{MPLTEXT 1 0 102 "   \+
   # elif( type(E,`constant`) or (type(E,`name`) and CheckConst and no
t(isgenerator(E,Alg))) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "  \+
    elif( is(E,`constant`) or (type(E,`name`) and CheckConst and not(i
sgenerator(E,Alg))) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     \+
    RETURN(E^P);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         RETURN(evaln(E&^P));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 49 "LieAlg[`&<`] := proc(A::algebraic, B::algebraic) " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     option `Copyright (C) 1999-20
19 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 92 "     description `monomial &< monomial defines the operator \"
&<\", which is interface to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 
"                 function evaluate; works only with the default set o
f generators`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     local LA, L
B, i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 97 "     ### if we have sum, look at leading terms, if co
nstant multiplier, send only expression part" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "     if( type(A, `+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "        LA := leading(A, ALGEBRA);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   \+
     LA := A;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 30 "     if( type(LA, `*`) ) then\n" }{MPLTEXT
 1 0 26 "        # Correction 2019\n" }{MPLTEXT 1 0 25 "        # LA :
= op(2,LA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "        LA := PickTe
rm(LA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "     if( t
ype(B, `+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        LB :=
 leading(B, ALGEBRA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "        LB := B;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "  \+
   if( type(LB,`*`) ) then\n" }{MPLTEXT 1 0 26 "        # Correction 2
019\n" }{MPLTEXT 1 0 25 "        # LB := op(2,LB);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 27 "        LB := PickTerm(LB);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "     if( hastype(GENERATORS,indexed
) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "        RETURN(evalb(tc
oeff(indexedranking(LA,ALGEBRA) - indexedranking(LB,ALGEBRA)) < 0));" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "        RETURN(evalb(normalranking(LA,ALGEBRA) < norm
alranking(LB,ALGEBRA)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "LieAl
g[`&>`] := proc(A::algebraic, B::algebraic) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Billig a
nd Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "     descrip
tion `monomial &> monomial defines the operator \"&>\", which is inter
face to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "                 fu
nction evaluate; works only with the default set of generators`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     local LA, LB, i;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "     ##
# if we have sum, look at leading terms, if constant multiplier, send \+
only expression part" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "     if( ty
pe(A, `+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        LA := \+
leading(A, ALGEBRA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "        LA := A;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   \+
  if( type(LA, `*`) ) then\n" }{MPLTEXT 1 0 26 "        # Correction 2
019\n" }{MPLTEXT 1 0 25 "        # LA := op(2,LA);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 27 "        LA := PickTerm(LA);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "     if( type(B, `+`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        LB := leading(B, ALGEBRA);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "        LB := B;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 
"     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "     if( type(LB,`*`) \+
) then\n" }{MPLTEXT 1 0 26 "        # Correction 2019\n" }{MPLTEXT 1 
0 25 "        # LB := op(2,LB);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "
        LB := PickTerm(LB);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     \+
fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "     if( hastype(GENERATORS,indexed) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 91 "        RETURN(evalb(tcoeff(indexedrankin
g(LA,ALGEBRA) - indexedranking(LB,ALGEBRA)) > 0));" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "    \+
    RETURN(evalb(normalranking(LA,ALGEBRA) > normalranking(LB,ALGEBRA)
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "LieAlg[`&=`] := proc(A::al
gebraic, B::algebraic) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     opt
ion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "     description `monomial &= monom
ial defines the operator \"&=\", which is interface to the " }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 84 "                 function evaluate; works \+
only with the default set of generators`; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "     local LA, LB;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "     ### if we have sum, loo
k at leading terms, if constant multiplier, send only expression part"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "     if( type(A, `+`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        LA := leading(A, ALGEBRA);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "        LA := A;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 
"     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "     if( type(LA, `*`)
 ) then\n" }{MPLTEXT 1 0 26 "        # Correction 2019\n" }{MPLTEXT 1 
0 25 "        # LA := op(2,LA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "
        LA := PickTerm(LA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     \+
fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "     if( type(B, `+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "        LB := leading(B, ALGEBRA);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   \+
     LB := B;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 29 "     if( type(LB,`*`) ) then\n" }{MPLTEXT 
1 0 26 "        # Correction 2019\n" }{MPLTEXT 1 0 25 "        # LB :=
 op(2,LB);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "        LB := PickTer
m(LB);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "     RETURN
(evalb([extract(LA, ALGEBRA)] = [extract(LB, ALGEBRA)]));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "LieAlg[`&<=`] := p
roc(A::algebraic, B::algebraic) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 
"     option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag
.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "     description `monomial &
< monomial defines the operator \"&<=\", which is interface to the " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "                 function evaluate
; works only with the default set of generators`; " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "     RETURN(n
ot(A &> B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "LieAlg[`&>=`] := proc(A::algebraic, B::algebraic) " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     option `Copyright (C) 1999-20
19 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 93 "     description `monomial &> monomial defines the operator \"
&>=\", which is interface to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
83 "                 function evaluate; works only with the default se
t of generators`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 26 "     RETURN(not(A &< B)); " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "LieAlg[`&<>`] := proc(A::
algebraic, B::algebraic) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     o
ption `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "     description `monomial &= monom
ial defines the operator \"&<>\", which is interface to the " }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 84 "                 function evaluate; works
 only with the default set of generators`; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "     RETURN(not
(A &= B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "LieAlg_Hidden[`&!<`] := proc(A::list, B::list) " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Bil
lig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "     de
scription `list &!< list defines the operator \"&!<\", which is interf
ace to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                 fun
ction comparewts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 33 "     RETURN(comparewts(A,`<`,B));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 48 "LieAlg_Hidden[`&!!<`] := proc(A::list, B::list) " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly \+
Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "    \+
 description `list &!!< list defines the operator \"&!!<\", which is i
nterface to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "               \+
  function revcomparewts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "     RETURN(revcomparewts(A,`<`,B))
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "LieAlg_
Hidden[`&!>`] := proc(A::list, B::list) " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Billig and Matya
s Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "     description `li
st &!> list defines the operator \"&!>\", which is interface to the " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                 function compare
wts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "     RETURN(comparewts(A,`>`,B));" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "L
ieAlg_Hidden[`&!!>`] := proc(A::list, B::list) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Billig a
nd Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "     descrip
tion `list &!!> list defines the operator \"&!!>\", which is interface
 to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "                 functi
on revcomparewts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 36 "     RETURN(revcomparewts(A,`>`,B));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "LieAlg_Hidden[`&
!<=`] := proc(A::list, B::list) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 
"     option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag
.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "     description `list &!<= \+
list defines the operator \"&!<=\", which is interface to the " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                 function comparewt
s`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "     RETURN(evalb(comparewts(A,`<`,B) or (A = B)));" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "LieAlg_
Hidden[`&!>=`] := proc(A::list, B::list) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Billig a
nd Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "     descrip
tion `list &!>= list defines the operator \"&!>=\", which is interface
 to the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                 functi
on comparewts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 51 "     RETURN(evalb(comparewts(A,`>`,B) or (A = B
)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "L
ieAlg_Hidden[`&!=`] := proc(A::list, B::list) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "     option `Copyright (C) 1999-2019 by Yuly Billig a
nd Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "     descrip
tion `list &!= list defines the operator \"&!=\", which is interface t
o the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                 function
 comparewts`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 26 "     RETURN(evalb(A = B));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "LieAlg_Hidden[`&!<>`] := pr
oc(A::list, B::list) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     optio
n `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "     description `List &!<> list de
fines the operator \"&!<>\", which is interface to the " }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 40 "                 function comparewts.`; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "     RETURN(evalb(A <> B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "e
nd:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "#####################>  oper
ator definitions end" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "####################
#>  debugging stuff" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "LieAlg_Hidde
n[dump] := proc() " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Co
pyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 80 "   description `debugging tool, dumps a proc
edures hash table (remember table)`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   ### check to see if pro
cedure exist" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "   if( nargs > 0 an
d type(args[1], procedure) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 
"      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "      ### there could be
 no table associated with the procedure" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 45 "      if( op(4, eval(args[1])) <> NULL ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 38 "         RETURN(op(4, eval(args[1])));" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 49 "      ### there is no table assoc. with t
he proc." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 22 "         RETURN(NULL);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   ### proc. doesn't exist" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "      RETURN(FAIL);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 7 "   fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 43 "#####################>  debugging stuff end" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "#####################>  algebra def
initions follow" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "LieAlg_Hidden[al
gebra] := proc()" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copy
right (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 74 "   description `Algebra() is used to store alg
ebras in its lookup table.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   \+
remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
51 "LieAlg[generators] := proc(Label::name,Gens::list) " }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Bil
lig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "   desc
ription `generators(algname, \{generators\}[,[weights]]) uses its reme
mber-table to store" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "            \+
   the different sets of generators in a table form; everytime a new s
et of " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "               generators
 is added, the list GENERATORS is set to that list by default`; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 31 "   global GENERATORS, ALGEBRA; " }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 55 "   local Defwt, i, Temp, SortByDegWt, SortByDeg
Gen, k; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "      " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 25 "   ### too many arguments" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 65 "   if (nargs > 3) then ERROR(`too many arguments %1.`
, args); fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 46 "   ### a special weight is defined by the user" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if (nargs = 3) then " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "     \+
 ### received something other than a list of weights" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 47 "      if( not(type(args[3],list(list))) ) then " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "         ERROR(`expected list, re
ceived %1.`, args[3]); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "      ### we have a list of weights
, lets validate them further" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   \+
   else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "         ### looping th
rough the weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "         for i
 to nops(args[3]) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 77 "            ### checking for different leng
ths for weights (which is invalid)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
29 "            if( i >= 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
64 "               if( nops(args[3][i-1]) <> nops(args[3][i]) ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "                  ERROR(`weights \+
%1 and %2 are of different length.`,args[3][i-1],args[3][i]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 12 "         od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "        " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         ### approved" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 27 "         Defwt := args[3]; " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "   ### otherwise need to create de
fault weights for generators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   e
lse " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "      Defwt := [seq([seq(0,
i=1..i-1),1,seq(0,i=i+1..nops(Gens))],i=1..nops(Gens))];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 7 "   fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "
   ### sorting weights and generators by the degree of their weights" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 115 "   if( not(hastype(Defwt,`name`)
) and member(`false`,map((e,f)->evalb(f=e),Defwt[2..nops(Defwt)],Defwt
[1])) ) then\n" }{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 
24 "# Use REVERSE Lex order\n" }{MPLTEXT 1 0 2 "# " }{MPLTEXT 1 0 47 "
Temp := [seq([Defwt[i][],i],i=1..nops(Defwt))];" }{MPLTEXT 1 0 1 "\n" 
}{MPLTEXT 1 0 2 "# " }{MPLTEXT 1 0 32 "SortByDegWt := sort(Temp,`&!>`)
;" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 2 "# " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 53 "      Temp := [seq([i,Defwt[i][]],i=1..nops(Defwt))];
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      SortByDegWt := sort(Temp,
`&!!<`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "      SortByDegGen := m
ap(proc(x,y,z) if(member(x,y,'k')) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 49 "                                          z[k]; \n" }{MPLTEXT 
1 0 19 "# Correction 2019 \n" }{MPLTEXT 1 0 2 "# " }{MPLTEXT 1 0 57 "f
i; end,Temp,SortByDegWt,Gens); #used inverse permutation" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 58 "                                      fi; end
,SortByDegWt," }{MPLTEXT 1 0 5 "Temp," }{MPLTEXT 1 0 7 "Gens);\n" }
{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 49 "# Drop the fir
st entry in the list, not the last\n" }{MPLTEXT 1 0 2 "# " }{MPLTEXT 
1 0 52 "SortByDegWt := [seq(i[1..nops(i)-1],i=SortByDegWt)];" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 56 "      SortByDegWt := [seq(i[2..nops(i)],i
=SortByDegWt)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 27 "      SortByDegWt := Defwt;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 27 "      SortByDegGen := Gens;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### entries going into the tabl
e:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "   ### defining algebra name \+
and corresponding generators, form: algname = generator-list" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 38 "   algebra(Label) := op(SortByDegGen):" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "   ### inserting weight into table
, form: (algname,'weight')=[weight-list]" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 42 "   algebra(Label,`weight`) := SortByDegWt:" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 57 "   ### registering the default ordering of the gen
erators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "#   algebra(Label, order
) := nops(SortByDegWt):" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   ### also have to add entries to \+
the ideal table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ideal(Label,S
ortByDegGen,Label);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 61 "   ### idealname and its generators, form: a
lgname = gen-list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "#   ### ideal'
s generators' alg, form: (algname,'algebra') = algname" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 36 "#   ideal(Label,`algebra`) := Label:" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   #
## output to user" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   using(Label
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   RETURN(Label=Gens,Defwt);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "LieAlg
[directsum] := proc(Label::name,Algs::list(algebra)) " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billi
g and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "  descrip
tion `directsum(dirsumname, \{alg1, alg2\}) This function produces a d
irectsum of two " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "              a
lgebras; calling sequence:  directsum([name of dir.sum. alg],\{set of \+
(two) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "              algebras\})
`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "  ### declarations" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 82 "  local Table, Weight1, Weight2, DefWeigh
t, i, SortByDegWt, SortByDegGen, AlgL, k;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "  ### let it remember stuff" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 11 "  remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "  ### called with too many argument
s" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "  if( nargs > 2 ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "     ERROR(`too many arguments %1.`
, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "  else" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 30 "     if( nops(Algs) = 1 ) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 34 "        AlgL := [Algs[], ALGEBRA];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "
        AlgL := Algs;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "     ### getting generators table"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "     Table := op(4,eval(algebra)
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "     ### entry going into tab
le of the form: dirsum.alg. = alg1,alg2" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "     directsum(Label) := AlgL[1],AlgL[2]:" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "     ### getti
ng the weights for the algebras" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "
     Weight1 := [op(Table[(AlgL[1],`weight`)])];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "     Weight2 := [op(Table[(AlgL[2],`weight`)])];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
59 "     ### if weights are of the same length concatenate them" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "     if( nops(Weight1[1]) = nops(We
ight2[1]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "         DefWei
ght := [op(Weight1),op(Weight2)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "     ### otherwise make them t
he same length" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         ### weights in Weight1 are
 longer" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "         if( nops(Weight
1[1]) > nops(Weight2[1]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "
            DefWeight := [seq([seq(0,i=1..nops(Weight1[1]))],i=1..nops
(Weight1)+nops(Weight2))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "         ### weights in Weight2 are
 longer  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "            DefWeight := [seq([seq(
0,i=1..nops(Weight2[1]))],i=1..nops(Weight1)+nops(Weight2))];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "         ### ad
ding in the first algebra's weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
34 "         for i to nops(Weight1) do" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 70 "            DefWeight[i] := zip((x,y)->x+y,DefWeight[i],Weight
1[i],0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 51 "         ### adding in the second algebra'
s weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "         for i to nops
(Weight2) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "            DefWeig
ht[i+nops(Weight1)] := zip((x,y)->x+y,DefWeight[i+nops(Weight1)],Weigh
t2[i],0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "    ### sorting weights and \+
generators by the degree of their weights" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "#    if( hastype(DefWeight,name) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 32 "       SortByDegWt := DefWeight;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 55 "       SortByDegGen := [Table[AlgL[1]],Table
[AlgL[2]]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "#    else" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 68 "#       DefWeight := [seq([DefWeight[i][],i
],i=1..nops(DefWeight))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "#     \+
  SortByDegWt := sort(DefWeight,`&!>`);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 45 "#       SortByDegWt := sort(DefWeight,`&!<`);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 64 "#       SortByDegGen := map(proc(x,y,z) if(membe
r(x,y,'k')) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "#              \+
                           z[k]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
104 "#                                       fi; #end,DefWeight,SortBy
DegWt,[Table[AlgL[1]],Table[AlgL[2]]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 60 "#       SortByDegWt := [seq(i[1..nops(i)-1],i=SortByDegWt)];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "#    fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "    ### also cr
eating an entry in the generators table" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 39 "    algebra(Label) := op(SortByDegGen):" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "    ### entry going in the table" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 44 "    algebra(Label, `weight`) := SortByDegWt:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "#    algebra(Label, order) := nops(
SortByDegWt): " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 23 "    ### output for user" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "    RETURN(using(Label));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 5 "  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 58 "LieAlg[ideal] := proc(Label::name, Gens::list(algebr
aic)) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) \+
1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "   description `ideal(idealname, idealgens) let's the
 user define an ideal`; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "    ###
 declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "    global IDEAL;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "    local Alg, i; " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 29 "    ### let it remember stuff" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 14 "    remember; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "    ### called with too ma
ny arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "    if( nargs > 3 )
 then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "       ERROR(`too many ar
guments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    ### giv
en an algebra to be used" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    eli
f( nargs = 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       Alg :
= args[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 22 "       Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "    if( not(type(Alg,algebra)) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "       ERROR(`expecting an al
gebra's name, received %1.`, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
56 "    elif( member([],map((x,y)->wt(x,y),Gens,Alg)) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 69 "       ERROR(`generators %1 of the ideal \+
are not homogenous.`, Gens);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    \+
else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "       ### entries going in
to the table:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "       ideal(Label
) := op(Gens):       ### generators for the given ideal" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 82 "       ideal(Label, `algebra`) := Alg: ### alg
ebra of the generators for the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "       unprotect(evaln(IDE
AL)); IDEAL := Label; protect(evaln(IDEAL));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       ### some
 output to user" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "       RETURN(La
bel = Gens);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "LieAlg[quotalg] :=
 proc(Label::name, Ideal::ideal) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "   description `quotalg(quo
talgname, idealname, algname(optional)) This" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "               function defines a quotient algebra of
 an ideal and its algebra`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   #
## declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   global ALGEBR
A, IDEAL;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   local Algebra;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### let it remember stuff" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ### get the \+
algebra of the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   Algebra \+
:= op(4,eval(ideal))[Ideal,`algebra`];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### called with too m
any arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   if( nargs > 3 )
 then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`too many arg
uments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 67 "   ### the third arg. can only be the cut of
f weights for the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif(
 nargs = 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      if( not(
type(args[3],list(integer))) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
96 "         ERROR(`list of integers is expected for the cut off weigh
t, but received %1.`,args[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 " \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 104 "         quotalg(Labe
l,`stableset`) := args[3], stableset([op(4,eval(ideal))[Ideal]], args[
3], Algebra):" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### place entries in the \+
table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "   ### names of the ideal \+
and algebra for quotient algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 
"   quotalg(Label) := Algebra, Ideal:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 54 "   ### registering the generators for the quotient alg" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 91 "   generators(Label,[op(4,eval(algebra))[
Algebra]], op(4,eval(algebra))[Algebra,`weight`]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   ### return
 some output" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   RETURN(using(Lab
el));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "
LieAlg[triangular] := proc(Label::name, List::list(name))" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly B
illig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "   de
scription `allows the construction of algebras with triangular decompo
sition`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 113 "   local i, j, k, Tabl
e, Wp, Wh, Wn, Gp, Gn, Gh, Temp, Lp, Ln, H, Len, Entries, SortByDegWt,
 SortByDegGen, Defwt;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "   ### mem
ory" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   ### ge
tting the generators for the algebras" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 33 "   Table := op(4, eval(algebra));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   ### if there are entr
ies...." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   if( Table <> NULL ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "      ### selecting algebras
 without knowing the order they came in" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 83 "      if( member([List[1]],[indices(Table)]) and member([List[
2]],[indices(Table)])" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "        an
d member([List[3]],[indices(Table)]) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "         ### fi
rst one is H" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "         if( Table[
(List[1], `weight`)][1] = [seq(0,i=Table[(List[1], `weight`)][1])] ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "            H := List[1];" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "            ### second is Lminus" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 100 "            if( (Table[(List[2],
 `weight`)][1]) &!<= [seq(0,i=Table[(List[2], `weight`)][1])] ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "               Ln := List[2];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "               Lp := List[3];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "            ### second is Lplus" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 29 "               Lp := List[2];" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 29 "               Ln := List[3];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         ### second one is H" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "         elif( (Table[(List[2], `w
eight`)][1]) = [seq(0,i=Table[(List[2], `weight`)][1])] ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "            H := List[2];" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 31 "            ### first is Lminus" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 100 "            if( (Table[(List[1], `weight
`)][1]) &!<= [seq(0,i=Table[(List[1], `weight`)][1])] ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 29 "               Ln := List[1];" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 29 "               Lp := List[3];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 30 "            ### first is Lplus" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 29 "               Lp := List[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 29 "               Ln := List[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 42 "         ### we're assuming the third is H
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 25 "            H := List[3];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "            ### first is Lminus" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 100 "            if( (Table[(List[1], `weight`)][1]) &!<=
 [seq(0,i=Table[(List[1], `weight`)][1])] ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "               Ln := List[1];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "               Lp := List[2];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "            ### first is Lplus" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
29 "               Lp := List[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
29 "               Ln := List[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 33 "      ### an algebra wasn't found" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "    \+
     ERROR(`one of the algebras from %1 is not defined in generators()
.`, List);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "      \+
### checking restrictions on positive algebra's weights (they have to \+
be non-negative)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      Wp := Tab
le[(Lp, `weight`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      Len :=
 nops(Wp[1]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      for i to nop
s(Wp) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "         if( hastype(Wp
[i], negative) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "          \+
  ERROR(`negative weight %1 is not allowed for algebra.`);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 40 "         elif( nops(Wp[i]) <> Len ) then" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "            ERROR(`weights %1 and \+
%2 have different lengths.`,Wp[1],Wp[i]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "   \+
   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "      ### checking restrictions on alg. with supposed
 all zero weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      Wh := Ta
ble[(H, `weight`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      for i \+
to nops(Wh) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "         if( Wh[i
] &!<> [seq(0,i=Wh[i])] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 " \+
           ERROR(`only zero weights are allowed for algebra %1.`, H);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "         elif( nops(Wh[i]) <> Le
n ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "            ERROR(`weig
hts %1 and %2 have different lengths.`, Wp[1], Wh[i]);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 92 "      ### checking restrictions on negative algebra
's weights (they have to be non-positive)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "      Wn := Table[(Ln, `weight`)];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 26 "      for i to nops(Wn) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "         if( hastype(Wn[i], positive) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "            ERROR(`positive weight \+
is not allowed for algebra %1.`, Ln);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 40 "         elif( nops(Wn[i]) <> Len ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "            ERROR(`weights %1 and %2 have different l
engths.`,Wp[1], Wn[i]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "        \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      ### we
 might have been sent some rules already set up" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      if( nargs = 3 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "         if( type(args[3], list) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 47 "            store([args[3][], Label],`silent`
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 73 "            ERROR(`rules are expected in a list
, received %1.`, args[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "     \+
    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      ###
 retriveing the generators for each algebra" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "      Gp := [Table[Lp]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "      Gn := [Table[Ln]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "      Gh := [Table[H]];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 6 "      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 100 "      ### and ge
tting the lookup table to check whether we set up all the rules if the
y were sent in" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      Table := op
(4, eval(withrules));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "      if( \+
Table <> NULL and member([Label],[indices(Table)]) ) then" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 33 "         Entries := Table[Label];" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 23 "         Entries := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 " \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "      ### delete the remember table, since we'll be l
ooking up values from it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      r
esettabs([functionize]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      ### looking at the weights of
 the generators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      for i to n
ops(Gp) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         for j to nop
s(Gn) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "            ### we didn
't find the rule, add it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "       \+
     if( functionize(evaln(Gp[i]&*Gn[j]),Label) = FAIL ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "               if( wt(Gp[i], Lp) <>
 -(wt(Gn[j], Ln)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "       \+
           store([evaln(Gp[i]&*Gn[j])=0, Label],`silent`);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 60 "               elif( wt(Gp[i], Lp) = -(wt(G
n[j], Ln)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "              \+
    Temp := readstat(cat(convert(Gp[i], string),`&*`,convert(Gn[j], st
ring),` = `));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "                 \+
 store([evaln(Gp[i]&*Gn[j])=Temp, Label]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "      ### promp
ting user for rules for intersection of H and Lp (pos. lie algebra)" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "      ### and for rules for inters
ection of H and Ln (neg. lie algebra)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 26 "      for i to nops(Gh) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 
"         ### looping through pos. algebra" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "         for j to nops(Gp) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "            ### we didn't find the rule, add it" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "            if( functionize(evaln(G
h[i]&*Gp[j]),Label) = FAIL ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
95 "               Temp := readstat(cat(convert(Gh[i], string),`&*`,co
nvert(Gp[j], string),` = `));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "  \+
             store([evaln(Gh[i]&*Gp[j])=Temp, Label]);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 12 "         od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 41 "         ### looping through neg. algebra" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         for j to nops(Gn) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "            ### we didn't find the \+
rule, add it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "            if( fun
ctionize(evaln(Gh[i]&*Gn[j]),Label) = FAIL ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 95 "               Temp := readstat(cat(convert(Gh[i], s
tring),`&*`,convert(Gn[j], string),` = `));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "               store([evaln(Gh[i]&*Gn[j])=Temp, Label
]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 12 "         od;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "         ### producing t
he rules for the intersection of H with generators from itself" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "         ### (H[i]&*H[j]=0 for all \+
i,j)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "         for j from i to no
ps(Gh) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "            ### we did
n't find the rule, add it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "      \+
      if(functionize(evaln(Gh[i]&*Gh[j]),Label) = FAIL ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "               store([evaln(Gh[i]&*
Gh[j])=0, Label],`silent`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "    \+
        fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "      ### sorti
ng weights and generators by the degree of their weights" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 47 "      if( hastype([Wp[],Wh[],Wn[]],name) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "         SortByDegWt := [Wp[]
,Wh[],Wn[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         SortByDegG
en := [Gp[],Gh[],Gn[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      el
se" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "         Defwt := [seq([[Wp[]
,Wh[],Wn[]][i][],i],i=1..nops([Wp[],Wh[],Wn[]]))];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 43 "#         SortByDegWt := sort(Defwt,`&!>`);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         SortByDegWt := sort(Defwt,
`&!<`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "         SortByDegGen :=
 map(proc(x,y,z) if(member(x,y,'k')) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "                                           z[k]; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "                                   \+
      fi; end,Defwt,SortByDegWt,[Gp[],Gh[],Gn[]]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 61 "         SortByDegWt := [seq(i[1..nops(i)-1],i=Sort
ByDegWt)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "   \+
   ### adding the gen-s of the three alg-s as the gen-s of our produce
d triang. alg." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      algebra(Lab
el):=op(SortByDegGen):" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      alg
ebra((Label, `weight`)):=SortByDegWt:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 49 "#      algebra(Label, order):= nops(SortByDegWt):" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "      ##
# storing our algebras in the procedure's remember table" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 37 "      triangular(Label) := Ln, H, Lp:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
31 "      ### returning some output" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "      RETURN(using(Label));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 " \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "
LieAlg[KacMoody] := proc(Label::name, Cartan::anything)" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Bil
lig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   desc
ription ``;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "   local i, j, M, Wts, Gens, n, \+
Rules, DefGens, Lp, Lm, Lz, SerreP, SerreM, TempP, TempM, Temp, k;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "   ### memory" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   ### inputcheck" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 23 "   if( nargs > 4 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif( nargs = 4 ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 22 "      Gens := args[3];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "      Wts := args[4];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      Ge
ns := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      Wts := [];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "   ### we hopefuly got \+
a matrix, if not, we can try to convert it" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "   if( type(Cartan, Matrix) ) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 18 "      M := Cartan;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 105 "   elif( type(Cartan, matrix) or type(Cartan, list) or type(C
artan, array) or type(Cartan, vector) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "      M := convert(Cartan, Matrix);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 95 "    \+
  ERROR(`expected argument of type Matrix (or matrix, list, array), re
ceived %1.`, Cartan);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
44 "   ### checking the dimensions of the matrix" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 94 "   if( nops(convert((linalg[row](M,1),list))) <> nops
(convert((linalg[col](M,1),list))) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "      ERROR(`%1 is not a square matrix.`, Cartan);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "      n := LinearAlgebra[RowDimension](M);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### checking the matrix res
trictions" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### 1) diagonal ent
ries have to be 2" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "   ### 2) all \+
other entries less then or equal to 0" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 35 "   ### 3) M[i,j] = 0 <=> M[j,i] = 0" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "   for i to n do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "      for j to i do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "        \+
 if( i <> j ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "            i
f( M[i,j] > 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "           \+
    ERROR(`%1 is a positive value outside the diagonal in the cartan m
atrix.`, M[i,j]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "            el
if( M[i,j] = 0 and not(M[j,i] = 0) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 85 "               ERROR(`zeros are not in a symmetrical \+
fashion in the cartan matrix.`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 
"            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "         elif( \+
i = j and not(M[i,j] = 2) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 
"            ERROR(`diagonal entry %1 in cartan matrix.`, M[i,j]<>2); \+
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   \+
od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "   ### creating subscripted default generators" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( Gens = [] ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 25 "      DefGens := [f,h,e];" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 91 "      Gens := map(proc(x,y) map(proc(x,y) y[x]; e
nd, y, x); end, DefGens, [seq(i,i=1..n)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 58 "   ### picking out the L+, L- and H algeb
ras from the list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   Lm := Gens[
1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   Lz := Gens[2];" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 18 "   Lp := Gens[3]; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   ### making t
he algebras visible" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   if( Wts =
 [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      generators(cat(
Label,`_free_plus`), Lp);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      \+
Wts := [seq([seq(0,i=Lz)],i=Lz)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
46 "      generators(cat(Label,`_zero`), Lz, Wts);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 47 "      for i to nops(Wts) do Wts[i,i] := -1; od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      generators(cat(Label,`_free_m
inus`), Lm, Wts);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      generators(cat(Label,`_free_p
lus`), Lp, Wts);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "      generator
s(cat(Label,`_free_minus`), Lm, -Wts);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 68 "      generators(cat(Label,`_zero`), Lz, [seq([seq(0,i=i)],i=W
ts)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### so the
 loop wouldn't crash" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   if( nops
(Lp) <> n or nops(Lm) <> n or nops(Lz) <> n ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 83 "      ERROR(`incorrect number of generators for the
 cartan matrix of size %1.`, n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "   ### setting up the rules (e[i]: Lp, f[i]: Lm, h[i]
:Lz)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   ### h[i]&*e[j] = M[i,j]*
e[j]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### h[i]&*f[j] = -M[i,j]
*e[j]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### e[i]&*f[j] = if(i=j
) h[i] else 0" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   ### and Serre's
 relations for the plus and minus algebra" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "   Rules := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 
"   SerreP := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   SerreM := [
];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   for i to n do" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 19 "      for j to n do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "         if( i = j ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 92 "            Rules := [Rules[], evaln(Lp[i]&*Lm[i])=Lz
[i], evaln(Lz[i]&*Lp[j])=M[i,j]*Lp[j]];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 89 "            Rules := [Rules[], evaln(Lz[i]&*Lm[j])=-M[i,j]*Lm[
j], evaln(Lz[i]&*Lz[j])=0];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "    \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "            Rules := [
Rules[], evaln(Lp[i]&*Lm[j])=0, evaln(Lz[i]&*Lz[j])=0];" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 93 "            Rules := [Rules[], evaln(Lz[i]&*Lp
[j])=M[i,j]*Lp[j], Lz[i]&*Lm[j]=-M[i,j]*Lm[j]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "            ###
 creating the Serre's relations for both Lplus and Lminus algebras" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "            TempP := Lp[j]; TempM :
= Lm[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "            for k to 1-
M[i,j] do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "               TempP \+
:= evaln(Lp[i] &* TempP); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "     \+
          TempM := evaln(Lm[i] &* TempM); " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 
"            SerreP := [SerreP[], TempP];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "            SerreM := [SerreM[], TempM];" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   \+
### storing the ideals" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "   ideal(
cat(Label,`_plus_ideal`), SerreP, cat(Label,`_free_plus`));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 70 "   ideal(cat(Label,`_minus_ideal`), SerreM
, cat(Label,`_free_minus`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### creating quotient algebras" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "   quotalg(cat(Label,`_plus`), ca
t(Label,`_plus_ideal`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   quot
alg(cat(Label,`_minus`), cat(Label,`_minus_ideal`));" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "   ### stor
ing our matrix and creating a global variable for it" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 30 "   KacMoody(Label) := eval(M):" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 26 "   `A_`||Label := eval(M);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   ### if we al
ready have a default triangular algebra defined, delete its rules" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   if( type(Label,withrules) ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "      store([Label],`silent`);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   ### form the
 triangular decomposition of the algebra" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 99 "   RETURN(triangular(Label, [cat(Label,`_plus`), cat(Label,`_
zero`), cat(Label,`_minus`)], Rules));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "LieAlg[roots
] := proc(Cartan::name)\n" }{MPLTEXT 1 0 3 "   " }{MPLTEXT 1 0 78 "opt
ion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remem
ber;\n" }{MPLTEXT 1 0 3 "   " }{MPLTEXT 1 0 48 "description `creates a
 list of positive roots`;\n" }{MPLTEXT 1 0 3 "   " }{MPLTEXT 1 0 90 "l
ocal CMat, n, m, i, cur, allroots, newroots, zvec, bufroots, rt, newve
c, j, marks, bound;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "   ### memor
y" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "   # remember;\n" }{MPLTEXT 1 
0 1 "\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ### we hopefuly got a
 supported type for the Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 93 "   if( not(type(Cartan,indexed)) or nops(Cartan) <> 1 or not(typ
e(op(Cartan),integer)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "  \+
    ERROR(`%1 is an incorrect name for type of Cartan matrix.`, Cartan
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "      n := op(Cartan);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 55 "      if( op(0,Cartan) = A ) then CMat := Anmat(n); fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      if( op(0,Cartan) = B ) then C
Mat := Bnmat(n); fi;\n" }{MPLTEXT 1 0 56 "      if( op(0,Cartan) = C )
 then CMat := Cnmat(n); fi;\n" }{MPLTEXT 1 0 56 "      if( op(0,Cartan
) = D ) then CMat := Dnmat(n); fi;\n" }{MPLTEXT 1 0 56 "      if( op(0
,Cartan) = E ) then CMat := Enmat(n); fi;\n" }{MPLTEXT 1 0 56 "      i
f( op(0,Cartan) = F ) then CMat := Fnmat(n); fi;\n" }{MPLTEXT 1 0 55 "
      if( op(0,Cartan) = G ) then CMat := Gnmat(n); fi;" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 22 "      allroots := [];
\n" }{MPLTEXT 1 0 22 "      newroots := [];\n" }{MPLTEXT 1 0 27 "     \+
 for i from 1 to n do\n" }{MPLTEXT 1 0 17 "         newvec:=" }
{MPLTEXT 1 0 15 "[seq(0,i=1..n)]" }{MPLTEXT 1 0 2 ";\n" }{MPLTEXT 1 0 
23 "         newvec[i]:=1;\n" }{MPLTEXT 1 0 43 "         newroots := [
newroots[], newvec];\n" }{MPLTEXT 1 0 10 "      od;\n" }{MPLTEXT 1 0 
1 "\n" }{MPLTEXT 1 0 36 "      while (nops(newroots) > 0) do\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 47 "         al
lroots := [allroots[], newroots[]];\n" }{MPLTEXT 1 0 31 "         bufr
oots := newroots;\n" }{MPLTEXT 1 0 25 "         newroots := [];\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 43 "         for j from 1 to nops(bu
froots) do\n" }{MPLTEXT 1 0 31 "            rt := bufroots[j];\n" }
{MPLTEXT 1 0 38 "            marks := CMat.Vector(rt);\n" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 33 "            for i from 1 to n do\n" }
{MPLTEXT 1 0 24 "               cur := rt" }{MPLTEXT 1 0 1 ";" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 35 "               bound := -marks[i
];\n" }{MPLTEXT 1 0 40 "               for m from 1 to bound do\n" }
{MPLTEXT 1 0 40 "                  cur[i] := cur[i] + 1;\n" }{MPLTEXT 
1 0 88 "                  if ((not member(cur, allroots)) and (not mem
ber(cur, newroots))) then\n" }{MPLTEXT 1 0 52 "                     ne
wroots := [newroots[], cur];\n" }{MPLTEXT 1 0 22 "                  fi
;\n" }{MPLTEXT 1 0 20 "               end;\n" }{MPLTEXT 1 0 17 "      \+
      end;\n" }{MPLTEXT 1 0 15 "          end;\n" }{MPLTEXT 1 0 12 "  \+
     end;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 50 "       RETURN(map(
x->convert(x,list), allroots));\n" }{MPLTEXT 1 0 22 "    fi;          \+
    \n" }{MPLTEXT 1 0 5 "end:\n" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 
1 0 49 "LieAlg[simple] := proc(Label::name, Cartan::name)" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly B
illig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   de
scription `supports the declaration of simple algebras`;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "   global e, h;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 
"   local i, j, Gens, n, Wts, Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "   ### memory" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 17 "   ### inputcheck" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( n
args > 4 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`too
 many arguments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   e
lse" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      Gens := ['e','h'];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      Wts := [];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 17 "      Temp := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 30 "      for i from 3 to nargs do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 35 "         Temp := [Temp[], args[i]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 66 "         if( type(args[i],list(name)) and nops(args[i
]) = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "            Gens :
= args[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "         elif( type(a
rgs[i],list(list)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "      \+
      Wts := args[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         e
lse" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 106 "            ERROR(`invalid \+
parameter %1 (expected a list of generators and a list of weights).`, \+
args[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 61 "   ### we hopefuly got a supported type for the Cart
an matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "   if( not(type(Cartan
,indexed)) or nops(Cartan) <> 1 or not(type(op(Cartan),integer)) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "      ERROR(`%1 is an incorrec
t name for type of Cartan matrix.`, Cartan);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      n \+
:= op(Cartan);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      if( op(0,Ca
rtan) = B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "         simple
(cat(Label,`_unfolded`), D[n+1], Temp[]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "      elif( op(0,Cartan) = C ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 58 "         simple(cat(Label,`_unfolded`), A[2*n-1],
 Temp[]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      elif( Cartan = F
[4] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "         simple(cat(L
abel,`_unfolded`), E[6], Temp[]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "      fi;    " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "   ### creating subscripted default generators and weights" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "   Gens := [Gens[1][seq(`k`||j,j=1.
.n)], Gens[2][`i`||1]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   if( W
ts = [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      Wts := [[se
q(`k`||j,j=1..n)],[seq(0,j=1..n)]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      Wts := [Wts[1],
 [seq(0,j=1..nops(Wts[1]))]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   \+
fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "   ### making the matrix available globally" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 88 "   `A_`||Label := eval(regmatrix(Label, o
p(0,Gens[1]), op(0,Gens[2]), op(0,Cartan), n));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   ### register
ing the algebras" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   RETURN(gener
ators(Label, Gens, Wts));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 51 "LieAlg[affine] := proc( Label::name, Cartan::name \+
)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-
2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 68 "   description `supports the declaration of affine simple alg
ebras`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   global e, h, K, k;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 37 "   local i, j, r, Gens, n, Wts, Temp;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "   ### memory" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   ### inputcheck" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 23 "   if( nargs > 4 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "      Gens := ['e','h','K'];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      Wts := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
17 "      Temp := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "      for \+
i from 3 to nargs do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "         Te
mp := [Temp[], args[i]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "       \+
  if( type(args[i],list(name)) and nops(args[i]) = 3 ) then" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 28 "            Gens := args[i];" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 12 "            " }{MPLTEXT 1 0 43 "Temp[nops(T
emp)] := Temp[nops(Temp)][1..2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 
"         elif( type(args[i],list(list)) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "            Wts := args[i];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 106 "
            ERROR(`invalid parameter %1 (expected a list of generators
 and a list of weights).`, args[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ### we hopefuly got \+
a supported type for the Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 93 "   if( not(type(Cartan,indexed)) or nops(Cartan) <> 1 or not(t
ype(op(Cartan),integer)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "
      ERROR(`%1 is an incorrect name for type of Cartan matrix.`, Cart
an);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 22 "      n := op(Cartan);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 58 "   ### creating subscripted default generators an
d weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   k := 'k';" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 73 "   Gens := [Gens[1][seq(`r`||j,j=1..n), k
], Gens[2][`i`||1, k], Gens[3]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 
"   if( Wts = [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      Wt
s := [[seq(`r`||j,j=1..n), k], [seq(0,j=1..n), k], [seq(0,j=1..n+1)]];
\n" }{MPLTEXT 1 0 20 "#### Correction 2019" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 11 "####   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 106 "##
##      Wts := [Wts[1], [seq(0,j=1..nops(Wts[1])-1), Wts[1][nops(Wts[1
])]], [seq(0,j=1..nops(Wts[1]))]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "   ### making the matrix available globally and regis
tering the algebra\n" }{MPLTEXT 1 0 21 "   # Correction 2019\n" }
{MPLTEXT 1 0 21 "   if Temp = [] then\n" }{MPLTEXT 1 0 21 "      Temp \+
:= [Wts];\n" }{MPLTEXT 1 0 7 "   fi;\n" }{MPLTEXT 1 0 19 "   Temp:=sub
s(k=0, " }{MPLTEXT 1 0 30 "seq(`r`||i = `k`||i, i=1..n), " }{MPLTEXT 
1 0 7 "Temp);\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }{MPLTEXT 1 
0 71 "affine(Label) := op(1,[simple(cat(Label,`_simple`),Cartan,Temp[]
)][1]):" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "   ### registering the algebra with the generators ta
ble" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   RETURN(generators(Label, \+
Gens, Wts));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }{TEXT 219 0 "
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 94 "LieAlg_Hidden[regmatrix] := proc( label::name, \+
gens1::name, gens2::name, t::name, n::integer )" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "   description
 `generates and registers with simple() a matrix of given type and siz
e`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### create A
[n] Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   if( t = A )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "      M := Anmat(n);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      simple(label,type) := `ADE_ma
trix`, `type_A`:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 32 "   ### create D[n] Cartan matrix" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 21 "   elif( t = D ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "      M := Dnmat(n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 51 "      simple(label,type) := `ADE_matrix`, `type_D`:" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ###
 create E[n] Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   el
if( t = E ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "      M := Enma
t(n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      simple(label,type) :
= `ADE_matrix`, `type_E`:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### create B[n] Cartan matrix" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   elif( t = B ) then" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 20 "      M := Bnmat(n);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "      simple(label,type) := `B_matrix`, `type_D`:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
32 "   ### create C[n] Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 21 "   elif( t = C ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "    \+
  M := Cnmat(n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      simple(la
bel,type) := `C_matrix`, `type_A`:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### create F[n] Cartan ma
trix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   elif( t = F ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      ### set up the rules for F4" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "      F42E6();" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 20 "      M := Fnmat(n);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 49 "      simple(label,type) := `F_matrix`, `type_E`:" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ##
# create G[n] Cartan matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   e
lif( t = G ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      ### set \+
up the rules for G2" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      G22G2(
gens1, gens2, label);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      unfo
ld_G_matrix(gens1, gens2, label);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
20 "      M := Gnmat(n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      s
imple(label,type) := `G_matrix`, `type_G`:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 5 "  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 24 "  ### storing our matrix" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 27 "  simple(label) := eval(M):" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "  ### returning
 the matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "  RETURN(M);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "LieAlg_
Hidden[Anmat] := proc(n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "   description `generates an An matrix`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   if( n < 1 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ERROR(`subscript %1 is too lo
w.`, n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 24 "   RETURN(matbase(n,n));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "LieAlg_Hidden[Dnmat] := pro
c(n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   description `ge
nerates an Dn matrix`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local \+
M;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   option `Copyright (C) 1999
-2019 by Yuly Billig and Matyas Mazzag.`, system, remember;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   i
f( n < 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ERROR(`sub
script %1 is too low.`, n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   M := matbase(n,n-1);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   M[n-2,n] := -1; " }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 19 "   M[n,n-2] := -1; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "   M[n,n] := 2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 
"   RETURN(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 40 "LieAlg_Hidden[Enmat] := proc(n::integer)" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 40 "   description `generates an En matrix`;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   if( not(member(n,\{6,7,8
\})) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      ERROR(`algebra
 of type %1 is not supported.`, E[n]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   M := matbase(n,
n-1);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   M[n-3,n] := -1;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   M[n,n-3] := -1;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 15 "   M[n,n] := 2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 19 "   RETURN(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 
"" {MPLTEXT 1 0 40 "LieAlg_Hidden[Bnmat] := proc(n::integer)" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 40 "   description `generates an Bn matrix`;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billig an
d Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   if( n < 2 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ERROR(`subscript %1 is too lo
w.`, n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 21 "   M := matbase(n,n);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "   M[n,n-1] := -2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   RETURN(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 40 "LieAlg_Hidden[Cnmat] := proc(n::integer)" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 40 "   description `generates an Cn matrix`;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   if( n < 2 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      ERROR(`subscript %1 is too lo
w.`,n);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "   M := matbase(n,n);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "   M[n-1,n] := -2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   RETURN(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 40 "LieAlg_Hidden[Fnmat] := proc(n::integer)" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 40 "   description `generates an Fn matrix`;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   if( n <> 4 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      ERROR(`algebra of type %1 is \+
not supported.`, F[n]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   M := matbase(n,n);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 20 "   M[n-2,n-1] := -2;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "   RETURN(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "LieAlg_Hidden[Gnmat] := proc(n::int
eger)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   description `generates \+
an Gn matrix`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local M;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 \+
by Yuly Billig and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   if( n <
> 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      ERROR(`algebra \+
of type %1 is not supported.`, G[n]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   M := matbase(n,n)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   M[n-1,n] := -3;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 19 "   RETURN(eval(M));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "LieAlg_Hidden[matbase] := p
roc(n::integer,uplim::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 " \+
  option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "   description `the base matrix \+
off all matrices (for algs An,.., Gn)`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 17 "   local j, k, M;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   M := [seq([seq(0,j=1..n)],j=1..n
)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   for j to uplim do " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      for k to uplim do " }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 39 "         if( j = k ) then M[j,k] := 2; " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "         elif( abs(j - k) = 1 ) th
en M[j,k] := -1; fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      od; 
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "   RETURN(convert(M,Matrix));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "LieAlg_Hidden[unfoldh_B_mat
rix] := proc(e::`&*`,n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 
"   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`
, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "   description `Does
 the unfolding of a whole expression involving h's.`;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   if( \+
op(op(1,e)) = n and op(op(2,e)) = n ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 63 "      RETURN(generalexpand(op(0,op(1,e))[n]+op(0,op(1
,e))[n+1]," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "                     \+
      op(0,op(2,e))[n]+op(0,op(2,e))[n+1],`&*`));" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 31 "   elif( op(op(1,e)) = n ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 78 "      RETURN(generalexpand(op(0,op(1,e))[n]+op(0,op(
1,e))[n+1],op(2,e),`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   el
if( op(op(2,e)) = n ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "     \+
 RETURN(generalexpand(op(1,e),op(0,op(2,e))[n]+op(0,op(2,e))[n+1],`&*`
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      RETURN(e);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 
"   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "LieAlg_Hidden[unfold_B_matrix] := proc(e::`&*`)" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig \+
and Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 " \+
  description `Does the unfolding of a whole expression.`;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 27 "   local LI, RI, DI, LB, i;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "   ### We
 don't error check, therefore everything should be checked beforehand!
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   LI := [op(op(1,e))];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   RI := [op(op(2,e))];" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "   ##
# checking for indices to be the right sequence (0's, 1's, 2's, 1)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   ### and unfolding betas into alp
has at the same time" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   if( LI =
 -RI ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "      LB := [LI,RI];
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      LB := [LI,RI,LI+RI];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   DI := \+
[];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   for i to nops(LB) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      ### unfolding the current ind
ex" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      LB[i] := Bn2Dn(LB[i]); 
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 56 "      ### if any unfolding was unsuccessful, return zero" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "      if( LB[i] = [] ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ###
 don't add the unfolded LI+RI term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "      elif( i < 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   \+
      ### preparing the D terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "
         if( LB[i][2] = [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "            DI := [DI[], op(0,GENERATORS[1])[LB[i][1][]]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 92 "            DI := [DI[], op(0,GENERATORS[1])[LB[i][1]
[]] + op(0,GENERATORS[1])[LB[i][2][]]];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ### expand t
he sum if we have to" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   RETURN(g
eneralexpand(DI[1],DI[2],`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "
end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 59 "LieAlg_Hidden[unfoldh_C_matrix] := proc(e::
`&*`,n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copy
right (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "   description `Does the unfolding \+
of a whole expression involving h's.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 11 "   local k;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 16 "   k := 2*n - 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 79 "   if( k+1-op(op(1,e)) <> op(op(1,e)) and k+1-op(op(2
,e)) <> op(op(2,e)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "     \+
 RETURN(generalexpand(op(1,e)+op(0,op(1,e))[k+1-op(op(1,e))]," }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "                           op(2,e)+
op(0,op(2,e))[k+1-op(op(2,e))],`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 46 "   elif( k+1-op(op(1,e)) <> op(op(1,e)) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 81 "      RETURN(generalexpand(op(1,e)+op(0,op(1,e)
)[k+1-op(op(1,e))],op(2,e),`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
46 "   elif( k+1-op(op(2,e)) <> op(op(2,e)) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 81 "      RETURN(generalexpand(op(1,e),op(2,e)+op(0,op(
2,e))[k+1-op(op(2,e))],`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "  \+
 else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(e);" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "LieAlg_Hidden[unfold_C_matrix] := p
roc(e::`&*`)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copyrigh
t (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   description `Does the unfolding \+
of a whole epxression.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   loca
l LI, RI, AI, LB, i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 79 "   ### We don't error check, therefore ever
ything should be checked beforehand!" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 23 "   LI := [op(op(1,e))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "  \+
 RI := [op(op(2,e))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 81 "   ### the two indices and their sum (if i
t's not [0,...,0]) must unfold properly" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 22 "   if( LI = -RI ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 " \+
     LB := [LI,RI]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "      LB := [LI,RI,LI+RI]; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 12 "   AI := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "   ### che
cking for indices to be the right sequence (0's, 1's, 2's, 1)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   ### and unfolding betas into alp
has at the same time" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   for i to
 nops(LB) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      ### unfold in
dex" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      LB[i] := Cn2An(LB[i]);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 45 "      ### check whether unfold was successful" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 27 "      if( LB[i] = [] ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      ### we don't want to
 add the unfolded sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      elif
( i < 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "         ### prep
aring the A terms, the current index unfolded into the same indices" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "         if( LB[i][1] = LB[i][2] )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "            AI := [AI[], o
p(0,GENERATORS[1])[LB[i][1][]]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "         ### unfolded into diff
erent patterns" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "            AI := [AI[], op(0,GENER
ATORS[1])[LB[i][1][]] + op(0,GENERATORS[1])[LB[i][2][]]];" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   \+
### expand if we have to" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   RETU
RN(generalexpand(AI[1],AI[2],`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "LieAlg_Hidden[unfoldh_F_matrix] := \+
proc(e::`&*`,n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   opti
on `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, rememb
er;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "   description `Does the unf
olding of a whole expression involving h's.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   RETURN(gener
alexpand(add(i,i=map((x,y)->y[x[]],F42E6([op(op(1,e))]),op(0,op(1,e)))
), " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "                        add(
i,i=map((x,y)->y[x[]],F42E6([op(op(2,e))]),op(0,op(2,e)))),`&*`));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "LieAlg_
Hidden[unfold_F_matrix] := proc(e::`&*`)" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas \+
Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   descripti
on `Does the unfolding of a whole epxression.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "   local LI, RI;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "   ### We don't error check, t
herefore everything should be checked beforehand!" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 23 "   LI := [op(op(1,e))];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "   RI := [op(op(2,e))];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "   ### we have to check
 for the sum of indices to be in the table" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "   if( LI <> -RI and F42E6(LI+RI) = FAIL ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   ### ok to
 proceed" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 35 "      ### creating expression in E6" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 40 "      LI := F42E6(LI); RI := F42E6(RI); " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      if( LI = FAIL or RI = FAIL ) \+
then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 82 "         RETURN(generalexpand(add(i,i=map((x,y)->y[x[
]],LI,op(0,GENERATORS[1]))), " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "  \+
                            add(i,i=map((x,y)->y[x[]],RI,op(0,GENERATO
RS[1]))),`&*`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "LieAlg_Hidden[unfoldh_G_matrix] := \+
proc(e::`&*`,n::integer)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   opti
on `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "   description `Does the unfolding \+
of a whole expression involving h's.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   if( unfold_G_matrix(a
rgs[1],ALGEBRA) = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "     \+
 RETURN(unfold_G_matrix(evaln(op(2,args[1])&*op(1,args[1])),ALGEBRA));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "      RETURN(unfold_G_matrix(args[1],ALGEBRA));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "LieAlg_Hidden[unfold_G_matrix] := p
roc()" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1
999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 59 "   description `Does the unfolding of a whole epxress
ion.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   local a, b, Alg;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs = \+
3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      a := args[1];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      b := args[2];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 21 "      Alg := args[3];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      unfold_G_
matrix(evaln(a[3,2]&*a[-3,-2]), Alg) := 36:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 59 "      unfold_G_matrix(evaln(a[3,1]&*a[-3,-1]), Alg) :
= -36:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      unfold_G_matrix(eva
ln(a[2,1]&*a[-2,-1]), Alg) := 12:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      unfold_G_matrix(evaln(a[1,1]&*a[-1,-1]), Alg) := -3:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      unfold_G_matrix(evaln(a[0,1]&
*a[0,-1]), Alg) := 1:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      unfo
ld_G_matrix(evaln(a[1,0]&*a[-1,0]), Alg) := 3:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "      unfold_G_matrix(evaln(b[1]&*b[1]), Alg) := 6:" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      unfold_G_matrix(evaln(b[2]&
*b[2]), Alg) := 2:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      unfold_
G_matrix(evaln(b[1]&*b[2]), Alg) := -3:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( nargs = 2 and n
ops(args[1]) = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "      (a
,b) := op(args[1]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "      if( t
ype([op(a)],`G_matrix_truegen`) and type([op(b)],`G_matrix_truegen`) a
nd [op(a)] = -[op(b)]) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "    \+
     RETURN(unfold_G_matrix(evaln(b&*a),args[2]));" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "  \+
       RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "      RETURN(FAIL);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "LieAlg_Hidden[Bn2Dn] := proc(L::list(integer))" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "      option `Copyright (C) 1999-20
19 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 122 "      description `Checking for indices to be the ri
ght sequence and unfolding Bn betas into Dn alphas at the same time.`;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      local j, Temp, State, zer
os, ones, twos, zte;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 51 "      ### init. our list we're going to unf
old into" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "      Temp := [seq(0, j
 = 1..nops(L))]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      ### init
. our state" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      State := zeros
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 68 "      ### loop through e's indices, checking states, copying i
ndices" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      for j to nops(L) do
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "         ### copy all the stuff
 until we have zeros" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "         if
( L[j] = 0 and (State = zeros or State = zte) ) then;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 26 "            Temp[j] := 0; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "         ### we
 just saw a sequence of ones, we can only have zeros following" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "         ### (change state, zte is \+
for zeros till the end)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "        \+
 elif( L[j] = 0 and State = ones ) then;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 25 "            State := zte;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
26 "            Temp[j] := 0; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "         ### we saw a one and we \+
only had zeros, copy element, change state" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "         elif( abs(L[j]) = 1 and State = zeros ) then
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "            State := ones;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            Temp[j] := L[j]; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 44 "         ### we're seeing a sequence of ones" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 52 "         elif( abs(L[j]) = 1 and State = ones ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            Temp[j] := L[j]; "
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 63 "         ### we've come accross a two change flag, copy elemen
t" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "         elif( abs(L[j]) = 2 a
nd State = ones ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "        \+
    State := twos;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            T
emp[j] := L[j]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 29 "         ### sequence of twos" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 52 "         elif( abs(L[j]) = 2 and State = twos \+
) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            Temp[j] := L[
j]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "         ### we didn't recognize the pattern, return \+
0" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "         else " }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 23 "            RETURN([]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "   \+
   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 59 "      ### analyzing our state, determine the unfolded
 parts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      if( State = zte ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "         Temp := [[Temp[], 0
],[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      elif( State = ones \+
) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "         Temp := [[Temp[]
, 0],[Temp[1..nops(Temp)-1][], 0, Temp[nops(Temp)]]];" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 31 "      elif( State = twos ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 88 "         Temp := [[Temp[1..nops(Temp)-1][], Temp
[nops(Temp)]/2, Temp[nops(Temp)]/2],[]];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 50 "      ### we only had zeros, not a valid generator" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 20 "         Temp := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      RETURN(Temp);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "LieAlg_
Hidden[Cn2An] := proc(L::list(integer))" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 83 "      option `Copyright (C) 1999-2019 by Yuly Billig and Matya
s Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 141 "      des
cription `Checking for indices to be the right sequence (0's, 1's, 2's
, 1) and unfolding Cn betas into An alphas at the same time.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "      local i, j, State, zeros, one
s, twos, zte, Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 51 "      ### init. our list we're going to unfo
ld into" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "      Temp := [[seq(0, i
 = 1..(2 * nops(L) - 1))],[seq(0, i = 1..(2 * nops(L) - 1))]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
25 "      ### init. our state" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "  \+
    State := zeros;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 68 "      ### loop through e's indices, checking
 states, copying indices" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      f
or j to nops(L) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "         ### \+
copy all the stuff until we have zeros" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 64 "         if( L[j] = 0 and (State = zeros or State = zte) ) the
n;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            Temp[1][j] := 0; 
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "            Temp[2][nops(Temp[2
]) + 1 - j] := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 77 "         ### we just saw a sequence of ones, w
e can only have zeros following" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "
         ### (change state, zte is for zeros till the end)" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 48 "         elif( L[j] = 0 and State = ones ) \+
then;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "            State := zte;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            Temp[1][j] := 0; " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "            Temp[2][nops(Temp[2]) \+
+ 1 - j] := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 75 "         ### we saw a one and we only had zero
s, copy element, change state" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "  \+
       elif( abs(L[j]) = 1 and State = zeros ) then " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 26 "            State := ones;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "            Temp[1][j] := L[j]; " }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 51 "            Temp[2][nops(Temp[2]) + 1 - j] := L[j];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "  " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 44 "         ### we're seeing a sequence of ones" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 52 "         elif( abs(L[j]) = 1 and State = ones ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "            Temp[1][j] := L[
j]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "            Temp[2][nops(Te
mp[2]) + 1 - j] := L[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "         ### when we had a sequence
 of twos, we have to have the last as one" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 68 "         elif( abs(L[j]) = 1 and j = nops(L) and Stat
e = twos ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "            Temp
[1][j] := L[j]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "            Tem
p[2][nops(Temp[2]) + 1 - j] := L[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "         ### we've come
 accross a two change flag, copy element" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 89 "         elif( j <> nops(L) and abs(L[j]) = 2 and (State = on
es or State = zeros) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   \+
         State := twos;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "        \+
    Temp[1][j] := L[j]/2; Temp[2][j] := L[j]/2;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "            Temp[1][nops(Temp[1]) + 1 - j] := L[j]/2;
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "            Temp[2][nops(Temp[
2]) + 1 - j] := L[j]/2; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         ### sequence of twos" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "         elif( j <> nops(L) and abs
(L[j]) = 2 and State = twos ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
55 "            Temp[1][j] := L[j]/2; Temp[2][j] := L[j]/2;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 54 "            Temp[1][nops(Temp[1]) + 1 - j]
 := L[j]/2; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "            Temp[2]
[nops(Temp[2]) + 1 - j] := L[j]/2; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "         ### we didn't recog
nize the pattern, return empty list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
14 "         else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "            R
ETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "      od;         " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 31 "      ### return unfolded lists" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 19 "      RETURN(Temp);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "LieAlg_Hidden[F42E6] := pro
c()" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 199
9-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "   description `this is for looking up what indices i
n F4 unfold into in E6`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   ### \+
let it use its table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 23 "   if( nargs = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "
      ### initializing our table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 
"      ### e values" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6(
[1,0,0,0]) := [[1,0,0,0,0,0],[0,0,0,0,1,0]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "      F42E6([0,1,0,0]) := [[0,1,0,0,0,0],[0,0,0,1,0,0
]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E6([0,0,1,0]) := [[
0,0,1,0,0,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E6([0,0,
0,1]) := [[0,0,0,0,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      \+
F42E6([1,1,0,0]) := [[1,1,0,0,0,0],[0,0,0,1,1,0]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 56 "      F42E6([0,1,1,0]) := [[0,1,1,0,0,0],[0,0,1,1,0
,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E6([0,0,1,1]) := \+
[[0,0,1,0,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6([1,
1,1,0]) := [[1,1,1,0,0,0],[0,0,1,1,1,0]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "      F42E6([0,1,1,1]) := [[0,1,1,0,0,1],[0,0,1,1,0,1
]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6([1,1,1,1]) := [[
1,1,1,0,0,1],[0,0,1,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   \+
   F42E6([0,2,1,0]) := [[0,1,1,1,0,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 42 "      F42E6([0,2,1,1]) := [[0,1,1,1,0,1]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 59 "      F42E6([1,2,1,0]) := [[1,1,1,1,0,0],[0,1,1,1,1
,0]]:   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E6([0,2,2,1]) \+
:= [[0,1,2,1,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6(
[1,2,1,1]) := [[1,1,1,1,0,1],[0,1,1,1,1,1]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "      F42E6([2,2,1,0]) := [[1,1,1,1,1,0]]:" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6([1,2,2,1]) := [[1,1,2,1,0,1],[
0,1,2,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E6([2,2,
1,1]) := [[1,1,1,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      \+
F42E6([1,3,2,1]) := [[1,2,2,1,0,1],[0,1,2,2,1,1]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 42 "      F42E6([2,2,2,1]) := [[1,1,2,1,1,1]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      F42E6([2,3,2,1]) := [[1,2,2,1
,1,1],[1,1,2,2,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      F42E
6([2,4,2,1]) := [[1,2,2,2,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 
"      F42E6([2,4,3,1]) := [[1,2,3,2,1,1]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "      F42E6([2,4,3,2]) := [[1,2,3,2,1,2]]:" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[1,0,0,0]) := -[[1,0,0,0,0,0]
,[0,0,0,0,1,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[0
,1,0,0]) := -[[0,1,0,0,0,0],[0,0,0,1,0,0]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      F42E6(-[0,0,1,0]) := -[[0,0,1,0,0,0]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F42E6(-[0,0,0,1]) := -[[0,0,0
,0,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[1,1,0,0]
) := -[[1,1,0,0,0,0],[0,0,0,1,1,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 58 "      F42E6(-[0,1,1,0]) := -[[0,1,1,0,0,0],[0,0,1,1,0,0]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F42E6(-[0,0,1,1]) := -[[0,0,1
,0,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[1,1,1,0]
) := -[[1,1,1,0,0,0],[0,0,1,1,1,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 58 "      F42E6(-[0,1,1,1]) := -[[0,1,1,0,0,1],[0,0,1,1,0,1]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[1,1,1,1]) := -[[1,1,1
,0,0,1],[0,0,1,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F4
2E6(-[0,2,1,0]) := -[[0,1,1,1,0,0]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 44 "      F42E6(-[0,2,1,1]) := -[[0,1,1,1,0,1]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 61 "      F42E6(-[1,2,1,0]) := -[[1,1,1,1,0,0],[0,1,1,1
,1,0]]:   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F42E6(-[0,2,2,1
]) := -[[0,1,2,1,0,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F4
2E6(-[1,2,1,1]) := -[[1,1,1,1,0,1],[0,1,1,1,1,1]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 44 "      F42E6(-[2,2,1,0]) := -[[1,1,1,1,1,0]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[1,2,2,1]) := -[[1,1,2
,1,0,1],[0,1,2,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F4
2E6(-[2,2,1,1]) := -[[1,1,1,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 58 "      F42E6(-[1,3,2,1]) := -[[1,2,2,1,0,1],[0,1,2,2,1,1]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F42E6(-[2,2,2,1]) := -[[1,1,2
,1,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      F42E6(-[2,3,2,1]
) := -[[1,2,2,1,1,1],[1,1,2,2,1,1]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 44 "      F42E6(-[2,4,2,1]) := -[[1,2,2,2,1,1]]:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 44 "      F42E6(-[2,4,3,1]) := -[[1,2,3,2,1,1]]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      F42E6(-[2,4,3,2]) := -[[1,2,3
,2,1,2]]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      ### for the h values" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "      F42E6([1]) := [[1],[5]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "      F42E6([2]) := [[2],[4]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      F42E6([3]) := [[3]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      F42E6([4]) := [[6]]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   ### no match
 was found " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 19 "      RETURN(FAIL);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 30 "LieAlg_Hidden[G22G2] := proc()" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   description
 `this is for looking up G2 rules`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   local
 a, b, Alg;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   ### let it use it
s table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "   ##
# initializing our table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( \+
nargs = 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      a := args
[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      b := args[2];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := args[3];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      #
## create the rules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      G22G2(
evaln(a[1,0]&*a[0,1]), Alg) := a[1,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 50 "      G22G2(evaln(a[1,0]&*a[1,1]), Alg) := a[2,1]:" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 50 "      G22G2(evaln(a[1,0]&*a[2,1]), Alg) := \+
a[3,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G22G2(evaln(a[1,0]
&*a[3,1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G22G
2(evaln(a[1,0]&*a[3,2]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
49 "      G22G2(evaln(a[1,0]&*a[-1,0]), Alg) := b[1]:" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 46 "      G22G2(evaln(a[1,0]&*a[0,-1]), Alg) := 0:" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "      G22G2(evaln(a[1,0]&*a[-1,-1
]), Alg) := 3 * a[0,-1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      G
22G2(evaln(a[1,0]&*a[-2,-1]), Alg) := 4 * a[-1,-1]:" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 58 "      G22G2(evaln(a[1,0]&*a[-3,-1]), Alg) := 3 * a
[-2,-1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      G22G2(evaln(a[1,0
]&*a[-3,-2]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G
22G2(evaln(a[0,1]&*a[1,1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 45 "      G22G2(evaln(a[0,1]&*a[2,1]), Alg) := 0:" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 50 "      G22G2(evaln(a[0,1]&*a[3,1]), Alg) := a[3,2
]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G22G2(evaln(a[0,1]&*a[3
,2]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      G22G2(eva
ln(a[0,1]&*a[-1,0]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "
      G22G2(evaln(a[0,1]&*a[0,-1]), Alg) := b[2]:" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 55 "      G22G2(evaln(a[0,1]&*a[-1,-1]), Alg) := - a[-1,
0]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      G22G2(evaln(a[0,1]&*a[
-2,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      G22G2(
evaln(a[0,1]&*a[-3,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
54 "      G22G2(evaln(a[0,1]&*a[-3,-2]), Alg) := a[-3,-1]:" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 52 "      G22G2(evaln(a[1,1]&*a[2,1]), Alg) := \+
- a[3,2]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G22G2(evaln(a[1,
1]&*a[3,1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G2
2G2(evaln(a[1,1]&*a[3,2]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 57 "      G22G2(evaln(a[1,1]&*a[-1,0]), Alg) := - 3 * a[0,1]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      G22G2(evaln(a[1,1]&*a[0,-1]),
 Alg) := a[1,0]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "      G22G2(eva
ln(a[1,1]&*a[-1,-1]), Alg) := - 3 * b[2] - b[1]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "      G22G2(evaln(a[1,1]&*a[-2,-1]), Alg) := 4 * a[-1
,0]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      G22G2(evaln(a[1,1]&*a
[-3,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      G22G2
(evaln(a[1,1]&*a[-3,-2]), Alg) := 3 * a[-2,-1]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "      G22G2(evaln(a[2,1]&*a[3,1]), Alg) := 0:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      G22G2(evaln(a[2,1]&*a[3,2]), \+
Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "      G22G2(evaln(a[2
,1]&*a[-1,0]), Alg) := - 4 * a[1,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 46 "      G22G2(evaln(a[2,1]&*a[0,-1]), Alg) := 0:" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 58 "      G22G2(evaln(a[2,1]&*a[-1,-1]), Alg) := - 4 \+
* a[1,0]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "      G22G2(evaln(a[2,
1]&*a[-2,-1]), Alg) := 12 * b[2] + 8 * b[1]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "      G22G2(evaln(a[2,1]&*a[-3,-1]), Alg) := - 12 * a
[-1,0]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      G22G2(evaln(a[2,1]
&*a[-3,-2]), Alg) := 12 * a[-1,-1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
45 "      G22G2(evaln(a[3,1]&*a[3,2]), Alg) := 0:" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 56 "      G22G2(evaln(a[3,1]&*a[-1,0]), Alg) := -3 * a[2
,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      G22G2(evaln(a[3,1]&*a
[0,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      G22G2(
evaln(a[3,1]&*a[-1,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
57 "      G22G2(evaln(a[3,1]&*a[-2,-1]), Alg) := 12 * a[1,0]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "      G22G2(evaln(a[3,1]&*a[-3,-1])
, Alg) := - 36 * b[2] - 36 * b[1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      G22G2(evaln(a[3,1]&*a[-3,-2]), Alg) := 36 * a[0,-1]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      G22G2(evaln(a[3,2]&*a[-1,0]),
 Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "      G22G2(evaln(a[
3,2]&*a[0,-1]), Alg) := - a[3,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      G22G2(evaln(a[3,2]&*a[-1,-1]), Alg) := - 3 * a[2,1]:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      G22G2(evaln(a[3,2]&*a[-2,-1])
, Alg) := - 12 * a[1,1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      G
22G2(evaln(a[3,2]&*a[-3,-1]), Alg) := - 36 * a[0,1]:" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 67 "      G22G2(evaln(a[3,2]&*a[-3,-2]), Alg) := 72 *
 b[2] + 36 * b[1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "      G22G2(e
valn(a[-1,0]&*a[0,-1]), Alg) := a[-1,-1]:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 55 "      G22G2(evaln(a[-1,0]&*a[-1,-1]), Alg) := a[-2,-1
]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "      G22G2(evaln(a[-1,0]&*a[
-2,-1]), Alg) := a[-3,-1]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "     \+
 G22G2(evaln(a[-1,0]&*a[-3,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "      G22G2(evaln(a[-1,0]&*a[-3,-2]), Alg) := 0:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      G22G2(evaln(a[0,-1]&*a[-1,-1]
), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      G22G2(evaln(
a[0,-1]&*a[-2,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 " \+
     G22G2(evaln(a[0,-1]&*a[-3,-1]), Alg) := a[-3,-2]:" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 48 "      G22G2(evaln(a[0,-1]&*a[-3,-2]), Alg) := 0
:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      G22G2(evaln(a[-1,-1]&*a[
-2,-1]), Alg) := - a[-3,-2]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   \+
   G22G2(evaln(a[-1,-1]&*a[-3,-1]), Alg) := 0:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "      G22G2(evaln(a[-1,-1]&*a[-3,-2]), Alg) := 0:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      G22G2(evaln(a[-2,-1]&*a[-3,-1
]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      G22G2(evaln
(a[-2,-1]&*a[-3,-2]), Alg) := 0:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 
"      G22G2(evaln(a[-3,-1]&*a[-3,-2]), Alg) := 0:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( narg
s = 2 and nops(args[1]) = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "      (a,b) := op(args[1]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "
      if( type([op(a)],`G_matrix_truegen`) and type([op(b)],`G_matrix_
truegen`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "         RETURN
(-G22G2(evaln(b&*a),args[2]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 " \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   ### no match
 was found" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 19 "      RETURN(FAIL);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 24 "LieAlg[unienv] := proc()" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "   description
 `Defines a Universal Enveloping algebra for the Lie algebra passed to
 it.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   local Label, Alg, i;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   ### gett
ing name of algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   Alg := AL
GEBRA; Label := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   for i to n
args do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "      if( type(args[i],`
algebra`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         Alg :=
 args[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 25 "         Label := args[i]" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   \+
od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 38 "   if( not(type(Alg,`algebra`)) ) then" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 47 "      ERROR(`invalid algebra %1 to use.`, Alg)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif( Label = 0 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      Label := `U_`||Alg;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   ### registering info" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   unienv(Label) := Alg:" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 94 "   RETURN(generators(Label, [op(4, eval(al
gebra))[Alg]], op(4, eval(algebra))[Alg,`weight`]));" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "LieAlg[hwrep] := proc()
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2
019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 43 "   description `Defines a Representation.`;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 36 "   global v, lambda, REPRESENTATION;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 54 "   local i, Alg, GTL, Lz2L, L, T, P, Label, U
niAlg, Z;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   \+
### init our variables\n" }{MPLTEXT 1 0 41 "   # Label is the name of \+
representation\n" }{MPLTEXT 1 0 49 "   # Alg is the algebra acting on \+
representation\n" }{MPLTEXT 1 0 53 "   # GTL is the symbol for the hig
hest weight vector\n" }{MPLTEXT 1 0 93 "   # L is the list of rules fo
r the action of Cartan subalgebra on the highest weight vector\n" }
{MPLTEXT 1 0 4 "   #" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "   Label :=
 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   Alg := ALGEBRA;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 22 "   lambda := 'lambda';" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 14 "   GTL := 'v';" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
11 "   L := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   ### default i
s lambda" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 118 "   Lz2L := (x)->if(typ
e(x,indexed)) then if( hastype([op(x)],name) ) then lambda else lambda
[op(x)] fi else lambda fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### analyze the arguments" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   for i to nargs do" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 40 "      if( type(args[i],`algebra`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "         Alg := args[i];\n" }
{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 2 "# " }{MPLTEXT 
1 0 73 "elif( type(eval(args[i]),procedure) or type(eval(args[i]),inte
ger) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "      elif( type(eva
l(args[i]),procedure) or type(eval(args[i]),constant) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 25 "         Lz2L := args[i];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 37 "      elif( type(args[i],list) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 44 "         if( type(args[i],list(`=`)) ) th
en " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "             L := args[i];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 85 "             ERROR(`expected a set of rules in the \+
form x=y, received %1.`, args[i]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      elif( typ
e(args[i],name) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         \+
if( Label = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "           \+
 Label := args[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "            GTL := args[i];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "      else         " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 84 "         ERROR(`expected one of procedure, name or algebra, rece
ived %1.`, args[2]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   if( not(type
(Alg,algebra)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      ERRO
R(`algebra %1 is not defined.`, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 112 "   elif( L <> [] and member(`false`,map((x,y)->wt(x,y) &!= [seq
(0,i=wt(x,y))],map(x->op(1,x),L),Alg),'i') ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 80 "      ERROR(`replacement rule %1 is for a nonzero ge
nerator in %2.`, L[i], Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   f
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 81 "   ### so far we don't have a new representation for the zero
s, let's create them" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   if( [] =
 L ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "      ### we had no va
lues for Lzero sent in, we have to fetch them and convert them" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      T := grab(Alg);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 14 "      Z := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 33 "      for i to nops(grab(Alg)) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "         if( wt(T[i],Alg) &!= [seq(0,i=wt(T[i],Alg))]
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "            Z := [];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "            while( i <= nops(T) and
 wt(T[i],Alg) &!= [seq(0,i=wt(T[i],Alg))] ) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "               Z := [Z[], T[i]];" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 26 "               i := i + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 
"            break;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "      if( type(Alg,`simple`) ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 93 "         Z := [seq(op(0,Z[1])[i],i=1..LinearAlgeb
ra[RowDimension](op(4,eval(simple))[Alg]))];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "      elif( type(Alg,`affine`) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 17 "         Z := [];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      Z := map
(x->x=Lz2L(x), Z);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      L := Lz
2L;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "      Z := L;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "  \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 53 "   ### creating unieversal enveloping algebra for Alg
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   if( type(Alg,unienv) ) then"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "      UniAlg := Alg;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "      UniAlg := op(1,[unienv(Alg)][1]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( La
bel = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      Label := `H
W_`||UniAlg;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### \+
setting default representation" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 " \+
  unprotect(evaln(REPRESENTATION)); REPRESENTATION := Label; protect(e
valn(REPRESENTATION));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 24 "   ### registering stuff" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 20 "   if( Z = [] ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      hwrep(Label) := GTL;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "   ### creating subscritps for v" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "      h
wrep(Label) := GTL[map(x->op(2,x),Z)[]];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 53 "   ### register the algebra and the replacement r
ules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "   hwrep(Label,`algebra`) :
= UniAlg,op(4,eval(unienv))[UniAlg]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 37 "   hwrep(Label,`replace`) := eval(L):" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### returnin
g some output" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   RETURN(Label=hw
rep(Label));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "LieAlg[submodule] := proc(Label::name, Gens::list(alg
ebraic)) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (
C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 92 "   description `submodule(submodulename, submodulegen
s) let's the user define a submodule`; " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 20 "    ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   \+
 local Rep, RealGens, SplitGens;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 
"    ### let it remember stuff" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 " \+
   remember; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 38 "    ### called with too many arguments" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 25 "    if( nargs > 3 ) then " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 45 "       ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    ### given an algebra to be used
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    elif( nargs = 3 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       Rep := args[3];" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
29 "       Rep := REPRESENTATION;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 
"    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "# Yuly's CORRECTION in December" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "RealGens := map
((g,a)->if(0<>repsimplify(g,a)) then g; fi,Gens,Rep);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "    if( no
t(type(Rep,`hwrep`)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "    \+
   ERROR(`expecting a representation name, received %1.`, Rep);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    else " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 74 "      RealGens := map((g,a)->if(0<>repsimplify(g,a)) \+
then g; fi,Gens,Rep);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "      Spli
tGens := map((g)->if(type(g,`+`)) then op(g); else g; fi, RealGens);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 135 "      if( member([],map((g,r,a)-
>wt(eval(subs(r=1,g)),a),SplitGens,op(4,eval(hwrep))[Rep], op(4,eval(h
wrep))[Rep,`algebra`][2])) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
73 "       ERROR(`generators %1 of the submodule are not homogenous.`,
 Gens);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "       ##
# entries going into the table:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "
       submodule(Label) := op(RealGens):       ### generators for the \+
given ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "       submodule(Lab
el, `algebra`) := Rep:   ### representation of the generators" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
30 "       ### some output to user" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
32 "       RETURN(Label = RealGens);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 9 "     fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "#   \+
 if( not(type(Rep,`hwrep`)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
68 "#       ERROR(`expecting a representation name, received %1.`, Rep
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 131 "#    elif( member([],map((g,
r,a)->wt(eval(subs(r=1,g)),a),Gens,op(4,eval(hwrep))[Rep], op(4,eval(h
wrep))[Rep,`algebra`][2])) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
74 "#       ERROR(`generators %1 of the submodule are not homogenous.`
, Gens);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "#    else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 76 "#       RealGens := map((g,a)->if(0<>repsimpli
fy(g,a)) then g; fi,Gens,Rep);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "#
       ### entries going into the table:" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 82 "#       submodule(Label) := op(RealGens):       ### generator
s for the given ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "#       su
bmodule(Label, `algebra`) := Rep:   ### representation of the generato
rs" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 30 "       ### some output to user" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 33 "#       RETURN(Label = RealGens);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "#    fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "# End of CORRECTION ---------------
---------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "LieAlg[quotrep] := pro
c(Label::name, SubMod::submodule) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "   description `quotrep(quo
trepname, submodule) This" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "      \+
         function defines a quotient representation.`;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 28 "   ### let it remember stuff" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 25 "   global REPRESENTATION;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "   local HWRep;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 
"   remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 37 "   ### called with too many arguments" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 24 "   if( nargs > 3 ) then " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### place entries in
 the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "   ### names of the i
deal and algebra for quotient algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 52 "   HWRep := op(4,eval(submodule))[SubMod,`algebra`];" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 35 "   quotrep(Label) := HWRep, SubMod:" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   hwrep(Label) := op(4,eval(hwrep)
)[HWRep];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "   hwrep(Label,`algebr
a`) := op(4,eval(hwrep))[HWRep,`algebra`];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 64 "   hwrep(Label,`replace`) := op(4,eval(hwrep))[HWRep,
`replace`];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   unprotect(evaln(R
EPRESENTATION));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   REPRESENTATI
ON := Label;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   protect(evaln(RE
PRESENTATION));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 25 "   ### return some output" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 67 "   RETURN(Label=[op(4,eval(submodule))[SubMod,`algebr
a`], SubMod]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 47 "#####################>  algebra definitions e
nd" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "#####################>  algebra man
agement procedures follow" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "LieAlg
[using] := proc() " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Co
pyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 91 "   description `using(algname) changes the a
lgebra currently in use to the specified (sets " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "               GENERATORS to that algebra)`; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 45 "   global GENERATORS, ALGEBRA, USING_HISTORY;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 54 "   ### we have a request to change the default algebra" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs > 0 ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 40 "      if( type(args[1],`algebra`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "         ### change algebra and the
 generators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "         unprotect(e
valn(GENERATORS), evaln(ALGEBRA), evaln(USING_HISTORY));" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 51 "         USING_HISTORY := [ALGEBRA, USING_HIS
TORY];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         ALGEBRA := args[
1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "         GENERATORS := [op(4
,eval(algebra))[ALGEBRA]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "     \+
    protect(evaln(GENERATORS), evaln(ALGEBRA), evaln(USING_HISTORY));"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "      elif( args[1] = `reset` an
d USING_HISTORY <> [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   \+
      ### change algebra and the generators" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "         unprotect(evaln(GENERATORS), evaln(ALGEBRA),
 evaln(USING_HISTORY));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "        \+
 ALGEBRA := USING_HISTORY[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "  \+
       GENERATORS := [op(4,eval(algebra))[ALGEBRA]];" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 43 "         USING_HISTORY := USING_HISTORY[2];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "         protect(evaln(GENERATORS),
 evaln(ALGEBRA), evaln(USING_HISTORY));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   \+
### return algebra in use" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   if(
 nargs > 0 and args[1] = `showgens` ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "      RETURN(ALGEBRA = GENERATORS);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 39 "   elif( type(ALGEBRA,directsum) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 57 "      RETURN(ALGEBRA = [op(4,eval(directs
um))[ALGEBRA]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   elif( type(A
LGEBRA,quotalg) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "      RE
TURN(ALGEBRA = [op(4,eval(quotalg))[ALGEBRA]]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "   elif( type(ALGEBRA,triangular) ) then " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 58 "      RETURN(ALGEBRA = [op(4,eval(triangula
r))[ALGEBRA]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 35 "     RETURN(ALGEBRA = GENERATORS); " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "LieAlg_Hidden[grab] := proc(Alg::na
me)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 199
9-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 66 "   description `returns the generators for the reques
ted algebra`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   if( type(Alg,al
gebra) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "      RETURN([op(4
,eval(algebra))[Alg]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      RETURN(FAIL);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "en
d:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 45 "#LieAlg_Hidden[reorder] := proc(E::reordexpr)
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "#   option `Copyright (C) 1999-
2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 57 "#   description `Sets the order of a set of generators.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "#   local Alg, i, List, t, Ord, Gen
s;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "#   " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "#   ### input checks" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 24 "#   if( nargs = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "#
       Alg := args[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "#   elif(
 nargs = 1 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "#       Alg :=
 ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "#   else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 64 "#       ERROR(`wrong number of arguments to re
order %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "#   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
45 "#   ### deleting entries from remember tables" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 83 "#   resettabs([normalranking,indexedranking,simplify
,mainlsimplify,mainasimplify]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "#   ### get generators for alge
bra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "#   Gens := grab(Alg);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "#   ### init our values" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "#   \+
t := E;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "#   List := [];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "#   ### break the input up and plac
e in list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "#   for i to nops(Gens
)-1 do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "#       List := [op(0,t),
 op(2,t), List[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "#       t := \+
op(1,t);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "#   od;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 24 "#   List := [t, List[]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "#   ### assign
 numbers to each generator according to the relationships received" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "#   Ord := [1];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 11 "#   i := 2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "#
   while( i < nops(List) ) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "# \+
      if( List[i] = `&<<` ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 
"#           Ord := [Ord[], Ord[nops(Ord)]+1];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "#       elif( List[i] = `&==` ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 43 "#           Ord := [Ord[], Ord[nops(Ord)]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "#       else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "#           Ord := [Ord[], Ord[nops(Ord)]-1];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "#       fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "#       List := subsop(i = NULL, List);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 19 "#       i := i + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "#   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "#   ### registering the new order" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "#   algebra(Alg, order) := List, \+
Ord:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "#" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "#   ### some output" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 20 "#   RETURN(Alg = E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "#end:"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 42 "LieAlg[characteristic] := proc(p::integer)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 \+
by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
83 "   description `through characteristic() it is possible to set the
 CHARACTERISTIC`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declara
tions" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   global CHARACTERISTIC;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 44 "   ### deleting entries from remember tables" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 119 "   resettabs([mainlsimplify, mainasimplify, mainre
psimplify, quotbasis, submodulebasis, quotrepbasis, singularvector]);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 25 "   ### too many arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "
   if( nargs > 1 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "      ER
ROR(`characteristic() expects zero or one (integer) argument, received
 %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 37 "   ### we have an argument, set stuff" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 
"      ### OK to go on" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      unp
rotect(evaln(CHARACTERISTIC));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 " \+
     CHARACTERISTIC := p;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      \+
protect(evaln(CHARACTERISTIC));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "
      RETURN(evaln(characteristic) = CHARACTERISTIC);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:"
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 34 "LieAlg_Hidden[withrules] := proc()" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Bi
llig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "   des
cription `Withrules() is used as a lookuptable for rules defined for a
lgebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   remember;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "LieAlg[
store] := proc() " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Cop
yright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 80 "   description `store() saves a given rule an
d its reverse in the lookup table`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "   local
 rhs, lhs, res, i, j, Table, NOR, End, Alg, createfunc;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ###--
----------------> subs <-----------------------------" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 34 "   createfunc := proc(lhs,rhs,res)" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 73 "      option `Copyright (C) 1999-2019 by Yuly
 Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   \+
   description `Creates a function from an expression.`;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      i
f( type(lhs,indexed) and hastype([op(lhs)],name) or" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 62 "          type(rhs,indexed) and hastype([op(rhs)],
name) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "         RETURN(una
pply(res,[[op(lhs)][],map((i,l)->" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "                                           if(not(member(i,l))) th
en i" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                           \+
                fi," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "            \+
                             [op(rhs)],[op(lhs)])[]][]));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      \+
else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "         RETURN(unapply(res
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   #--
------------------------- end of subs" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   ### some input checks" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs = 0 ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 15 "      RETURN();" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "   elif( args[nargs] = `silent` ) then   " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 21 "      NOR := nargs-1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      NO
R := nargs;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### d
elete the remember tables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "   res
ettabs([functionize,mainlsimplify,mainasimplify,mainrepsimplify,reduce
]):" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "   ### process all rules" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "   for i to NOR do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "      ### trap an error" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "    \+
  if( not(type(args[i], list)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 66 "         ERROR(`expected a list of rules, received %1.`, args[i]
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "      elif( nops(args[i]) > 0
 and type(args[i,nops(args[i])],name) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "         End := nops(args[i])-1;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 38 "         Alg := args[i,nops(args[i])];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 34 "      elif( GENERATORS = [] ) then" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 97 "         ERROR(`can't set rules for defaul
t algera, since there is no default algebra defined.`);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
30 "         End := nops(args[i]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "         Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "      if( args[i,1..End] = [] ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 48 "        if( op(4,eval(withrules)) <> NULL ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "           Table := op(op(4,eva
l(withrules)))[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "           re
settabs([withrules]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "          \+
 map(x->if(op(1,x)<>Alg) then withrules(op(1,x)):=op(2,x); fi, Table);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        fi;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "  \+
      ### process the rules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "    \+
    for j to End do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "           #
## we got an expression coming in" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
46 "           if( not(type(args[i,j],`=`)) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 71 "              ERROR(`expected an expression, receiv
ed %1.`, args[i,j]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 45 "           ### what we have is not an algeb
ra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "           else " }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 62 "              ### some error handling, enfor
cing correct form " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 113 "            \+
  if( nops(args[i][j]) <> 2 or nops(op(1,args[i][j])) <> 2 or type(op(
1,args[i][j]), indexed) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "
                 ERROR(`incorrect rule %1, the correct form is: [name]
&*[name]=[expr]`, args[i]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "    \+
          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 48 "              ### it's safe to break up the rule" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "              lhs := op(1,op(1,ar
gs[i][j])); ### left-hand-side of expression" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "              rhs := op(2,op(1,args[i][j])); ### righ
t-hand-side of expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "      \+
        res := op(2,args[i][j]); ### result of expression" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   \+
           ### rule can't have constants on the LHS\n" }{MPLTEXT 1 0 
25 "              # JUL 2019\n" }{MPLTEXT 1 0 71 "              # if( \+
type(lhs, constant) or type(rhs, constant) ) then  " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 65 "              if( is(lhs, constant) or is(rhs, con
stant) ) then  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 102 "               \+
  ERROR(`incorrect rule %1, no constants are allowed in the LHS of exp
r.`, args[i][j]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "              \+
fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 64 "              if( functionize(evaln(lhs&*rhs),Alg) = \+
FAIL ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "                 ###
 entry going in the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      \+
           Table := op(4,eval(withrules));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 93 "                 if(Table=NULL or (Table<>NULL and no
t(member([Alg],[indices(Table)])))) then" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 41 "                    withrules(Alg) := []:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 20 "                 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                 if( lhs
 <> rhs ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 126 "                \+
    withrules(Alg) := [withrules(Alg)[], lhs&*rhs=createfunc(lhs,rhs,r
es), rhs&*lhs=createfunc(rhs,lhs,-res)]:" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 21 "                 else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 " \+
                   withrules(Alg) := [withrules(Alg)[], lhs&*rhs=creat
efunc(lhs,rhs,res)]:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "           \+
      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "              fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "               " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 42 "              ### formated output for user" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "              if( args[nargs] <> `s
ilent` ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "                 p
rint(evaln(lhs &* rhs) = res);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 " \+
             fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "           fi;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        od;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 82 "        ### deleting the remember table of functioni
ze, since we made some changes" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 " \+
       resettabs([functionize]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "
      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 16 "   RETURN(NULL):" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "####################
#>  algebra management procedures end" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "#######
##############>  expression manipulators follow" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "LieAlg[isgenerator] := proc(Var::anything, " }
{MPLTEXT 1 0 9 "Alg::name" }{MPLTEXT 1 0 2 ") " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 95 "    description `isgenerator(Var[,algname]) checks to
 see whether the passed on variable or in " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 96 "                case of a list all elements in the li
st are generators or not; searches through " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 83 "                the list GENERATORS and returns true \+
if found, false if not found`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 " \+
   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "    global A
LGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "    local GL, AL, i, j, \+
Flag, rk, indx, rts;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "    ### giv
e it memory to improve efficiency" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
89 "    option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazz
ag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "  ### too many arguments" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 23 "  if( nargs > 2 ) then " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 44 "     ERROR(`too many arguments %1.`, args);\n" }
{MPLTEXT 1 0 16 "#Correction 2019" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "  #elif( nargs = 2 ) then  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "
  #   Alg := args[2]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "  #else" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "  #   Alg := ALGEBRA;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "  if( not(type(Alg,algebra)) ) th
en " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "     ERROR(`algebra %1 not d
efined.`, Alg); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "  else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 31 "     if( type(Var,list) ) then\n" }
{MPLTEXT 1 0 26 "        # Correction 2019\n" }{MPLTEXT 1 0 80 "      \+
  # AL := map(proc(x) if(type(x,`*`)) then op(2,x); else x; fi; end, V
ar);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "        AL := map(proc(x) i
f(type(x,`*`)) then PickTerm(x); else x; fi; end, Var);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 10 "     else\n" }{MPLTEXT 1 0 26 "        # Corre
ction 2019\n" }{MPLTEXT 1 0 82 "        # AL := map(proc(x) if(type(x,
`*`)) then op(2,x); else x; fi; end, [Var]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 84 "        AL := map(proc(x) if(type(x,`*`)) then PickTe
rm(x); else x; fi; end, [Var]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 " \+
    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "     ### initializing the loop stuff" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 12 "     i := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
18 "     Flag := true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     GL :
= grab(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "     while( i <= no
ps(AL) and Flag ) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "        Fl
ag := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "        for j to no
ps(GL) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "            if( AL[i] \+
= GL[j] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "               Fl
ag := true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "               break
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "            elif( type(GL[j],i
ndexed) and type([op(GL[j])],list(name)) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 84 "                  and op(0,AL[i]) = op(0,GL[j]) and n
ops(AL[i]) = nops(GL[j]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "
               Flag := true;\n" }{MPLTEXT 1 0 33 "               # Cor
rection 2019\n" }{MPLTEXT 1 0 62 "               # special rules for s
imple and affine algebras\n" }{MPLTEXT 1 0 40 "               if type(
Alg,simple) then\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "             \+
      rk := LinearAlgebra[RowDimension](" }{MPLTEXT 1 0 23 "op(4,eval(
simple))[Alg]" }{MPLTEXT 1 0 3 ");\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 
1 0 34 "                   # h-generators\n" }{MPLTEXT 1 0 33 "       \+
            if (j=2) then\n" }{MPLTEXT 1 0 43 "                      i
ndx := op(1,AL[i]);\n" }{MPLTEXT 1 0 56 "                      if (ind
x < 1) or (indx > rk) then\n" }{MPLTEXT 1 0 39 "                      \+
  Flag := false;\n" }{MPLTEXT 1 0 26 "                      fi;\n" }
{MPLTEXT 1 0 23 "                   fi;\n" }{MPLTEXT 1 0 34 "         \+
          # e-generators\n" }{MPLTEXT 1 0 33 "                   if (j
=1) then\n" }{MPLTEXT 1 0 61 "                      # extract the code
 name of the algebra\n" }{MPLTEXT 1 0 43 "                      indx :
= [op(AL[i])];\n" }{MPLTEXT 1 0 27 "                      if ( " }
{MPLTEXT 1 0 83 "substring(convert(op(1,[op(4,eval(simple))[(Alg,type)
]]),string),1..1) = \"A\" ) then" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 
32 "                         rts := " }{MPLTEXT 1 0 96 "roots(convert(
substring(convert(op(2,[op(4,eval(simple))[(Alg,type)]]),string),6..6)
,name)[rk]);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 27 "                 \+
     else\n" }{MPLTEXT 1 0 25 "                         " }{MPLTEXT 1 
0 7 "rts := " }{MPLTEXT 1 0 96 "roots(convert(substring(convert(op(1,[
op(4,eval(simple))[(Alg,type)]]),string),1..1),name)[rk]);" }{MPLTEXT 
1 0 1 "\n" }{MPLTEXT 1 0 26 "                      fi;\n" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 83 "                      if (not member(indx, \+
rts)) and (not member(-indx, rts)) then\n" }{MPLTEXT 1 0 25 "         \+
                " }{MPLTEXT 1 0 15 "Flag := false;\n" }{MPLTEXT 1 0 
30 "                      fi;     " }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 
0 23 "                   fi;\n" }{MPLTEXT 1 0 20 "                fi;
\n" }{MPLTEXT 1 0 13 "             " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "               if type(Alg,affine) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "                   rk := LinearAlgebra[RowDimension](
op(4,eval(simple))[" }{MPLTEXT 1 0 18 "cat(Alg,`_simple`)" }{MPLTEXT 
1 0 4 "]);\n" }{MPLTEXT 1 0 34 "                   # h-generators\n" }
{MPLTEXT 1 0 33 "                   if (j=2) then\n" }{MPLTEXT 1 0 43 
"                      indx := op(1,AL[i]);\n" }{MPLTEXT 1 0 56 "     \+
                 if (indx < 1) or (indx > rk) then\n" }{MPLTEXT 1 0 
39 "                        Flag := false;\n" }{MPLTEXT 1 0 26 "      \+
                fi;\n" }{MPLTEXT 1 0 23 "                   fi;\n" }
{MPLTEXT 1 0 34 "                   # e-generators\n" }{MPLTEXT 1 0 
33 "                   if (j=1) then\n" }{MPLTEXT 1 0 81 "            \+
         # extract the code name of simple algebra and get its roots\n
" }{MPLTEXT 1 0 60 "                     indx := [op(1..nops(AL[i])-1,
 AL[i])];\n" }{MPLTEXT 1 0 26 "                     if ( " }{MPLTEXT 
1 0 44 "substring(convert(op(1,[op(4,eval(simple))[(" }{MPLTEXT 1 0 
18 "cat(Alg,`_simple`)" }{MPLTEXT 1 0 36 ",type)]]),string),1..1) = \"
A\" ) then" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 86 "                   \+
  rts := roots(convert(substring(convert(op(2,[op(4,eval(simple))[(" }
{MPLTEXT 1 0 18 "cat(Alg,`_simple`)" }{MPLTEXT 1 0 36 ",type)]]),strin
g),6..6),name)[rk]);\n" }{MPLTEXT 1 0 26 "                     else\n"
 }{MPLTEXT 1 0 21 "                     " }{MPLTEXT 1 0 65 "rts := roo
ts(convert(substring(convert(op(1,[op(4,eval(simple))[(" }{MPLTEXT 1 
0 18 "cat(Alg,`_simple`)" }{MPLTEXT 1 0 35 ",type)]]),string),1..1),na
me)[rk]);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 25 "                    \+
 fi;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 83 "                      i
f (not member(indx, rts)) and (not member(-indx, rts)) then\n" }
{MPLTEXT 1 0 40 "                         Flag := false;\n" }{MPLTEXT 
1 0 31 "                      fi;     \n" }{MPLTEXT 1 0 23 "          \+
         fi;\n" }{MPLTEXT 1 0 19 "                fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 21 "               break;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "           fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "
        od;        " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "        i :=
 i + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "     od;   " }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "     #
## true or false" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "     RETURN(Fla
g);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "LieAlg[`expand/&*`] := proc
(A::anything,B::anything)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   opt
ion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   description `Expands a Lie expre
ssion.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   if(nargs > 2) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      RETURN(generalexpand(A,B,`&
*`,args[3]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else " }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 38 "      RETURN(generalexpand(A,B,`&*`));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "LieAlg[`expand/&@`] := proc(A::anyt
hing,B::anything)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Cop
yright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 60 "   description `Expands an associative algebr
a expression.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   if(nargs > 2)
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      RETURN(generalexpand
(A,B,`&@`,args[3]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      RETURN(generalexpand(A,B,`&@`
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "LieAlg[`expand/&^`] := proc
(E::anything,P::nonnegative)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   \+
option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "   description `Expands a power ex
pression.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   local temp, i;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   if( 0 = P ) then" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 18 "      RETURN( 1 );" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "   else\n" }{MPLTEXT 1 0 17 "      # JUL 2019\n" }
{MPLTEXT 1 0 35 "      # if( type(E,constant) ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 31 "      if( is(E,constant) ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 21 "         RETURN(E^P);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "    \+
     temp := E;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "         for i t
o P-1 do temp := evaln(temp &@ E); od;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 22 "         RETURN(temp);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "  \+
    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "LieAlg_Hidden[generalexp
and] := proc(El::anything,Er::anything,OP::symbol)" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig a
nd Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "   descripti
on `Expands a Lie/associative expression, pulls constants to the front
.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   local TermsX, TermsY, Alg, Check
Const;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "   if(nargs > 3) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 21 "      Alg := args[4];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "  \+
    CheckConst := true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else "
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      CheckConst := false;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   ### look at both sid
es" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   if( type(El,`+`) and type(
Er,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      if(CheckCon
st) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 103 "         RETURN(map(pr
oc(x,y,z,w) map(proc(x,y,z,w) z(y,x,w); end, y, x, z, w); end, El, Er,
 OP, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 89 "         RETURN(map(proc(x,y,z) map(proc(
x,y,z) z(y,x); end, y, x, z); end, El, Er, OP));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   ### only lhs is a sum" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 28 "   elif( type(El,`+`) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 25 "      if(CheckConst) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "         RETU
RN(map(proc(x,y,z,w) z(x,y,w); end, El, Er, OP, Alg));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "         RETURN(map(proc(x,y,z) z(x,y); end, El, Er, OP));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   ### only rhs
 is a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   elif( type(Er,`+`) \+
) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      if(CheckConst) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "         RETURN(map(proc(x,y,z,
w) z(y,x,w); end, Er, El, OP, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "         RETURN
(map(proc(x,y,z) z(y,x); end, Er, El, OP));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   ### nothing could be changed" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "     if(CheckConst) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "        RETURN(OP(expand(El),expand(Er),Alg));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "        RETURN(OP(expand(El),expand(Er)));        " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 41 "LieAlg_Hidden[allop] := proc(E::anything)" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 29 "    option system, remember;\n" }{MPLTEXT 
1 0 4 "    " }{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 16 "
        local i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "    if( nops(E)
 = 1 or type(E,indexed) or (nargs = 2 and type(E,`&*`)) ) then RETURN(
E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "    elif( type(E,`&^`) ) the
n RETURN(seq(op(1,E),i=1..op(2,E)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 74 "    elif( nargs = 2 ) then RETURN(map(x->allop(x,`keepterms`),[o
p(E)])[]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "    else RETURN(map(a
llop,[op(E)])[]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "LieAlg_
Hidden[extract] := proc(E::anything, Alg::algebra)" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 89 "    option `Copyright (C) 1999-2019 by Yuly Billig \+
and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 95 "    description `extract(expression) picks out all the generat
ors from a given non-commutative " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
111 "                expression and returns them in a list; side effec
ts: ignores constants inside the expression`;\n" }{MPLTEXT 1 0 17 "# C
orrection 2019" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "local i;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 57 "    if( type(E,`*`) or type(E,`+`) or typ
e(E,`&@`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "       RETURN(m
ap(proc(x,y) extract(x,y[]); end, [op(E)], [args[2..nargs]])[]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    elif( type(E,`&*`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "       if( nargs = 3 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "          RETURN(E);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
82 "          RETURN(map(proc(x,y) extract(x,y[]); end, [op(E)], [args
[2..nargs]])[]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "    elif( type(E,`&^`) ) then\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 
1 0 2 "# " }{MPLTEXT 1 0 48 "RETURN(seq(extract(op(1,E),Alg),i=1..op(2
,E)));\n" }{MPLTEXT 1 0 2 "# " }{MPLTEXT 1 0 52 "RETURN(seq(extract(op
(1,E),Alg),iZqYy=1..op(2,E)));\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 
"       RETURN(seq(extract(op(1,E),Alg),i=1..op(2,E)));\n" }{MPLTEXT 
1 0 16 "     # JUL 2019\n" }{MPLTEXT 1 0 36 "     # elif( type(E,const
ant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "    elif( is(E,const
ant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "       RETURN(NULL);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    elif( isgenerator(E,Alg) ) \+
then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       RETURN(E);" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 59 "       ERROR(`%1 is not a valid generator in %2.`, E, Alg);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "LieAlg[`convert/&*`] := pro
c(L::list(name))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copy
right (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 67 "   description `Converts a list to a free Lie \+
algebra expression.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "   RETURN(
listtolie(lieconvert(L,ALGEBRA),ALGEBRA));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "LieAlg_Hidden[listtolie] :=
 proc(List)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "   description `Conv
erts a list to a lieexpression (with &*-s).`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 30 "   local i, Result, KeepTerms;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 20 "   ### memory option" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   op
tion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, syst
em, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 18 "   ### stnd. check" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 23 "   if( nargs > 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "
      ERROR(`too many arguments %1.`, args);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "   elif( nargs = 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "      KeepTerms := true;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      Ke
epTerms := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "   ### for extra caution" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   \+
if( not(type(List, list)) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "      if( KeepTerms = true ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 38 "         RETURN(listtolie([List], 0));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    \+
     RETURN(listtolie([List]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 " \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   elif( nops(List) = 0
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(0);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "   ### needed for the c
omparisons in lieconvert, if we get a an expression in the list," }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "   ### ie sum, then we make our dei
cion depending on its leading term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
94 "   ### if there are two arguments to the function, it flags that w
e mean to keep the `+` terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   \+
if( (KeepTerms = false) and (nops(List) = 1) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 63 "      and (type(List[], `+`) or type(List[], function
)) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "       Result := lead
ing(List[], ALGEBRA);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "      ### expand the sublist as well" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 36 "      if( type(List[1], list) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "         if( KeepTerms = true ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 44 "            Result := listtolie(List[1], 0);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "            Result := listtolie(List[1]);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "         Resu
lt := List[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "      ### applying &* to elements" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 36 "      for i from 2 to nops(List) do " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "         if( type(List[i], list) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 51 "            if( KeepTerms = true ) then      \+
      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "               Result := \+
Result &* listtolie(List[i], 0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 
"            else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "              \+
 Result := Result &* listtolie(List[i]);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "       \+
  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "            Result := Res
ult &* List[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   RETURN
(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
45 "LieAlg_Hidden[lieconvert] := proc(List::list)" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig an
d Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   \+
description `Wrapper to do_lieconvert.`;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   \+
local dolieconvert, Result;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "   #--------------------------> sub
s <-----------------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 34 "   dolieconvert := proc(List, Alg)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "      description `Brackets a list of names properly \+
according to Lie rules.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      \+
### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      local Lea
st, i, Previ, Mon;\n" }{MPLTEXT 1 0 6 "      " }{MPLTEXT 1 0 15 "globa
l ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "      ### memory opti
on" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "      option `Copyright (C) 1
999-2019 by Yuly Billig and Matyas Mazzag.`, system, remember;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
20 "      ### base cases" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      i
f( nops(List) = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "       \+
  RETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      elif( nops(L
ist) = 1 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "         ### we
 have to distinguish between names (expressions of single vars.)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "         ### and complex ones; this
 is done because if listtolie() sees a complex" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 81 "         ### expression (one with sums) in a list all
 by itself, it knows that it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "   \+
      ### has to consider only the leading term from it" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 38 "         if( type(List[], name) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "            RETURN(List[]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "            RETURN(List);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      ### we have arranging to do"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "         ### finding smallest value in the list" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "         Least := List[1]; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "         for i to nops(List) do " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "            if( listtolie(List[i])
 &< listtolie(Least) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   \+
            Least := List[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "  \+
          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
62 "         ### catching a case that would cause an infinite loop" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "         if( listtolie(List[nops(Li
st)]) &= listtolie(Least) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 
"            RETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "       \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "         ### init. i to one" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "         i := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
59 "         ### init. Mon (this holds the bracketed monomials)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         Mon := [];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "         \+
### loop once through the list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 " \+
        while( i <= nops(List) ) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
79 "            ### this will show us whether there is a sequence of s
mallest terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "            Previ \+
:= i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "            ### bracketing the smallest value with th
e one to it on the right" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "       \+
     while( listtolie(List[i]) &= listtolie(Least) )  do" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 26 "               i := i + 1;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "            ### no smallest \+
terms, just copy element over" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "  \+
          if( Previ = i ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 " \+
              Mon := [Mon[], List[i]];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "            ### we had a
 sequence of smallest terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "    \+
        else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "               Mon \+
:= [Mon[], List[Previ..i-2][], List[i-1..i]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 
"            ### increment i" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   \+
         i := i + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "         od
;   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 69 "         ### we do the same for until everything is g
roupped into one" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "         RETURN
(dolieconvert(Mon, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      f
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "   #--------------------------- end of subs" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   \+
### standard error check" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( \+
nargs > 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`to
o many arguments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "  \+
 elif( nargs = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      us
ing(args[2]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "      Result := do
lieconvert(List, " }{MPLTEXT 1 0 7 "args[2]" }{MPLTEXT 1 0 2 ");" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      using(`reset`);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "
      Result := dolieconvert(List, ALGEBRA);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   RETURN
(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "LieAlg[`convert/&@`] := proc(L::list(anything))" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig \+
and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "   descript
ion `Converts a list to an associative algebra expression.`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 25 "   local Alg, CheckConst;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if(
 nargs > 1 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := a
rgs[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      CheckConst := true
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      CheckConst := false;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 20 "   if( L = [] ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 18 "      RETURN( 0 );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "   elif( nops(L) = 1 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
20 "      RETURN( L[] );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      if(CheckConst) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "         RETURN( &@(convert(L[1..no
ps(L)-1],`&@`,Alg),L[nops(L)],Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "         RETURN
( evaln(convert(L[1..nops(L)-1],`&@`) &@ L[nops(L)]) );" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 41 
"LieAlg[`convert/&^`] := proc(e::anything)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 170 "   descriptio
n `Simplifies an associative multiplication expression by writing wher
e possible '&^' for the same terms in sequence. For example: input: e&
@e output: e&^2`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   local L, i,
 R, T, j, Alg, CheckConst;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs > 1 ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 21 "      Alg := args[2];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "      CheckConst := true;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "      Ch
eckConst := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 18 "# Correction 2
019\n" }{MPLTEXT 1 0 24 "if is(e, constant) then\n" }{MPLTEXT 1 0 15 "
    RETURN(e);\n" }{MPLTEXT 1 0 5 "else\n" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "   if( type(e,`+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      if(CheckConst) then\n" }{MPLTEXT 1 0 27 "      \+
   # Correction 2019\n" }{MPLTEXT 1 0 87 "         # RETURN(map(proc(x
,y) if(type(x,`*`)) then op(1,x) * `convert/&^`(op(2,x),y);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 98 "         RETURN(map(proc(x,y) if(type(x,`*
`)) then PickConstants(x) * `convert/&^`(PickTerm(x),y);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 53 "                              else `convert/&
^`(x,y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "                       \+
       fi; end, e, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "      \+
else\n" }{MPLTEXT 1 0 27 "         # Correction 2019\n" }{MPLTEXT 1 0 
83 "         # RETURN(map(proc(x) if(type(x,`*`)) then op(1,x) * `conv
ert/&^`(op(2,x));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "         RETUR
N(map(proc(x) if(type(x,`*`)) then PickConstants(x) * `convert/&^`(Pic
kTerm(x));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "                     \+
       else `convert/&^`(x);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   \+
                         fi; end, e));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 27 "   elif( type(e,`*`) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 26 "      if(CheckConst) then\n" }{MPLTEXT 1 0 27 "    \+
     # Correction 2019\n" }{MPLTEXT 1 0 55 "         # RETURN(op(1,e) \+
* `convert/&^`(op(2,e),Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "  \+
       RETURN(PickConstants(e) * `convert/&^`(PickTerm(e),Alg));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 27 "   \+
      # Correction 2019\n" }{MPLTEXT 1 0 51 "         # RETURN(op(1,e)
 * `convert/&^`(op(2,e)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "     \+
    RETURN(PickConstants(e) * `convert/&^`(PickTerm(e)));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      if( type(e,list
) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "        L := e;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "        L := [allop(e,`keepterms`)];" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 " \+
     R := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "      i := 1;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "      while( i <= nops(L) ) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "          T := L[i];" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 21 "          i := i + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "          j := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "          while( i <= nops(L) and T = L[i] ) do" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 25 "              j := j + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "              i := i + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "          od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 " \+
         if( R <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "     \+
        if(CheckConst) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "    \+
            R := evaln(R &@ (T &^ j));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 17 "             else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      \+
          R := evaln(R &@ &^(T,j,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 16 "             fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "       \+
   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "             R := T&^j;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   \+
   RETURN(R);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   fi;\n" }{MPLTEXT
 1 0 4 " fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "LieAlg_Hidden[indexedranking] := proc(Monomial::algeb
raic, Alg::algebra)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "  option `Co
pyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "  description `gives a numerical r
ank to a monomial; to be used for comparison of monomials;`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 13 "  global LRP;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "  local L, p, i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "  ### init things" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 15 "  LRP := 'LRP';" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 79 "  L := map(proc(e,a,g,sg) if(type(e,indexed) and (mem
ber(op(0,e),sg,'p'))) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "# Yul
y's CORRECTION in December " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "# I \+
switched two comment signs below" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 
"#                            p,wt(e,a)[],op(e);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "                            wt(e,a)[],p,op(e);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "                          elif(memb
er(e,g,'p')) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "#            \+
                p,wt(e,a)[];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   \+
                         wt(e,a)[],p;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 58 "                          fi; end,[extract(Monomial,Alg)]," }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "                                 Al
g," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "                             \+
    GENERATORS," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "                \+
                 map((ge)->if(type(ge,indexed)) then op(0,ge); " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "                                   \+
        else ge; fi, GENERATORS)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "
       );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 56 "  RETURN(expand(map(`+`,seq(L[i]*LRP^i,i=1..nops(L)))
));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "Li
eAlg_Hidden[normalranking] := proc(Monomial::algebraic, Alg::algebra)"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "  option `Copyright (C) 1999-201
9 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 94 "  description `gives a numerical rank to a monomial; \+
to be used for comparison of monomials;`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "  local L, value, N, f, gensinorder, i, position;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
29 "  L:=[extract(Monomial,Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
42 "  value:=0; N:=nops(GENERATORS)+1; f:=1/N;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "  ### loop thro
ugh the expression and calculate a value for the monomial" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 21 "  for i to nops(L) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "     member(L[i], GENERATORS, 'position');" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 31 "     value:=value + position*f;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 12 "     f:=f/N;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 5 "  od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "  RETURN(value);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "LieAlg_
Hidden[leading] := proc(Expr::algebraic)" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas \+
Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "   description `Picks \+
out the leading term from the sum (the term with the maximum value)," 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "                and also checks f
or the terms to be homogenous.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 
"   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   local Mi
nTerm, Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   global ALGEBRA;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "   ### memory" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 29 "   # option system, remember;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### droppin
g terms if possible" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   Temp := a
pplychar(Expr);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 20 "   ### we have a sum" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "   if( type(Temp, `+`) ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      if( nargs = 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "         using(args[2]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "         MinTerm := sort([op(Temp)],`&<`)[1];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         using(`reset`);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 45 "         MinTerm := sort([op(Temp)],`&<`)[1];" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   ### applychar(expr) has only o
ne term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 22 "      MinTerm := Temp;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 43 "   ### and returning the maximum term fou
nd" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   RETURN(MinTerm);" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "LieAlg_Hidden[s
ubwd] := proc(E1::algebraic,E2::algebraic)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "   description
 `subwd() picks out the subword E1 in E2 and returns a and b in a list
," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "                where E2 = aE1
b`;    " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   ### decalarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   local i, Result, A, B, Alg;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
28 "    ### standard error check" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 
"    if( nargs > 3 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "     \+
  ERROR(`too many arguments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 26 "    elif( nargs = 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "       Alg := args[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    el
se" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       Alg := ALGEBRA;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "    ### prepare
 A and B and init. result" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "    A \+
:= [extract(leading(E1, Alg), Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 42 "    B := [extract(leading(E2, Alg), Alg)];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "    ### simple \+
enough case, A is the same as B" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "
    if( A = B ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       Resu
lt := [[], E1, []];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 42 "    ### we have thinking and looping to do" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "       Result := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 54 "       ### go through B looking for A hidden somewhere" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 36 "       for i to nops(B)-nops(A)+1 do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "          ### when found, return co
rresponding pieces" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "          if(
 A = B[i..i+nops(A)-1] ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 " \+
            Result := [B[1..i-1], E1, B[i+nops(A)..nops(B)]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "             break;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 10 "       od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "    ### return the goods" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   \+
 RETURN(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 59 "LieAlg_Hidden[overlap] := proc(E1::algebraic,E2::alge
braic)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) \+
1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 89 "   description `overlap() picks out the overlaps of t
he end of A (1st arguments) and the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 49 "               beginning of B (second argument)`;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "   local i, A, B, Result, Rem, Alg, L1, L2;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   \+
 ### if list L1 is longer then drop the first few elements" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 28 "    ### standard error check" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 25 "    if( nargs > 3 ) then " }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 45 "       ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    elif( nargs = 3 ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       Alg := args[3];" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "       Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 43 "    ### creating lists from the expressions" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 43 "    L1 := [extract(leading(E1, Alg), Alg)];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "    L2 := [extract(leading(E2, Alg)
, Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "    ### remove part of L1 that isn't effected by the \+
overlap" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "    if( nops(L1) > nops(
L2) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "       A := L1[nops(L
1)-nops(L2)+1..nops(L1)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      \+
 Rem := L1[1..nops(L1)-nops(L2)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 
"    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "       A := L1;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       Rem := [];" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 8 "    fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   \+
 ### B is always this" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "    B := L
2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 71 "    ### compare an always shrinking part of the end of A to a
 shrinking" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "    ### part of begin
ning of B" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "    Result := []; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "    for i to nops(A) do" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 52 "       if( A[i..nops(A)] = B[1..nops(A)+1-i
] ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 95 "          Result := [R
esult[], [[Rem[], A[1..i-1][]], A[i..nops(A)], B[nops(A)+2-i..nops(B)]
]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 7 "    od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "    ### return stuff" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 19 "    RETURN(Result);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "###########
##########>  expression manipulators end" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "#######
##############>  simplification procedures follow\n" }{MPLTEXT 1 0 1 "
\n" }{MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 18 "# Removed
 simplify" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "#LieAlg_Hidden[`simpli
fy/&*`] := proc()" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "#   option `Co
pyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 83 "#   description `This is an interface to the
 Lie algebra simplification function.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 36 "#   RETURN(lsimplify(args,ALGEBRA));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 5 "#end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "LieAlg[lsimplify] := proc(
)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-
2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 114 "   description `This is an interface to the function mainlsi
mplify() which is the main simplification procedure.`;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 14 "   local Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### lets simplify!" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   Temp := traperror(mainlsimplify(
args));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "#Temp := mainlsimplify(args);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   ### we had a
n error" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   if( Temp = lasterror \+
) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "     ERROR(lasterror);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "   ### no error, apply characteristic p" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "     RET
URN(applychar(Temp));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "LieAlg_
Hidden[mainlsimplify] := proc(G::algebraic) " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 69 "  option `Copyright (C) 1999-2019 by Yuly Billig and \+
Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 102 "  description \+
`mainlsimplify(expression<,algname>) simplifies an expression containi
ng Hall Monomials " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "             \+
 and returns the simplified expression; precondition: in the expressio
n brackets " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "              have t
o be placed around constant * generator  (ie instead of 2*x&*y use " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "              (2*x)&*y)`; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "  ### declarations" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 69 "  local ismixed, Alg, NewAlg, List, R, S, Temp, \+
Algabove, Table, TMP;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "  ### give
 it memory to improve efficiency" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 
"  # option  remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "   \+
 #------------------------> definition of subprocedures <-------------
------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "    ### subpr
ocedure to check for mixed expressions" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 43 "    ### occuring with directsum expressions" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 66 "    ### returns an algebra, it the same as called \+
with, it's mixed" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "    ### otherwi
se an algebra is returned with which we can continue the simplificatio
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "    ismixed := proc(G, Alg) " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "      option `Copyright (C) 1999-
2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 22 "      ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "
      local Table, List;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      ### let's get the algebras (w
e know table is not empty," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "     \+
 ### since the type directsum evaluated to true)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "      Table := op(4, eval(directsum)); " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 6 "      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 " \+
     ### let's get the terms from the expression" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "      List := [extract(G, Alg)];" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      ### if a
ll terms are in Alg1 return Alg1" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 
"      if( isgenerator(List, Table[Alg][1]) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 31 "         RETURN(Table[Alg][1]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ### all
 terms are in Alg2 return Alg2" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 " \+
     elif( isgenerator(List, Table[Alg][2]) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 31 "         RETURN(Table[Alg][2]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "      ### ter
ms from both algebras, return original Alg" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "    \+
     RETURN(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 89 "    #----------------------------------- end of subs \+
------------------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "  #-----------------------
---------> main proc()'s body <--------------------------------" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "  ### called with too many arguments" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 22 "  if( nargs > 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "     ERROR(`too many arguments %1.`, args);" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "  #
## need to use specified algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 
"  elif( nargs = 2 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "     \+
Alg := args[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 29 "  ### we can use default alg." }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 7 "  else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     \+
Alg := ALGEBRA; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 63 "  ### we have to check for the algebra to \+
be a quotient algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "  if( type
(Alg,quotalg) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 34 "     ### getting quotient algebra " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "     Table := op(4, eval(quotalg));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "     ### we know entry exists, \+
since the type quotalg evaluated to true" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 33 "     Algabove := [Table[Alg]][1];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "     # Ideal := [Table[(Alg)]][2];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "     Temp
 := mainlsimplify(G, Algabove);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "
     if( Temp = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "       \+
 RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "     elif( type(Temp
, `*` ) ) then\n" }{MPLTEXT 1 0 26 "        # Correction 2019\n" }
{MPLTEXT 1 0 62 "        # RETURN( op(1,Temp)*quotsimplify( op(2,Temp)
, Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "        RETURN( expand
(PickConstants(Temp)*quotsimplify( PickTerm(Temp), Alg)) );" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 32 "     elif( type(Temp,`+`) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 50 "        RETURN( map(proc(x) if(type(x,`*`
)) then \n" }{MPLTEXT 1 0 49 "                               # Correct
ion 2019\n" }{MPLTEXT 1 0 31 "                               " }
{MPLTEXT 1 0 69 "# product(op(iii,x), iii=1..nops(x)-1) * quotsimplify
(op(-1,x), Alg);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 81 "             \+
                  PickConstants(x) * quotsimplify(PickTerm(x), Alg);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "                            else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "                               q
uotsimplify(x, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "           \+
                 fi; end, Temp) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
9 "     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "        RETURN( quo
tsimplify( Temp , Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 30 "  ### we have multiple terms  " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 59 "  ### expression is a sum, then apply simplify to each term" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "  elif( type(G,`+`) ) then \n" }
{MPLTEXT 1 0 23 "     # Correction 2019\n" }{MPLTEXT 1 0 80 "     # RE
TURN(map(x-> if(type(x,`*`)) then op(1,x) * mainlsimplify(op(2,x),Alg)
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 99 "     RETURN(map(x-> if(type(x,
`*`)) then expand(PickConstants(x) * mainlsimplify(PickTerm(x),Alg)) "
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "                    else mainlsi
mplify(x,Alg) fi, G));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 34 "  ### expression is multiplication" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "  elif( type(G,`*`) ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "     ### we need to further simplif
y the non-constant part" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "     ###
 and return the simplified expression\n" }{MPLTEXT 1 0 23 "     # Corr
ection 2019\n" }{MPLTEXT 1 0 55 "     # RETURN(op(1, G) * mainlsimplif
y(op(2, G), Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     RETURN(e
xpand(PickConstants(G) * mainlsimplify(PickTerm(G), Alg)));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "  ##
# algebra is registered as a triangular algebra, needs special simplif
ication" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "  elif( type(Alg,triangu
lar) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "     ### simplify by
 triangular algebra rules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "     R
ETURN(triangularsimplify(G, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "  ### we have an expression \+
that has two sides (ie. x&*y)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "  \+
elif( type(G,`&*`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "     #
## simplify the two sides" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "     T
emp := mainlsimplify(op(1, G), Alg) &* mainlsimplify(op(2, G), Alg);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 57 "     ### automatic expansion could have resulted in a sum" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "     if( type(Temp,`+`) ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "        ### if so, apply simplifica
tion to all terms in R\n" }{MPLTEXT 1 0 26 "        # Correction 2019
\n" }{MPLTEXT 1 0 83 "        # RETURN(map(x-> if(type(x,`*`)) then op
(1,x) * mainlsimplify(op(2,x),Alg) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
102 "        RETURN(map(x-> if(type(x,`*`)) then expand(PickConstants(
x) * mainlsimplify(PickTerm(x),Alg)) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 60 "                       else mainlsimplify(x,Alg) fi, Temp));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "     ### expansion could have resulted in a multiplication" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "     elif( type(Temp, `*`) ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "        ### if so, apply simplifi
cation to all terms in R\n" }{MPLTEXT 1 0 26 "        # Correction 201
9\n" }{MPLTEXT 1 0 63 "        # RETURN(op(1, Temp) * mainlsimplify(op
(2, Temp),Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "        RETURN(
expand(PickConstants(Temp) * mainlsimplify(PickTerm(Temp),Alg)));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
46 "     ### expansion could have resulted in zero" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 26 "     elif( Temp = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "        mainlsimplify(G,Alg):=0; " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 18 "        RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "     ### find R and S, the
 two sides to our expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    \+
 else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "        R := op(1, Temp);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "        S := op(2, Temp);\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 26 "        # Correction 2019\n" }
{MPLTEXT 1 0 29 "        if type(R, `*`) then\n" }{MPLTEXT 1 0 32 "   \+
        if type(S, `*`) then\n" }{MPLTEXT 1 0 103 "              RETUR
N((PickConstants(R)*PickConstants(S))*mainlsimplify(PickTerm(R)&*PickT
erm(S),Alg));\n" }{MPLTEXT 1 0 16 "           else\n" }{MPLTEXT 1 0 
14 "              " }{MPLTEXT 1 0 59 "RETURN(PickConstants(R)*mainlsim
plify(PickTerm(R)&*S,Alg));" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 15 "  \+
         fi;\n" }{MPLTEXT 1 0 13 "        elif " }{MPLTEXT 1 0 18 "typ
e(S, `*`) then\n" }{MPLTEXT 1 0 73 "              RETURN(PickConstants
(S)*mainlsimplify(R&*PickTerm(S),Alg));" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 12 "        fi;\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "  \+
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "  ### we have one term in the expression\n" }{MPLTEXT
 1 0 13 "  # JUL 2019\n" }{MPLTEXT 1 0 56 "  # elif( isgenerator(G,Alg
) or type(G,constant) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "  \+
elif( isgenerator(G,Alg) or is(G,constant) ) then " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 81 "     if( type(Alg,`withrules`) or type(Alg,`simple`
) or type(Alg,`affine`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 " \+
       RETURN(reduce(G,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "   \+
  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "        RETURN(G);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "  ### otherwise
 we have an error" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "  else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "     ERROR(`%1 is not a generator i
n %2.`, G,Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "  ###
 checking algebra to be a directsum of two algebras" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 32 "  if( type(Alg,directsum) ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 31 "     NewAlg := ismixed(G, Alg);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 28 "     if( NewAlg = Alg ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 18 "        RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         Alg :=
 NewAlg;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### algebra may have rules defi
ned" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "   if( type(Alg,`withrules`)
 or type(Alg,`simple`) or type(Alg,`affine`) ) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "      ### reduce R&*S" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "      RETURN(reduce(R&*S, Alg));" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "   ### not ind
exed algebra, no rules are defined for simplification" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   \+
   ### we need to change the algebra (since evaluate can't deal" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "      ### with any other than the d
efault algebra), but save the default alg. into Gens" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 17 "      using(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      ### lexicographica
l comparisons, R and S are the same" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "      if( R &= S ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   \+
      using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "         m
ainlsimplify(G,Alg):=0; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "       \+
  RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 26 "      ### R comes before S" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "      elif( R &> S ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "         using(`reset`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "         TMP:=-mainlsimplify(S &* R, Alg);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 36 "         mainlsimplify(G,Alg):=TMP; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         RETURN(TMP);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      #
## R comes after S" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "      elif( (
(R &< S) and isgenerator(S, Alg)) or (type(S,`&*`) and (R &>= op(1,S))
) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         using(`reset`
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         TMP:=R &* S;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "         mainlsimplify(G,Alg):=TMP;
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         RETURN(TMP);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
59 "      ### S = [U,V] and R &< U, apply the Jacobian identity" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "      else " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "         using(`reset`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 96 "         TMP:=mainlsimplify((R&*op(1,S))&*op(2,S),Alg
)+mainlsimplify(op(1,S)&*(R&*op(2,S)),Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "         mainlsimplify(G,Alg):=TMP; " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 21 "         RETURN(TMP);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "LieAlg
_Hidden[quotsimplify] := proc(Expr::algebraic, FactAlg::name)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 66 "   local  Basis, i, j, Table, StableSet, Temp, \+
Alg, Ideal, weight;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### memor
y thing" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copyright (C)
 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "   # we
 expect a monomial, already simplified in algebra above" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 32 "   ### getting quotient algebra " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 33 "   Table := op(4, eval(quotalg));" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 69 "   ### we know entry exists, since the type
 quotalg evaluated to true" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   Al
g := [Table[FactAlg]][1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   Ide
al := [Table[(FactAlg)]][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   ### calculating the weight of th
e expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   weight := wt(Exp
r, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "   ### getting basis" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 39 "   Basis := quotbasis(weight, FactAlg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   if (nops(Bas
is) = 0) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       RETURN(0);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   ### getting \+
the stable set for the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   \+
StableSet := Table[(FactAlg, `stableset`)][2];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   ### pick out
 only the elements we will need" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "
   ### positive weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   if( w
eight &!>= [seq(0,i=weight)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
106 "      StableSet := map(proc(x,y,z) if(wt(leading(x,z),z) &!<= y) \+
then x; fi; end, StableSet, weight, Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "   ### negative weights" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 106 "      StableSet
 := map(proc(x,y,z) if(wt(leading(x,z),z) &!>= y) then x; fi; end, Sta
bleSet, weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "   ### our term is could be a part of the ideal" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 33 "   if( member(Expr, Basis) ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 21 "      RETURN( Expr );" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### term is \+
not part of the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "      ### loop through stableset, l
ooking for an expression with a " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 
"      ### leading term that is a subword in Expr" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 34 "      for j to nops(StableSet)  do" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 48 "         Temp := subwd(StableSet[j], Expr, Alg);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 50 "         ### subword in the leading term was found" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 31 "         if( Temp <> [] ) then " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "       \+
     ### take its composition, simplify and apply characteristic p" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "            ### (Temp[]: current te
rm is V, U is leading term from stableset element)" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 64 "            Temp := Expr - mainlsimplify(comp(Temp[
],Alg), Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 47 "            ### return zero if Temp was reduced" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "            if( Temp = 0 ) then" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "               RETURN( 0 );" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
35 "            ### constant multiplier" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "            elif( type(Temp, `*`) ) then\n" }{MPLTEXT 1 0 33 "
               # Correction 2019\n" }{MPLTEXT 1 0 73 "               #
 RETURN( op(1,Temp)*quotsimplify( op(2,Temp), FactAlg) );" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 94 "               RETURN( expand(PickConstants(
Temp) * quotsimplify( PickTerm(Temp), FactAlg)) );" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "            #
## sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "            elif( type(Te
mp,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "               RE
TURN( map(proc(x) if(type(x,`*`)) then \n" }{MPLTEXT 1 0 57 "         \+
                              # Correction 2019\n" }{MPLTEXT 1 0 82 " \+
                                      # op(1,x) * quotsimplify(op(2,x)
, FactAlg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 101 "                   \+
                    expand(PickConstants(x) * quotsimplify(PickTerm(x)
, FactAlg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "                   \+
                else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "           \+
                            quotsimplify(x, FactAlg);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 52 "                                   fi; end, Temp
) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 64 "            ### simply an expression without constant
 multiplier" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "               RETURN( quotsimplify
( Temp, FactAlg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            \+
fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "            break;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "LieAlg_Hidden[triangularsimplify] :
= proc(E::algebraic, Alg::name)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "
   description ``;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declar
ations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   local TMP, P, S, N, si
m, i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   ### memory option" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 \+
by Yuly Billig and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "   # -----
------ subprocedure to be mapped into ---------" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "   sim := proc(x, Algname1,Algname2,Algname3)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     option `Copyright (C) 1999-201
9 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 22 "     local L, Algname;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "   \+
  # x is Const times a monomial, we simplify using" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 31 "     # appropriate Algname rule" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "     L := [ex
tract(x,Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "     if( isgenera
tor(L,Algname1) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "        A
lgname := Algname1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "     elif( i
sgenerator(L,Algname2) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "  \+
      Algname := Algname2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "     \+
elif( isgenerator(L,Algname3) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 28 "        Algname := Algname3;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 28 "     if( type(x,`*`) ) then\n" }{MPLTEXT 1 0 26 "   \+
     # Correction 2019\n" }{MPLTEXT 1 0 59 "        # RETURN( op(1,x)*
mainlsimplify(op(2,x),Algname) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
80 "        RETURN( expand(PickConstants(x) * mainlsimplify(PickTerm(x
),Algname)) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "        RETURN( mainlsimplify(x,Alg
name) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 8 "  end:  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 " \+
#------------- end of subprocedure -----------" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 42 "   ### getting the algebras from the table" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 54 "   (N,S,P) := seq(i,i=[op(4, eval(triangul
ar))[Alg]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 35 "   # we expect that E is a monomial" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 44 "   TMP := mixedtrisimplify(E, P, S, N, Alg);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
21 "   if( TMP = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "     R
ETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "   elif( type(TMP,`+`)
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "     RETURN( map(sim, TM
P, P, S, N) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 34 "     RETURN( sim( TMP, P, S, N) );" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "LieAlg_Hidden[mixedtrisimplify] := \+
proc(E::algebraic, P::name, S::name, N::name, Alg::name)" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Bi
llig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   des
cription ``;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "   local i, Result, Temp, Lhs, \+
Rhs, Lgen, Alg1, Alg2;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   ### me
mory option" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "   # option system, \+
remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "   if( isgenerator(E,Alg) or type(E,indexed) ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(E);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   \+
   ### breaking expression into its two sides" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "      Lhs := op(1,E); Rhs := op(2,E);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "   # if either Lhs or Rhs is not pu
re (contains terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   # from dif
ferent algebras), then mixedtrisimplify it" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "   Lgen := [extract(Lhs,Alg)]; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "   if ( isgenerator(Lgen, P) ) then " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 16 "      Alg1 := P;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 38 "   elif ( isgenerator(Lgen, S) ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      Alg1 := S;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
38 "   elif ( isgenerator(Lgen, N) ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      Alg1 := N;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 
"   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      Temp := mixedtris
implify(Lhs, P, S, N, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "    \+
  if( Temp = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         R
ETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      elif( type(Temp,
`*`) ) then\n" }{MPLTEXT 1 0 27 "         # Correction 2019\n" }
{MPLTEXT 1 0 81 "         # RETURN( op(1,Temp)*mixedtrisimplify( op(2,
Temp)&*Rhs, P, S, N, Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 102 "  \+
       RETURN( expand(PickConstants(Temp) * mixedtrisimplify( PickTerm
(Temp)&*Rhs, P, S, N, Alg)) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 " \+
     elif( type(Temp,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 
"         RETURN( map(proc(x) if(type(x,`*`)) then \n" }{MPLTEXT 1 0 
50 "                                # Correction 2019\n" }{MPLTEXT 1 
0 89 "                                # op(1,x) * mixedtrisimplify(op(
2,x)&*Rhs, P, S, N, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "     \+
                           expand(PickConstants(x) * mixedtrisimplify(
PickTerm(x)&*Rhs, P, S, N, Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "                             else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 71 "                                mixedtrisimplify(x&*Rhs, P, S, N
, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                        \+
     fi; end, Temp) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      els
e" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "         RETURN( mixedtrisimpl
ify( Temp &* Rhs, P, S, N, Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   Lge
n := [extract(Rhs,Alg)]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   if ( isgenerator(Lgen, P) ) then
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      Alg2 := P;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 38 "   elif ( isgenerator(Lgen, S) ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      Alg2 := S;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 38 "   elif ( isgenerator(Lgen, N) ) then " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 16 "      Alg2 := N;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      Te
mp := mixedtrisimplify(Rhs, P, S, N, Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "      if( Temp = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 34 "      elif( type(Temp,`*`) ) then\n" }{MPLTEXT 1 0 27 "         \+
# Correction 2019\n" }{MPLTEXT 1 0 81 "         # RETURN( op(1,Temp)*m
ixedtrisimplify( Lhs&*op(2,Temp), P, S, N, Alg) );" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 102 "         RETURN( expand(PickConstants(Temp) * mixe
dtrisimplify( Lhs&*PickTerm(Temp), P, S, N, Alg)) );" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 33 "      elif( type(Temp,`+`) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 51 "         RETURN( map(proc(x) if(type(x,`*`)) th
en \n" }{MPLTEXT 1 0 51 "                                 # Correction
 2019\n" }{MPLTEXT 1 0 90 "                                 # op(1,x) \+
* mixedtrisimplify(Lhs&*op(2,x), P, S, N, Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 109 "                                 expand(PickConstant
s(x) * mixedtrisimplify(Lhs&*PickTerm(x), P, S, N, Alg));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 33 "                             else" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 72 "                                 mixedtris
implify(Lhs&*x, P, S, N, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 " \+
                            fi; end, Temp) );" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "    \+
     RETURN( mixedtrisimplify( Lhs &* Temp, P, S, N, Alg) );" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 47 "   # both sides are monomials in one subalgebra" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   # if it is the same algebra, the
n we are done" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   # else we need \+
to rearrange and apply reduce" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "  \+
 if( Alg1 = Alg2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RE
TURN(E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 67 "   ### this nice little statement is for checking for
 mixed weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "   elif( ((isgene
rator([extract(Lhs,Alg)],P) and isgenerator([extract(Rhs,Alg)],N)) or"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "        (isgenerator([extract(Lh
s,Alg)],N) and isgenerator([extract(Rhs,Alg)],P)))" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 84 "              and not(((wt(Lhs, Alg) + wt(Rhs, Alg)
) &!>= [seq(0,i=wt(Lhs,Alg))]) or" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
89 "                      ((wt(Lhs, Alg) + wt(Rhs, Alg)) &!<= [seq(0,i
=wt(Lhs,Alg))])) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      ##
# we have mixed weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RE
TURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "   ### reducing the expression" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "   elif( isgenerator(Lhs,Alg1) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 38 "      if( isgenerator(Rhs,Alg2) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "         RETURN( reduce(E,Alg) );" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "         RETURN( mixedtrisimplify( (Lhs&*op(1,Rhs))&*
op(2,Rhs), P, S, N, Alg) + " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "    \+
             mixedtrisimplify( op(1,Rhs)&*(Lhs&*op(2,Rhs)), P, S, N, A
lg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### we \+
further simplify stuff" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "      RETURN( mixedtrisimplify( op
(1,Lhs)&*(op(2,Lhs)&*Rhs), P, S, N, Alg) + " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 77 "              mixedtrisimplify( (op(1,Lhs)&*Rhs)&*op(
2,Lhs), P, S, N, Alg) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "LieAlg_
Hidden[reduce] := proc(expr::algebraic, Alg::name) " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 98 "   description `reduce(expression) simplifies an e
xpression according to the rules defined in the " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 95 "               lookup table; reduce() can only simpli
fy an expression involving two terms, not " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "               more`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   g
lobal MATRIX_TYPE, MATRIX_LACING;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
51 "   local lhs, rhs, consl, consr, cons, Table, func;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 43 "   ### give it memory to improve efficiency" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019
 by Yuly Billig and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### th
is is true for all\n" }{MPLTEXT 1 0 14 "   # JUL 2019\n" }{MPLTEXT 1 
0 35 "   # if( type(expr,constant) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "   if( is(expr,constant) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "      RETURN(expr);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 59 "   elif( type(expr,`&*`) and op(1,expr) = op(2,expr) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "   ### we ha
ve algebra with rules (ie triangular, and user defined)" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 37 "   elif( type(Alg,`withrules`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      func := functionize(expr, Alg
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      if( func <> FAIL ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "         RETURN(func(op(op(1,ex
pr)),op(op(2,expr))));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 73 "   ### we have a simple algebra, it has its own simplification p
rocedures" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 58 "      ### we get the type of the algebra (ie A,
 B, C, etc)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      Table := op(4,
eval(simple));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      unprotect(e
valn(MATRIX_TYPE), evaln(MATRIX_LACING));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "      using(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "      if( type(Alg,`affine`) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 71 "         (MATRIX_LACING,MATRIX_TYPE) := Table[cat(Alg,`_simpl
e`),type];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "         func := affi
nesimplefunction(expr, Table[cat(Alg,`_simple`)]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "  \+
       (MATRIX_LACING,MATRIX_TYPE) := Table[Alg,type];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 65 "         func := simplefunction_||MATRIX_LACING
(expr,Table[Alg]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      using(`reset`);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 56 "      protect(evaln(MATRIX_TYPE), evaln(MATRI
X_LACING));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      if( func <> FA
IL ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "         RETURN(func);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 19 "   ### default case" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "   RETURN(expr);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 
"end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 74 "LieAlg_Hidden[simplefunction_ADE_matrix] :
= proc(E::`algebraic`,M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 
"   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 116 "   description `this is the f
unction for a simple lie algebra, that does the simplification of alge
bras An, Dn, En`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   local LI, R
I, Lhs, Rhs;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 54 "  ### single term in, return 0 if not a true genera
tor" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "  if( not(type(E,`&*`)) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "     if( (op(0,E) = op(0,GENE
RATORS[2]) and type([op(E)],`htruegen`))" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 86 "      or (op(0,E) = op(0,GENERATORS[1]) and type([op(E)],`ADE
_matrix_truegen`)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "      \+
  RETURN(E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     else" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 18 "        RETURN(0);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "  else" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 96 "    if( 0 = (simplefunction_ADE_matrix(op(1,E),M) * simplefun
ction_ADE_matrix(op(2,E),M)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
17 "       RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "       ### setting up our variable
s" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "       Lhs := op(1,E); Rhs := \+
op(2,E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "       LI := [op(Lhs)];
 RI := [op(Rhs)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
28 "    ### h[i]'s on both sides" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 
"    if( op(0,GENERATORS[2]) = op(0,Lhs) and op(0,GENERATORS[2]) = op(
0,Rhs)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       RETURN(0);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 48 "    ### on LHS we have h[i], RHS: e[k1,k2,..,kn]" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 48 "    elif( op(0,GENERATORS[2]) = op(0,Lhs) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "       RETURN(add(RI[j] * M[LI
[],j],j=1..nops(RI)) * op(0,GENERATORS[1])[RI[]]);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "    ### oppos
ite of the previous case" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "    eli
f( op(0,GENERATORS[2]) = op(0,Rhs) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 85 "       RETURN(-1 * add(LI[j] * M[RI[],j],j=1..nops(LI
)) * op(0,GENERATORS[1])[LI[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "    ### we have e[k1,..,kn] on \+
both sides, but they have to be true generators" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "    elif( scpd(LI,RI,M) = -2 ) then " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 54 "       RETURN(((-1)^epsilon_||MATRIX_TYPE(LI,RI,
M)) * " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "          add(LI[j] * op(
0,GENERATORS[2])[j],j=1..nops(LI))); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 11 "           " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "    ### if sca
lar product is -1" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "    elif( scpd
(LI,RI,M) = -1 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "       RE
TURN(((-1)^epsilon_||MATRIX_TYPE(LI,RI,M)) * " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "          map((x,y)->y[x[]],[LI+RI], op(0,GENERATORS[
1]))[]); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "    ### else we have 0 or larger" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 9 "    else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "     \+
  RETURN(0); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "e
nd:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 70 "LieAlg_Hidden[simplefunction_B_matrix] := pr
oc(E::algebraic,M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   op
tion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 116 "   description `this is the functi
on for a simple lie algebra, that does the simplification of algebras \+
of type Bn`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   local LI, RI, i,
 j, a, DI, Lhs, Rhs, DM, Len;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 " ### single term in" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 29 " if( not(type(E,`&*`)) ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 67 "   if( (op(0,E) = op(0,GENERATORS[2]) and type([
op(E)],`htruegen`))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "    or (op(0
,E) = op(0,GENERATORS[1]) and type([op(E)],`B_matrix_truegen`)) ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(E);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 " \+
     RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 " ###
 expr to look at" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 " else" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 91 "   if( 0 = (simplefunction_B_matrix(op(1,E
),M) * simplefunction_B_matrix(op(2,E),M)) ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      ### setting up \+
our variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      Lhs := op(1,
E); Rhs := op(2,E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      LI := \+
[op(Lhs)]; RI := [op(Rhs)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "   ### the product consists of two h[i]'s" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 80 "   if( op(0,GENERATORS[2]) = op(0,Lhs) and op(0,GENE
RATORS[2]) = op(0,Rhs)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   \+
   RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 54 "   ### on lhs we have h[i], on rhs we have e[k1,..
,kn]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[2]
) = op(0,Lhs) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      RETUR
N(add(RI[j] * M[LI[],j],j=1..nops(RI)) * op(0,GENERATORS[1])[RI[]]);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 36 "   ### opposite of the previous case" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[2]) = op(0,Rhs) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "      RETURN(-1 * add(LI[j] * M[RI[
],j],j=1..nops(LI)) * op(0,GENERATORS[1])[LI[]]);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   ### e[k1,..
,kn] on both sides, unfold the indices in case they are real roots" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "      ### unfolding expression" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "      DI := unfold_B_matrix(E);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      ### matri
x for unfolded algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "      DM \+
:= op(4,eval(simple))[cat(ALGEBRA,`_unfolded`)];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      ### save \+
the size of folded terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      L
en := nops(LI)+1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 38 "      using(cat(ALGEBRA,`_unfolded`));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "      ### simplify the expression a
ccording to Dn rules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "      if( D
I = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "      ### we have a sum, simpl. all terms" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 31 "      elif( type(DI,`+`) ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 47 "         DI := map((x,y)->if(type(x,`*`)) then\n" }
{MPLTEXT 1 0 49 "                               # Correction 2019\n" }
{MPLTEXT 1 0 80 "                               # op(1,x) * simplefunc
tion_ADE_matrix(op(2,x),y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 99 "    \+
                           expand(PickConstants(x) * simplefunction_AD
E_matrix(PickTerm(x),y));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      \+
                      else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "    \+
                           simplefunction_ADE_matrix(x,y);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 40 "                            fi, DI, DM);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      ### we have a product, get constant, simpl. the rest" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      elif( type(DI,`*`) ) then\n" 
}{MPLTEXT 1 0 27 "         # Correction 2019\n" }{MPLTEXT 1 0 67 "    \+
     # DI:= op(1,DI) * simplefunction_ADE_matrix(op(2,DI), DM);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "         DI:= expand(PickConstants(
DI) * simplefunction_ADE_matrix(PickTerm(DI), DM));" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      ### ju
st an expression, simpl. it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "    \+
  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "         DI := simplefunc
tion_ADE_matrix(DI, DM);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      using(`reset`);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "      ### simpl. resulted in zero" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 23 "      if( DI = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "  \+
       RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 25 "      ### fold back stuff" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "   \+
      ### we still have a sum, pick out constants and look at indices"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "         if( type(DI,`+`) ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "            if( type(op(1,DI),`
*`) ) then\n" }{MPLTEXT 1 0 33 "               # Correction 2019\n" }
{MPLTEXT 1 0 70 "               # if( op(0,op(2,op(1,DI))) = op(0,GENE
RATORS[2]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "              \+
 if( op(0,PickTerm(op(1,DI))) = op(0,GENERATORS[2]) ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 72 "                  ### remove h[i] elements \+
that are larger than the max " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "  \+
                ### index of Bn  element (we subs in zero for them)" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "                  RETURN(subs(\{op
(0,GENERATORS[2])[Len]=0\}, DI));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "               else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "        \+
          a := op(1,op(1,DI));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 " \+
                 LI := [op(op(2,op(1,DI)))];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "                  RI := [op(op(2,op(2,DI)))];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "                  RI := LI[nops(LI)
-1..nops(LI)] + RI[nops(RI)-1..nops(RI)];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 52 "                  DM := [LI[1..nops(LI)-2][], RI[]];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "               if( op(0,op(1,DI)) = op(0,GENERATORS[2
]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "                  ### \+
remove h[i] elements that are larger than the max " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 69 "                  ### index of Bn  element (we subs
 in zero for them)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "             \+
     RETURN(subs(\{op(0,GENERATORS[2])[Len]=0\}, DI));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 19 "               else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "                  a := 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "                  LI := [op(op(1,DI))];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 39 "                  RI := [op(op(2,DI))];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "                  RI := LI[nops(LI)
-1..nops(LI)] + RI[nops(RI)-1..nops(RI)];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 52 "                  DM := [LI[1..nops(LI)-2][], RI[]];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 78 "            ### when we have two terms, it folds back into on
e term, for which" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "            ##
# we have to drop the last index" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 
"            RETURN(a * op(0,GENERATORS[1])[DM[1..nops(DM)-1][]]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "         ### not a sum, pick out constant part and indices" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "         elif( type(DI,`*`) ) then
\n" }{MPLTEXT 1 0 30 "            # Correction 2019\n" }{MPLTEXT 1 0 
61 "            # if( op(0,op(2,DI)) = op(0,GENERATORS[2]) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "            if( op(0,PickTerm(DI)) \+
= op(0,GENERATORS[2]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "   \+
            ### remove h[i] elements that are larger than the max " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "               ### index of Bn  ele
ment (we subs in zero for them)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "
               RETURN(subs(\{op(0,GENERATORS[2])[Len]=0\}, DI));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 29 "               a := op(1,DI);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 36 "               DM := [op(op(2,DI))];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "         ### we have a s
ingle generator in Dn+1 coming back, pick out indices" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
53 "            if( op(0,DI) = op(0,GENERATORS[2]) ) then" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 69 "               ### remove h[i] elements that
 are larger than the max " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "      \+
         ### index of Bn  element (we subs in zero for them)" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 62 "               RETURN(subs(\{op(0,GENERAT
ORS[2])[Len]=0\}, DI));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "        \+
    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "               a := 1;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "               DM := [op(DI)];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "         ### the case when we \+
have a sequence of ones inside, drop last term" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "         if( DM[nops(DM)] = 0 ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 65 "            RETURN(a * op(0,GENERATORS[1])[DM[1.
.nops(DM)-1][]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 79 "         ### we have a sequence of zeros, ones
 and twos, replace last two terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "         ### with a two" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "    \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "           RETURN(a * \+
op(0,GENERATORS[1])[[DM[1..nops(DM)-2][],DM[nops(DM)-1]+DM[nops(DM)]][
]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "         fi;  " }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 " fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "LieAlg_Hidden[simplefunc
tion_C_matrix] := proc(E::algebraic,M::Matrix)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 116 "   descriptio
n `this is the function for a simple lie algebra, that does the simpli
fication of algebras of type Cn`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
18 "   global ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   local \+
LI, RI, i, j, a, AI, Lhs, Rhs, AM;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
12 "   remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 19 " ### single term in" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 " if( not(type(E,`&*`)) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 67 "   if( (op(0,E) = op(0,GENERATORS[2]) and type([op(E)
],`htruegen`))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "    or (op(0,E) =
 op(0,GENERATORS[1]) and type([op(E)],`C_matrix_truegen`)) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(E);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "     \+
 RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 " ### exp
r to look at" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 " else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 91 "   if( 0 = (simplefunction_C_matrix(op(1,E),M)
 * simplefunction_C_matrix(op(2,E),M)) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 
"   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      ### setting up ou
r variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      Lhs := op(1,E)
; Rhs := op(2,E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      LI := [o
p(Lhs)]; RI := [op(Rhs)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 41 "   ### the product consists of two h[i]'s" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "   if( op(0,GENERATORS[2]) = op(0,Lhs) and op(0,GENER
ATORS[2]) = op(0,Rhs)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "    \+
  RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 54 "   ### on lhs we have h[i], on rhs we have e[k1,..,
kn]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[2])
 = op(0,Lhs) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      RETURN
(add(RI[j] * M[LI[],j],j=1..nops(RI)) * op(0,GENERATORS[1])[RI[]]);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "   ### opposite of the previous case" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 47 "   elif( op(0,GENERATORS[2]) = op(0,Rhs) ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 84 "      RETURN(-1 * add(LI[j] * M[RI[],j],j=1..
nops(LI)) * op(0,GENERATORS[1])[LI[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   ### e[k1,..,kn] on bo
th sides, unfold the indices if real roots" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      ##
# expand the sum if we have to" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 " \+
     AI := unfold_C_matrix(E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 " \+
     AM := op(4,eval(simple))[cat(ALGEBRA,`_unfolded`)];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      u
sing(cat(ALGEBRA,`_unfolded`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "
      ### simplify the expression according to An rules" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 23 "      if( AI = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "      ### we have a sum, s
impl. all terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      elif( type
(AI,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "         AI := m
ap((x,y)->if(type(x,`*`)) then\n" }{MPLTEXT 1 0 47 "                  \+
           # Correction 2019\n" }{MPLTEXT 1 0 78 "                    \+
         # op(1,x) * simplefunction_ADE_matrix(op(2,x),y);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 97 "                             expand(PickCon
stants(x) * simplefunction_ADE_matrix(PickTerm(x),y));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 31 "                          else " }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 60 "                             simplefunction_ADE
_matrix(x,y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                  \+
        fi, AI, AM);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 58 "      ### we have a product, get constant, \+
simpl. the rest" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      elif( type
(AI,`*`) ) then\n" }{MPLTEXT 1 0 27 "         # Correction 2019\n" }
{MPLTEXT 1 0 66 "         # AI:= op(1,AI) * simplefunction_ADE_matrix(
op(2,AI),AM);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "         AI:= expa
nd(PickConstants(AI) * simplefunction_ADE_matrix(PickTerm(AI),AM));" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "      ### just an expression, simpl. it" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "    \+
     AI := simplefunction_ADE_matrix(AI,AM);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      \+
using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 33 "      ### simpl. resulted in zero" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 23 "      if( AI = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      ### fold back loop" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 66 "         ### we still have a sum, pick first element \+
into temp var" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "         if( type(
AI,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "            AM :=
 op(1,AI);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "         ### assign a
ll of it, it's not a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "       \+
  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "            AM := AI;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "         ### we
 have a constant front, pick it out" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "         if( type(AM,`*`) ) then\n" }{MPLTEXT 1 0 30 "            \+
# Correction 2019\n" }{MPLTEXT 1 0 28 "            # a := op(1,AM);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            # AM := op(2,AM);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "            a := PickConstants(AM);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "            AM := PickTerm(AM);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "         ### no cons, our cons \+
is one" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 19 "            a := 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "         fi;  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "         ### we had an h[i] sum \+
coming back from the simplification, return it" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "         if( op(0,AM) = op(0,GENERATORS[2]) ) then" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "            ### remove h[i] elemen
ts that are larger than the max index of Cn " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "            ### element (we subs in zero for them)" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "            RETURN(subs(\{seq(op(0
,GENERATORS[2])[i]=0,i=nops(LI)+1..(2*nops(LI)-1))\},AI));" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "     \+
    ### the actual fold-back loop" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "            LI
 := [op(AM)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "            RI := \+
[seq(0, i = RI)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "            fo
r j to nops(RI)-1 do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "           \+
    RI[j] := LI[j] + LI[nops(LI) + 1 - j];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 
"            RI[j] := LI[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            ### return result" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "            RETURN(a * op(0,AM)[RI[
]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 " fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "LieAlg_Hidden[simplefunctio
n_F_matrix] := proc(E::algebraic,M::Matrix)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 116 "   descriptio
n `this is the function for a simple lie algebra, that does the simpli
fication of algebras of type F4`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
43 "   local LI, RI, i, a, b, EI, Lhs, Rhs, EM;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 " ### single ter
m in" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 " if( not(type(E,`&*`)) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "   if( (op(0,E) = op(0,GENERA
TORS[2]) and type([op(E)],`htruegen`))" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 82 "    or (op(0,E) = op(0,GENERATORS[1]) and type([op(E)],`F_matr
ix_truegen`)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETUR
N(E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 " ### expr to look at" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 5 " else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "   if( 0 = (simplefun
ction_F_matrix(op(1,E),M) * simplefunction_F_matrix(op(2,E),M)) ) then
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 " \+
     ### setting up our variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
37 "      Lhs := op(1,E); Rhs := op(2,E);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "      LI := [op(Lhs)]; RI := [op(Rhs)];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   ### the product consists of tw
o h[i]'s" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   if( op(0,GENERATORS[
2]) = op(0,Lhs) and op(0,GENERATORS[2]) = op(0,Rhs)) then" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "   ### on lhs w
e have h[i], on rhs we have e[k1,..,kn]" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 47 "   elif( op(0,GENERATORS[2]) = op(0,Lhs) ) then" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 79 "      RETURN(add(RI[j] * M[LI[],j],j=1..nops(R
I)) * op(0,GENERATORS[1])[RI[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### opposite of the previou
s case" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[
2]) = op(0,Rhs) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "      RET
URN(-1 * add(LI[j] * M[RI[],j],j=1..nops(LI)) * op(0,GENERATORS[1])[LI
[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 52 "   ### e[k1,..,kn] on both sides, unfold the indices"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "      EI := unfold_F_matrix(E);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "      EM := op(4,eval(simple))[cat(ALGEBRA,`_unfolded
`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 38 "      using(cat(ALGEBRA,`_unfolded`));" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 55 "      ### simplify the expression according to
 Dn rules" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "      if( EI = 0 ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "    \+
  ### we have a sum, simpl. all terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 31 "      elif( type(EI,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "         EI := map((x,y)->if(type(x,`*`)) then\n" }{MPLTEXT 1 0 
49 "                               # Correction 2019\n" }{MPLTEXT 1 0 
80 "                               # op(1,x) * simplefunction_ADE_matr
ix(op(2,x),y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 99 "                 \+
              expand(PickConstants(x) * simplefunction_ADE_matrix(Pick
Term(x),y));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "                   \+
         else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "                 \+
              simplefunction_ADE_matrix(x,y);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "                            fi, EI, EM);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "      \+
### we have a product, get constant, simpl. the rest" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 32 "      elif( type(EI,`*`) ) then\n" }{MPLTEXT 1 0 
27 "         # Correction 2019\n" }{MPLTEXT 1 0 66 "         # EI:= op
(1,EI) * simplefunction_ADE_matrix(op(2,EI),EM);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 85 "         EI:= expand(PickConstants(EI) * simplefuncti
on_ADE_matrix(PickTerm(EI),EM));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      ### just an expression, s
impl. it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 48 "         EI := simplefunction_ADE_matrix(EI,
EM);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "      using(`reset`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      ### simpl
. resulted in zero" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "      if( EI \+
= 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(0);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 24 "      ### fold back loop" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 " \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "         ### we still \+
have a sum, pick first element into temp var" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "         if( type(EI,`+`) ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 27 "            EM := op(1,EI);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "         ### assign all of it, it's not a sum" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "            EM := EI;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 53 "         ### we have a constant up front, p
ick it out" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "         if( type(EM,
`*`) ) then\n" }{MPLTEXT 1 0 30 "            # Correction 2019\n" }
{MPLTEXT 1 0 28 "            # a := op(1,EM);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "            # EM := op(2,EM);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "            a := PickConstants(EM);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 31 "            EM := PickTerm(EM);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 37 "         ### no cons, our cons is one" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 19 "            a := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "   \+
      fi;  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 78 "         ### we had an h[i] sum coming back from the
 simplification, return it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "     \+
    if( op(0,EM) = op(0,GENERATORS[2]) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "            ### remove h[i] elements that are larger \+
than the max index of Bn " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      \+
      ### element (we subs in zero for them)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 75 "            RETURN(subs(\{op(0,GENERATORS[2])[4]=0,op
(0,GENERATORS[2])[5]=0," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "        \+
                 op(0,GENERATORS[2])[6]=op(0,GENERATORS[2])[4]\},EI));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "         " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 38 "         ### the actual fold-back loop" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "            LI := [op(EM)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
56 "            RI := [LI[1]+LI[5],LI[2]+LI[4],LI[3],LI[6]];" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 32 "            ### return our stuff" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "            RETURN(a * op(0,EM)[RI[
]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 " fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "LieAlg_Hidden[simplefunctio
n_G_matrix] := proc(E::algebraic,M::Matrix)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 116 "   descriptio
n `this is the function for a simple lie algebra, that does the simpli
fication of algebras of type G2`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
26 "   local LI, RI, Lhs, Rhs;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 " ### single term in" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 29 " if( not(type(E,`&*`)) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 67 "   if( (op(0,E) = op(0,GENERATORS[2]) and type(
[op(E)],`htruegen`))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "    or (op(
0,E) = op(0,GENERATORS[1]) and type([op(E)],`G_matrix_truegen`)) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      RETURN(E);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "
      RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 " ##
# expr to look at" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 " else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 91 "   if( 0 = (simplefunction_G_matrix(op(1,
E),M) * simplefunction_G_matrix(op(2,E),M)) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 16 "      RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      ### setting up \+
our variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      Lhs := op(1,
E); Rhs := op(2,E);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      LI := \+
[op(Lhs)]; RI := [op(Rhs)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "   ### the product consists of two h[i]'s" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 80 "   if( op(0,GENERATORS[2]) = op(0,Lhs) and op(0,GENE
RATORS[2]) = op(0,Rhs)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   \+
   RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 54 "   ### on lhs we have h[i], on rhs we have e[k1,..
,kn]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[2]
) = op(0,Lhs) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      RETUR
N(add(RI[j] * M[LI[],j],j=1..nops(RI)) * op(0,GENERATORS[1])[RI[]]);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 36 "   ### opposite of the previous case" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "   elif( op(0,GENERATORS[2]) = op(0,Rhs) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 84 "      RETURN(-1 * add(LI[j] * M[RI[
],j],j=1..nops(LI)) * op(0,GENERATORS[1])[LI[]]);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ### e[k1,..
,kn] on both sides, look up simplification rule" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      RE
TURN(G22G2(E, ALGEBRA));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 " fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "LieAlg_Hidden[scpd] := proc(A::list
(integer),B::list(integer),M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Maz
zag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "   description `produces \+
the scalar product of two lists, given the matrix for them`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 19 "   local i, j, Res;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   Res := 0;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   for i to nops(A) do " }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 25 "      for j to nops(B) do" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 46 "         Res := Res + (A[i]  * B[j] * M[i,j]);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "   RETURN
(Res);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 82 
"LieAlg_Hidden[epsilon_type_A] := proc(A::list(integer),B::list(intege
r),M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyrig
ht (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 49 "   description `epsilon function for An algebra`;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   local i, j, Result, n;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "   Result := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "   n := nops
(convert(linalg[row](M,1),list));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "   for i to nops(A) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "     \+
 for j to nops(B) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "        if
( (i=j+1 and 2*j<=n) or (i=j-1 and 2*i>n) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "           Result := Result + ((A[i]*B[j]*M[i,j]) mod
 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "        fi;      " }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 10 "       od;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 7 "    od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "    RETURN(Result
 mod 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
82 "LieAlg_Hidden[epsilon_type_D] := proc(A::list(integer),B::list(int
eger),M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copy
right (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 18 "   description ``;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "   local i, j, Result;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "   Result := 0;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   for i to nops(A) do" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 26 "      for j to nops(B) do " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 25 "         if( i > j ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 58 "            Result := Result + ((A[i]*B[j]*M[i,j]) mo
d 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "         fi;      " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   RETURN
(Result mod 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 82 "LieAlg_Hidden[epsilon_type_E] := proc(A::list(integer
),B::list(integer),M::Matrix)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "  \+
 option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   description `epsilon function \+
for En algebra`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   local i, j, \+
Result, n;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "   Result := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 
"   n := nops(convert(linalg[row](M,1),list));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "   for i to nops(A) do" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 26 "      for j to nops(B) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
52 "         if( (i=j+1 and i<=n-3) or (i=n-3 and j=n-2)" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 56 "          or (i=n-2 and j=n-1) or (i=n-3 and \+
j=n) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "            Result :
= Result + ((A[i]*B[j]*M[i,j]) mod 2);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 18 "         fi;      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      \+
od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "   RETURN(Result mod 2);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "LieAlg_Hidden[affinesimplef
unction] := proc(Expr::algebraic, M::Matrix)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 143 "   descriptio
n `this is the function for an affine simple lie algebra, that does th
e simplification of an expression involving only two terms`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 48 "   local nlhs, nrhs, lhs, rhs, func, klhs
, krhs;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 " if( not(type(Expr,`&*`)) ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 33 "   using(cat(ALGEBRA,`_simple`));" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 93 "   if( 0 = simplefunction_||MATRIX_LACING(op(0,Exp
r)[[op(Expr)][1..nops(Expr)-1][]],M) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "       func := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "       func := Expr;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "   using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
16 "   RETURN(func);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "      " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 " else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 41 "   ### break up expression into two sides" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 22 "   lhs := op(1, Expr);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 22 "   rhs := op(2, Expr);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### anything multiplied by K \+
is zero" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "   if( lhs = GENERATORS[
3] or rhs = GENERATORS[3] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 
"      func := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 40 "   ### we have to compute matching rules" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "      ### drop the k values from the end" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 48 "      nlhs := op(0,lhs)[op(1..nops(lhs)-1,lh
s)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      nrhs := op(0,rhs)[op(
1..nops(rhs)-1,rhs)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      klhs
 := op(nops(lhs),lhs);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      krh
s := op(nops(rhs),rhs);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "      ### do the simplification acc
ording to the corresponding simple algebra rules" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 61 "      func := reduce(nlhs&*nrhs,op(4,eval(affine))[AL
GEBRA]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "      ### adding back the k values" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 24 "      ### if we have sum" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "      if( type(func,`+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "         func := map((x,y,z)->if(type(x,`*`)) then\n"
 }{MPLTEXT 1 0 51 "                                 # Correction 2019
\n" }{MPLTEXT 1 0 77 "                                 # op(1,x) * op(
0,op(2,x))[op(op(2,x)), y+z];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "  \+
                               expand(PickConstants(x) * op(0,op(-1,x)
)[op(PickTerm(x)), y+z]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      \+
                        else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "   \+
                              op(0,x)[op(x), y+z];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 52 "                              fi, func, klhs, krhs)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 37 "      ### if we have a multiplication" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "      elif( type(func,`*`) ) then\n" }{MPLTEXT 1 0 
27 "         # Correction 2019\n" }{MPLTEXT 1 0 76 "         # func :=
 op(1,func) * op(0,op(2,func))[op(op(2,func)), klhs+krhs];" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 96 "         func := expand(PickConstants(func)
 * op(0,op(-1,func))[op(PickTerm(func)), klhs+krhs]);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      ### \+
no sum, no constant" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      elif( \+
func <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "         func :
= op(0,func)[op(func), klhs+krhs]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 
"      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "      ### applying rule of adding delta(i,-j)*i*dotpr
oduct()*K" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "      func := func+(d
elta(klhs,-krhs)*klhs*dotproduct(nlhs,nrhs,op(4,eval(affine))[ALGEBRA]
)*GENERATORS[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 " fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ### returning what we
 calculated" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "   RETURN(func);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "LieAlg_
Hidden[functionize] := proc(expr::algebraic, Alg::name) " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 94 "   description `functionize(expression), if p
ossible, finds the rule in the lookup table that " }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 97 "               suits the given expression, and retur
ns that rule converted into a maple function;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "               when no corresponding rule is found or
 the lookup table is empty FAIL is " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
25 "               returned`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "  \+
 ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   local table
, i, lhs, rhs, temp, entries; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 " \+
  ### give it memory for efficiency" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
88 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 45 "   ### breaking the expression into two p
arts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   if( not(type(expr,`&*`))
 or op(4,eval(withrules)) = NULL ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "      RETURN(FAIL);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   el
se" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      lhs := op(1,expr); " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      rhs := op(2,expr); " }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 41 "      ### getting rules from lookup table
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      entries := op(4,eval(with
rules))[Alg]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   ##
# else we loop through the rules for the algebra in the table" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   for i to nops(entries) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "       ### temp holds the i-th rule
 in the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "       temp := op(
1,entries[i]); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 38 "       ### looking for a matching rule" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 53 "       if( (lhs = op(1,temp) and rhs = op
(2,temp)) or" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 55 "           (type(lhs,indexed) and type(rhs,indexed)
 and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "           type(op(1,temp),
indexed) and type(op(2,temp),indexed) and" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 84 "           hastype([op(op(1,temp))],`name`) and hasty
pe([op(op(2,temp))],`name`) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "
           op(0,lhs) = op(0,op(1,temp)) and nops([op(lhs)]) = nops([op
(op(1,temp))]) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "           op
(0,rhs) = op(0,op(2,temp)) and nops([op(rhs)]) = nops([op(op(2,temp))]
)) or" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "           (type(lhs,indexed) and type(op(1,temp),ind
exed) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "           hastype([op
(op(1,temp))],`name`) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "      \+
     op(0,lhs) = op(0,op(1,temp)) and nops([op(lhs)]) = nops([op(op(1,
temp))]) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "           rhs = op
(2,temp)) or" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 32 "           (lhs = op(1,temp) and" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 61 "           type(rhs,indexed) and type(op(2,temp),i
ndexed) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "           hastype([
op(op(2,temp))],`name`) and" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 "    \+
       op(0,rhs) = op(0,op(2,temp)) and nops([op(rhs)]) = nops([op(op(
2,temp))])) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 34 "         RETURN(op(2,entries[i]));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 36 "   ### no matches found in the table" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 16 "   RETURN(FAIL);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "# Correction 2019\n" }{MPLTEXT 1 0 
18 "# Removed simplify" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 39 "#LieAlg
_Hidden[`simplify/&@`] := proc()" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 
"#   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.
`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "#   description `This is an i
nterface to the Associative algebra simplification function.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "#   if( nops(args[1]) = 1 ) then " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 103 "#      if( args[1] = op(4,eval(h
wrep))[REPRESENTATION] ) then RETURN(repsimplify(args,REPRESENTATION))
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "#      else RETURN(asimplify(a
rgs,ALGEBRA)); fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "#   elif( op
(2,args[1]) = op(4,eval(hwrep))[REPRESENTATION] ) then RETURN(repsimpl
ify(args,REPRESENTATION));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "#   e
lse RETURN(asimplify(args,ALGEBRA));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 7 "#   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "#end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "LieAlg[asimplify] := proc()" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 126 "   descriptio
n `This is an interface to the function mainasimplify() which is the m
ain associative simplification procedure.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "   local Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### lets simplify!" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 42 "   Temp := traperror(mainasimplify(args));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "#Temp := mainasimplify(args);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   ### we had an error" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 30 "   if( Temp = lasterror ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 22 "     ERROR(lasterror);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### no erro
r, apply characteristic p" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "     RETURN(convert(applychar(T
emp),`&^`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "LieAlg_Hidden[main
asimplify] := proc(G::algebraic) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
80 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "   description `T
his is a simplification function for associative algebras.`;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 84 "   local Temp, Cons, i, j, Alg, Pre, Post
, Elem, Result, Term, NewTerm, Len, EvdAlg;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### called w
ith too many arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( na
rgs > 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`too \+
many arguments %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   #
## need to use specified algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 
"   elif( nargs = 2 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "    \+
  Alg := args[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   ### we can \+
use default alg." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := ALGEBRA;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "   ### checking for algebra to be
 univ. env. algebra, retrieving original algebra as well" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 30 "   if( type(Alg,unienv) ) then" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 41 "       EvdAlg := op(4,eval(unienv))[Alg];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 63 "       ERROR(`%1 is not a universal enveloping algebr
a.`, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   ### we
 have one term in the expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 
"   if( nops(G) = 1 or type(G, indexed) ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 68 "      ### it could be a constant or a generator, if s
o, that's fine\n" }{MPLTEXT 1 0 17 "      # JUL 2019\n" }{MPLTEXT 1 0 
58 "      # if( type(G,constant) or isgenerator(G,Alg) ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "      if( is(G,constant) or isgener
ator(G,Alg) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         Res
ult := G;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "      ### otherwise we
 have an error" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "         ERROR(`%1 is not a generat
or in %2.`, G, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      fi;  \+
      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "   ### we got a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "   elif( type(G,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
51 "      Result := map(proc(x,y) if(type(x,`*`)) then\n" }{MPLTEXT 1 
0 51 "                                 # Correction 2019\n" }{MPLTEXT 
1 0 68 "                                 # op(1,x)*mainasimplify(op(2,
x),y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "                         \+
        expand(PickConstants(x) * mainasimplify(PickTerm(x),y));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "                              else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "                                \+
 mainasimplify(x,y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "           \+
                   fi; end, G, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### we have a constant \+
multiplier" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   elif( type(G,`*`) \+
) then\n" }{MPLTEXT 1 0 24 "      # Correction 2019\n" }{MPLTEXT 1 0 
54 "      # Result := op(1,G)*mainasimplify(op(2,G), Alg);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 75 "      Result := expand(PickConstants(G) * m
ainasimplify(PickTerm(G), Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   ### just an associative mult
iplication term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 33 "      ### retrieve the `&@` terms" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      Elem := [extract(G,Alg,`KeepT
erms`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "      ### find a reversed ordered pair of generators \+
in the expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      using(Al
g);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "      for i to nops(Elem)-1 \+
do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "         if( Elem[i] &> Elem[
i+1] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "            break;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "     \+
 using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 31 "      if( i = nops(Elem) ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 22 "          Result := G;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    \+
     ### swap elements" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "         \+
Temp := Elem[i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "         Elem[i
] := Elem[i+1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "         Elem[i+
1] := Temp;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 38 "         ### prepare terms for the sum" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 25 "         if( i > 1 ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 47 "             Pre := convert(Elem[1..i-1],`&@`);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "             Pre := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "         if
( i+1 < nops(Elem) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "      \+
       Post := convert(Elem[i+2..nops(Elem)],`&@`);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "             Post := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "    \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "         ### create the resulting sum" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 92 "         Result := ((Pre&@lsimplify(Elem[i+1]&*
Elem[i],EvdAlg))&@Post) + convert(Elem,`&@`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "         ### ex
amine the results, further simplify if needed" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "         i := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "         while( true ) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "            if( type(Result,`+`) an
d i <= nops(Result) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "     \+
          Term := op(i,Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "
            elif(  not(type(Result,`+`)) and i <= 1 ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 30 "               Term := Result;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "               break;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "            if( type(Term,`*`) ) th
en\n" }{MPLTEXT 1 0 33 "               # Correction 2019\n" }{MPLTEXT 
1 0 36 "               # Cons := op(1,Term);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "               # Term := op(2,Term);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 43 "               Cons := PickConstants(Term);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "               Term := PickTerm(Ter
m);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 25 "               Cons := 1;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "            NewTerm := mai
nasimplify(Term, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 54 "            if( NewTerm = Term and NewTer
m <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "               i :
= i + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "               if( type(Result,`+`)
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "                  Result
 := eval(subsop(i=(Cons*NewTerm), Result));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "               else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 41 "                  Result := Cons*NewTerm;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   RETURN
(expand(Result));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 30 "LieAlg[repsimplify] := proc(G)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 131 "   descriptio
n `This is an interface to the function mainrepsimplify() which is the
 main representation simplification procedure.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "   local Temp, Rep;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### called with too man
y arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs > 2 ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`too many argume
nts %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### need to \+
use specified algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "   elif( n
args = 2 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Rep := ar
gs[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   ### we can use default
 alg." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   else " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 28 "      Rep := REPRESENTATION;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   if( type(Rep,`quotrep`) ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      Temp := traperror(mainquotr
epsimplify(G,Rep));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   elif( typ
e(Rep,`hwrep`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      Temp
 := traperror(mainrepsimplify(G,Rep));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "      ERROR(`%1 i
s not a representation and not a quotient representation.`, Rep);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   ### we had an error"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   if( Temp = lasterror ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "     ERROR(lasterror);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   #
## no error, apply characteristic p" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "     RETURN(applychar
(Temp));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "LieAlg_Hidden[mainrepsi
mplify] := proc(G,Rep)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option
 `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "   description `This is a simp
lification function for representations.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "   local Result, UAlg, ApplyRules;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   #--------
-------------> subs" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   ApplyRule
s := proc(Term, RuleFunc, Rep, Alg)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
73 "      option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Ma
zzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "      description `Remov
e terms with positive weight elements, keep rest.`;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 50 "      local R, j, Temp, TempNeg, TempZero, NZE, i;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 58 "      ### set flag to pick out zero elements from the term" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "      if( type(RuleFunc,list) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         R := RuleFunc;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "         NZE := 0;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 
"         R := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "         NZE \+
:= 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      ### g
et elements of the term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      Te
mp := [allop(Term)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 31 "      ### loop through elements" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "# Yul
y's CORRECTION in December" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "# Sep
arate negative weight terms in TempNeg, " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 37 "#   and zero weight terms in TempZero" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "# TempNeg := []
; TempZero := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 29 "#      for j to nops(Temp) do" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 69 "#         if( (wt(Temp[j],Alg) &!> [seq(0,i=wt(T
emp[j],Alg))]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "#         \+
   RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "#         elif( wt
(Temp[j],Alg) &!= [seq(0,i=wt(Temp[j],Alg))] ) then " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 47 "#            TempZero:=[op(TempZero), Temp[j]];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "#          else " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 45 "#            TempNeg:=[op(TempNeg), Temp[j]];" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "#         fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 10 "#      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "#  \+
    ### make substitutions and return" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 33 "#      if (nops(TempZero)=0) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 40 "#         RETURN(convert(TempNeg,`&^`));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "#        else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "#
         RETURN(convert(TempZero,`*`)*convert(TempNeg,`&^`));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "#      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "#   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      for j to nops(Temp) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "         if( (wt(Temp[j],Alg) &!> [
seq(0,i=wt(Temp[j],Alg))]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "            RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "     \+
    elif( NZE = 1 and wt(Temp[j],Alg) &!= [seq(0,i=wt(Temp[j],Alg))] )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "            R := [R[], Tem
p[j]=RuleFunc(Temp[j])];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "       \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 39 "      ### make substitutions and return" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "   \+
   RETURN(convert(convert(subs(R,[extract(Term,Alg)]),`&@`,Alg),`&^`,A
lg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 40 "#--------------------- end of CORRECTION" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 37 "   #--------------------- end of subs" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
53 "   Result := eval(subs(op(4,eval(hwrep))[Rep]=1, G));" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 47 "   UAlg := op(4,eval(hwrep))[Rep,`algebra`][
1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   if( type(Result,`+`) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "      Result := map((t,ua)->i
f(type(t,`*`)) then\n" }{MPLTEXT 1 0 79 "                             \+
  # Correction 2019                               " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 65 "                               #op(1,t) * asimplify
(op(2,t),ua);\n" }{MPLTEXT 1 0 84 "                               expa
nd(PickConstants(t) * asimplify(PickTerm(t),ua));" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 32 "                            else" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 47 "                               asimplify(t,ua);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                            fi, Res
ult, UAlg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   elif( type(Result
,`*`) ) then\n" }{MPLTEXT 1 0 28 "      # Correction 2019     " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "      # Result := op(1,Result) * as
implify(op(2,Result), UAlg);\n" }{MPLTEXT 1 0 82 "      Result := expa
nd(PickConstants(Result) * asimplify(PickTerm(Result), UAlg));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "      Result := asimplify(Result, UAlg);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "   ### applying rule on return: \+
drop terms with positive elements, keep rest" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "   if( type(Result,`+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "      Result := map(proc(x,y,z,w)\n" }{MPLTEXT 1 0 
40 "                      # Correction 2019 " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 82 "                      # if(type(x,`*`)) then op(1,x) \+
* ApplyRules(op(2,x),y,z,w);\n" }{MPLTEXT 1 0 92 "                    \+
  if(type(x,`*`)) then PickConstants(x) * ApplyRules(PickTerm(x),y,z,w
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "                      else Ap
plyRules(x,y,z,w);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "             \+
         fi; end, Result,op(4,eval(hwrep))[Rep,`replace`],Rep,UAlg);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   elif( type(Result,`*`) ) then
\n" }{MPLTEXT 1 0 24 "      # Correction 2019 " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 101 "      # Result := op(1,Result) * ApplyRules(op(2,Res
ult),op(4,eval(hwrep))[Rep,`replace`],Rep,UAlg);\n" }{MPLTEXT 1 0 112 
"      Result := PickConstants(Result) * ApplyRules(PickTerm(Result),o
p(4,eval(hwrep))[Rep,`replace`],Rep,UAlg);\n" }{MPLTEXT 1 0 21 "   # C
orrection 2019\n" }{MPLTEXT 1 0 39 "   elif( type(Result, constant) ) \+
then\n" }{MPLTEXT 1 0 27 "      if (Result = 1) then\n" }{MPLTEXT 1 0 
17 "         RETURN( " }{MPLTEXT 1 0 28 "op(4,eval(`hwrep`))[Rep] );\n
" }{MPLTEXT 1 0 11 "      else\n" }{MPLTEXT 1 0 9 "         " }
{MPLTEXT 1 0 43 "RETURN( Result*op(4,eval(`hwrep`))[Rep] );\n" }
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "      Result := ApplyRules(Resu
lt,op(4,eval(hwrep))[Rep,`replace`],Rep,UAlg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 49 "   ### return the result &@ highest weigh
t vector" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "   RETURN(&@(Result,op(4,eval(`hwrep`))[Rep],Rep));" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "LieAlg_
Hidden[mainquotrepsimplify] := proc(G, Rep)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "   d
escription `This is a simplification function for quotient representat
ions.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   local Result, ReduceT
erms, HWRep;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 41 "   #-----------------------------> subs()" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 37 "   ReduceTerms := proc(G, W, HWR, SM)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      local M, B, i, C, T, k;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "      ### get reduced matrix of submodule basis" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 54 "      M := op(4,eval(submodule))[SM,W,CHARACTERI
STIC];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 96 "      ### maybe submodule basis was not yet calculate
d for the given weight and we have to do it" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "      if( not(type(M,`listlist`)) ) then" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 31 "         submodulebasis(W, SM);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 57 "         M := op(4,eval(submodule))[SM,W,CHA
RACTERISTIC];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   \+
   if( G = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RET
URN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      elif( M = [] ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "         RETURN(G);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 47 "         ### calculate basis for representation" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 30 "         B := repbasis(W,HWR);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "         \+
C := array([seq(0,i=1..nops(B))]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
32 "         if( type(G,`+`) ) then\n" }{MPLTEXT 1 0 30 "            #
 Correction 2019\n" }{MPLTEXT 1 0 74 "            # T := map(t->if(typ
e(t,`*`)) then op(2,t) else t fi,[op(G)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 76 "            T := map(t->if(type(t,`*`)) then PickTerm
(t) else t fi,[op(G)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "        \+
    for i to nops(B) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "        \+
       if( member(B[i],T,'k') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "                  if( type(op(k,G),`*`) ) then\n" }{MPLTEXT 1 0 
39 "                     # Correction 2019\n" }{MPLTEXT 1 0 45 "      \+
               # C[i] := op(1,op(k,G));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 46 "                     C[i] := PickConstants(G);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 22 "                  else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "                     C[i] := 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "                  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "               else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "    \+
              C[i] := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "       \+
        fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "         elif( type(G,`*`) and memb
er(op(2,G),B,'k') ) then\n" }{MPLTEXT 1 0 30 "            # Correction
 2019\n" }{MPLTEXT 1 0 30 "            # C[k] := op(1,G);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 37 "            C[k] := PickConstants(G);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "         elif( member(G,B,'k') ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "            C[k] := 1;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "            ERROR(`%1 is not in basis %2.`, G, B);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "#print(evaln(C)
=eval(C),M);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 177 "         C := convert(LinearAlgebra[VectorMatrixM
ultiply](Vector[row](map(proc(l,cl) local k; if(member(1,l,'k')) then \+
cl[k]; fi; end,M,C)),Matrix(M)),`list`)-convert(C,`list`);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "#prin
t(G);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "#print(evaln(C)=eval(C));"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "#print(evaln(B)=B);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 19 "#print(evaln(M)=M);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "          RETUR
N(add(C[i]*B[i],i=1..nops(C)));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 " \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 37 "   #--------------------- end of subs" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   H
WRep := op(4,eval(quotrep))[Rep][1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 25 "   if( type(G,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "
      Result := map((t,r)->if(type(t,`*`)) then\n" }{MPLTEXT 1 0 48 " \+
                             # Correction 2019\n" }{MPLTEXT 1 0 69 "  \+
                            # op(1,t) * mainrepsimplify(op(2,t),r);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "                              expa
nd(PickConstants(t) * mainrepsimplify(PickTerm(t),r));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 31 "                           else" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 51 "                              mainrepsimplify(t
,r);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "                           \+
fi, G, HWRep);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   elif( type(G,`
*`) ) then\n" }{MPLTEXT 1 0 24 "      # Correction 2019\n" }{MPLTEXT 
1 0 60 "      # Result := op(1,G) * mainrepsimplify(op(2,G), HWRep);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      Result := expand(PickConsta
nts(G) * mainrepsimplify(PickTerm(G), HWRep));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      Re
sult := mainrepsimplify(G, HWRep);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 156 "   RETURN(ReduceTerms
(Result, wt(eval(subs(op(4,eval(hwrep))[HWRep]=1,Result)),op(4,eval(hw
rep))[HWRep,`algebra`][2]), HWRep, op(4,eval(quotrep))[Rep][2]));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "LieAlg[
dotproduct] := proc(el::algebraic,er::algebraic)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "   d
escription `Computes the dotproduct (scalar product) for ADE simple ag
ebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   local l, r, LI, RI, \+
Alg, M, Lacing, Type, UE, UM, e, Size;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   ### input check" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   if( nargs > 3 ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "   elif( nargs > 2 and type(ar
gs[3],`simple`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg
 := args[3];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   elif( type(ALGEB
RA,`simple`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg :=
 ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 26 "      if( nargs = 3 ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 24 "         Alg := args[3];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "    \+
     Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "      ERROR(`dotproduct is defined
 for simple algebras, %1 is not a simple algebra.`, Alg);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   ### expand the sums" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 76 "   e := eval(generalexpand(lsimplify(el, \+
Alg),lsimplify(er, Alg),`&*`,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   ### zero" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 19 "   if( e = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "       RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   ### handle the expression
, sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   elif( type(e,`+`) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "       RETURN(map(proc(x,y) if
(type(x,`*`)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "             \+
                 op(1,x) * dotproduct(op(1,op(2,x)),op(2,op(2,x)),y);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "                            else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "                              d
otproduct(op(1,x),op(2,x),y); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 " \+
                           fi; end, e, Alg));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "   ### ...product" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "   elif( type(e,`*`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "
       RETURN(op(1,e) * dotproduct(op(1,op(2,e)),op(2,op(2,e)),Alg));"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "   ### catching some errors" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
43 "   elif( nops([extract(e,Alg)]) <> 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "       ERROR(`%1 contains invalid terms in dotproduct
.`, e);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "   ### expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "       ### setting up
 our variables" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "       (l,r) := e
xtract(e,Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "       LI := [op(
l)]; RI := [op(r)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "       M := \+
op(4,eval(simple))[Alg];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "       \+
(Lacing,Type) := op(4,eval(simple))[Alg,`type`];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "       Size := LinearAlgebra[RowDimension](M);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
34 "       ### we got mixed indices in" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 58 "       if( type(LI,`mixedwt`) or type(RI,`mixedwt`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "          RETURN(0);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "       #
## h[i]'s on both sides" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "       e
lif( op(0,GENERATORS[2]) = op(0,l) and op(0,GENERATORS[2]) = op(0,r) )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "          if( LI[] < 1 or \+
LI[] > Size or RI[] < 1 or RI[] > Size ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "             RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 44 "          elif( Lacing = `ADE_matrix` ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 34 "             RETURN(M[LI[],RI[]]);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 27 "             ### unfold h's" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
44 "             UE := unfoldh_||Lacing(e,Size);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "       ### on LHS or RHS we have \+
h[i]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "       elif( op(0,GENERATOR
S[2]) = op(0,l) or op(0,GENERATORS[2]) = op(0,r) ) then" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 20 "          RETURN(0);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "       ### we h
ave e[k1,..,kn] on both sides" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "  \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "         if( Lacing = \+
`ADE_matrix` ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "            \+
if( LI <> -RI ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "           \+
    RETURN(0);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "               RETURN((-1)^epsil
on_||Type(LI,RI,M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "           \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 31 "            ### unfold equation" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 42 "            UE := unfold_||Lacing(e, Alg);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "      ### we should only come this \+
far if we had h's or e's to unfold" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
91 "      ### in this case we compute dotproduct in unfolded algebra f
or the expression (in UE)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "      ### produce name of unfolded \+
algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      Alg := cat(Alg,`_u
nfolded`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 62 "      ### unfolded equation is a constant, return imm
ediately\n" }{MPLTEXT 1 0 17 "      # JUL 2019\n" }{MPLTEXT 1 0 36 "  \+
    # if( type(UE,constant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
32 "      if( is(UE,constant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 20 "         RETURN(UE);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "      ### we have a sum" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 31 "      elif( type(UE,`+`) ) then" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 50 "         RETURN(map(proc(x,y) if(type(x,`*`
)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "                        \+
          op(1,x) * dotproduct(op(1,op(2,x)),op(2,op(2,x)),y);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "                               else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "                               \+
   dotproduct(op(1,x),op(2,x),y);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
50 "                               fi; end, UE, Alg));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "      ###
 we have a product, get constant" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 
"      elif( type(UE,`*`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 
"          RETURN(op(1,UE) * dotproduct(op(1,op(2,UE)),op(2,op(2,UE)),
 Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "      ### just an expression" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "    \+
      RETURN(dotproduct(op(1,UE),op(2,UE), Alg));" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 1 " " }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "LieA
lg_Hidden[applychar] := proc( Expr::algebraic )" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and
 Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "   description
 `applies characteristic p if there was one defined`;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 25 "   global CHARACTERISTIC;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### we have \+
characteristic p defined" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   if( \+
CHARACTERISTIC <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "     \+
 ### if we have a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      if( \+
type(Expr,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "         R
ETURN(map((x,y)->if(type(x,`*`)) then\n" }{MPLTEXT 1 0 48 "           \+
                   # Correction 2019\n" }{MPLTEXT 1 0 66 "            \+
                  # (Normal(op(1,x)) mod y) * op(2,x);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 77 "                              (Normal(PickConst
ants(x)) mod y) * PickTerm(x);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 " \+
                          else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 " \+
                             (Normal(1) mod y) * x; " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 54 "                           fi, Expr, CHARACTERIST
IC));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "      ### if we have a multiplication" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 34 "      elif( type(Expr,`*`) ) then\n" }{MPLTEXT 
1 0 27 "         # Correction 2019\n" }{MPLTEXT 1 0 72 "         # RET
URN((Normal(op(1,Expr)) mod CHARACTERISTIC) * op(2,Expr));" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 83 "         RETURN((Normal(PickConstants(Expr)
) mod CHARACTERISTIC) * PickTerm(Expr));" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "      ### simple expres
sion" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 55 "         RETURN((Normal(1) mod CHARACTERISTIC) *
 Expr);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 6 "  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   \+
   RETURN( Expr );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "  fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 54 "######################>  simplification procedures end" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "######################>  miscalleno
us procedures follow" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "LieAlg[wt] \+
:= proc(Expr::algebraic)  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   op
tion `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "   description `wt(expression) calc
ulates the weight of a given expression using values defined " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "               for the generators i
n generators(); ----> doesn't work for directsums yet <----`; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 22 "   global GENERATORS; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "   local FindWeight, Alg; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "   ### give it memory to improve efficiency" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 29 "   # option system, remember;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "   #-------------------------------
> definition of subprocedures <-------------------------" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 61 "   ### FindWeight() finds the actual weight o
f the expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   FindWeight :
= proc(Expr, Weights, Alg)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "     \+
 option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      ### declarations" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 40 "      local i, j, List, Result, GenList;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      ### give it memory to impro
ve efficiency" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      # option sys
tem, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 45 "      ### we have a sum for expression (Expr)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "      ### get weights for both side
s" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "      if( type(Expr,`+`) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "         ### getting weights o
f both sides (note that sums of multiple " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "         ### terms are dealt with in a recursive fash
ion)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "         Result := map((e,w
,a)->if(type(e,`*`)) then\n" }{MPLTEXT 1 0 54 "                       \+
             # Correction 2019\n" }{MPLTEXT 1 0 62 "                  \+
                  # FindWeight(op(2,e),w,a);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 64 "                                    FindWeight(PickTe
rm(e),w,a);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "                    \+
            else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "               \+
                     FindWeight(e,w,a);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 62 "                                fi, [op(Expr)], Weights, Alg);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 49 "         ### and then try to find a different one" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 40 "         for i from 2 to nops(Result) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "            if( Result[1] <> Result
[i] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "               RETURN
([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 12 "         od;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 27 "         RETURN(Result[1]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 8 "        " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "      ### we have \+
regular expressions, no sums" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   \+
   else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "         ### initializi
ng the result list to zero" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "     \+
    Result := [seq(0, i = Weights[1])];" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "         ### getting gen
erators that make up the expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
35 "         if( type(Expr,`*`) ) then\n" }{MPLTEXT 1 0 30 "          \+
  # Correction 2019\n" }{MPLTEXT 1 0 49 "            # List := [extrac
t(op(2,Expr), Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "           \+
 List := [extract(PickTerm(Expr), Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "         \+
   List := [extract(Expr, Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 
"         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 27 "         ### get generators" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "         GenList := grab(Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "         ### lo
oping through the generators for given algebra" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "         for i to nops(GenList) do" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "            \+
### looping through the generators (in the expression)" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 35 "            for j to nops(List) do " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "     \+
          ### we have a match, add its weight to the result" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 47 "               if( List[j] = GenList[i] ) \+
then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "                  ### we h
ave parametric weights (unapply makes a function of the weight list" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "                  ### then we plug
 in the parameters to get the actual weight)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 55 "                  if( hastype(Weights[i], name) ) the
n " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "                     Result :
= Result + unapply(Weights[i],op(GenList[i]))(op(List[j]));" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 87 "                  ### we have non-parametr
ic weights, we just add it                   " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "                  else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 51 "                     Result := Result + Weights[i];" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 21 "                  fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "              \+
 ### we have indexed generators, we have to do checking different" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "               elif( type(List[j], \+
indexed) and type(GenList[i], indexed) ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "                  ### checking for equals" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 56 "                  if( (op(0,List[j]) = op(0
,GenList[i]))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 87 "                  \+
                  and not(hastype([op(GenList[i])],constant)) ) then "
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 96 "                     ### we have parametric weights (unapply mak
es a function of the weight list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 
"                     ### then we plug in the parameters to get the ac
tual weight)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "                   \+
  if( hastype(Weights[i], name) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 91 "                        Result := Result + unapply(Weights[i],
op(GenList[i]))(op(List[j]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "                     ### we have n
on-parametric weights, we just add it                   " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 25 "                     else" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 54 "                        Result := Result + Weights[
i];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "                     fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "                  fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "            od;  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "         od; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "         ### r
eturning the weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "         RET
URN(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
94 "   #------------------------------------- end of subs ------------
----------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
94 "   #---------------------------------> main proc()'s body <-------
----------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   ### procedure is called with too
 many arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   if( nargs > 2
) then ERROR(`too many arguments %1.`, args ); fi;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "   ### if \+
we received an additional argument, it has to be the name of the" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   ### algebra to use, but we still
 save the default algebra into Gens" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "   if( nargs = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "    \+
  Alg := args[2]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := ALGEBRA;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "   ### getting weights from the t
able of generators() " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   ### cal
ling suproc to do the calculations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "   ### returning our answer" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "
   RETURN(FindWeight(Expr, op(4,eval(algebra))[(Alg,`weight`)], Alg));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "LieAl
g_Hidden[comparewts] := proc(W1::list, OP::symbol, W2::list)" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yul
y Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "  \+
 description `checks for W1 to be less than or equal to W2 in lexicogr
aphic order`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   ### decalaratio
ns" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "   local i;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 21 "   ### give it memory" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "   # option system, remember;  " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   ### when wro
ng set of lists passed in" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   if(
 nops(W1) <> nops(W2) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "   \+
   ERROR(`the weights %1 and %2 are of non-equal length, can't compare
.`, W1, W2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 66 "   ### we could be asked to do find a relation we'r
e not ready for" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   elif( not(mem
ber(OP,\{`=`,`<`,`>`,`<=`,`>=`\})) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 50 "      ERROR(`operation %1 is not supported.`, OP);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ### let's co
mpare piece by piece" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   for i to
 nops(W1) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      ### checking \+
the relations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "      if( not(type
(W1[i],integer) and type(W2[i],integer)) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "         RETURN(false);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 83 "      elif( (OP = `<` and (W1[i] > W2[i])) or (OP = `>` and (
W1[i] < W2[i])) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         \+
RETURN(false);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      elif( (OP =
 `<` and W1[i] < W2[i]) or (OP = `>` and W1[i] > W2[i]) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "         RETURN(true);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
6 "   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   RETURN(false);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "end:    " }}}{EXCHG {PARA 0 "> " 0 "
" {MPLTEXT 1 0 68 "LieAlg_Hidden[revcomparewts] := proc(W1::list, OP::
symbol, W2::list)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Cop
yright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 93 "   description `checks for W1 to be less than
 or equal to W2 in REVERSE lexicographic order`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "   ### decalarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 11 "   local i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### give it
 memory" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   # option system, reme
mber;  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "   ### when wrong set of lists passed in" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 34 "   if( nops(W1) <> nops(W2) ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 85 "      ERROR(`the weights %1 and %2 are of
 non-equal length, can't compare.`, W1, W2);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "   ### we could
 be asked to do find a relation we're not ready for" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 55 "   elif( not(member(OP,\{`=`,`<`,`>`,`<=`,`>=`\}))
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      ERROR(`operation %
1 is not supported.`, OP);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 35 "   ### let's compare piece by piece" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "   for i from nops(W1) to 1 by -1 do" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 32 "      ### checking the relations" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 65 "      if( not(type(W1[i],integer) and type(W2[i
],integer)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         RETU
RN(false);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "      elif( (OP = `<`
 and (W1[i] > W2[i])) or (OP = `>` and (W1[i] < W2[i])) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         RETURN(false);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 79 "      elif( (OP = `<` and W1[i] < W2[i]) or
 (OP = `>` and W1[i] > W2[i]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 22 "         RETURN(true);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 17 "   RETURN(false);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 44 "LieAlg[basis] := proc(Weight::list(integer))" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 \+
by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
83 "   description `General Lie algebra or representation basis calcul
ating function.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "   local Alg, \+
Temp, Temp2, i, n, bvec, indx, rts, nullweight, quant, qmax, lev, mask
, Fbasis;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 23 "   if( nargs > 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif( nargs = 2 ) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := args[2];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      \+
Alg := ALGEBRA;\n" }{MPLTEXT 1 0 24 "      # Correction 2019\n" }
{MPLTEXT 1 0 31 "      if type(Alg,unienv) then\n" }{MPLTEXT 1 0 41 " \+
        Alg := op(4,eval(unienv))[Alg];\n" }{MPLTEXT 1 0 9 "      fi;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### checking
 length of weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   if( type(Al
g,`algebra`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      if( no
ps(wt(grab(Alg)[1],Alg)) <> nops(Weight) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "         ERROR(`weight %1 is of invalid length for al
gebra %2.`, Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      f
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 33 "   elif( type(Alg,`ideal`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 47 "      Temp := op(4,eval(ideal))[Alg,`algebra`];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      if( nops(wt(grab(Temp)[1],Tem
p)) <> nops(Weight) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "     \+
    ERROR(`weight %1 is of invalid length for ideal %2.`, Weight, Alg)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   elif( type(A
lg,`quotrep`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "      Temp \+
:= op(4,eval(hwrep))[op(4,eval(quotrep))[Alg][1],`algebra`][2];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      if( nops(wt(grab(Temp)[1],Tem
p)) <> nops(Weight) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 94 "     \+
    ERROR(`weight %1 is of invalid length for quotient representation \+
%2.`, Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   elif( type(Alg,`hwrep`) ) then  \+
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      Temp := op(4,eval(hwrep)
)[Alg,`algebra`][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      if( n
ops(wt(grab(Temp)[1],Temp)) <> nops(Weight) ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 85 "         ERROR(`weight %1 is of invalid length for \+
representation %2.`, Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
9 "      fi;" }{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "
   elif( type(Alg,`submodule`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 83 "      Temp := op(4,eval(hwrep))[op(4,eval(submodule))[Alg,`algeb
ra`],`algebra`][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      if( no
ps(wt(grab(Temp)[1],Temp)) <> nops(Weight) ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 80 "         ERROR(`weight %1 is of invalid length for s
ubmodule %2.`, Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "    \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   ### algebra
 is directsum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   if( type(Alg,`d
irectsum`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "      Alg := o
p(4,eval(directsum))[Alg];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 82 "     \+
 Temp := [nops(wt(grab(Alg[1])[1],Alg[1])),nops(wt(grab(Alg[2])[1],Alg
[2]))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "      if( Weight[nops(We
ight)] <> 0 and Temp[1] <> Temp[2] ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "         if( Temp[1] > Temp[2] ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 41 "            RETURN(basis(Weight,Alg[1]));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "            RETURN(basis(Weight,Alg[2]));" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "         RETU
RN([basis(Weight[1..Temp[1]],Alg[1])[],basis(Weight[1..Temp[2]],Alg[2]
)[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### for
 quotalgebra call quotbasis" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   e
lif( type(Alg,`quotalg`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "
      RETURN(quotbasis(Weight,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### algebra is triangul
ar" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   elif( type(Alg,`triangular
`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      Temp := [seq(0,i
=Weight)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      if( Weight &!< \+
Temp ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "         RETURN(basi
s(Weight,op(4,eval(triangular))[Alg][1]));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "      elif( Weight &!= Temp ) then" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 62 "         RETURN(basis(Weight,op(4,eval(triangular)
)[Alg][2]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "         RETURN(basis(Weight,op(4,e
val(triangular))[Alg][3]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "     \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "   ### algebra is affine" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "   elif( type(Alg,`affine`) ) then\n" }{MPLTEXT 1 0 
24 "      # Correction 2019\n" }{MPLTEXT 1 0 75 "      # we need to di
stinguish cases of standard and non-standard gradings\n" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 6 "      " }{MPLTEXT 1 0 5 "n := " }{MPLTEXT 1 
0 47 "LinearAlgebra[RowDimension](op(4,eval(simple))[" }{MPLTEXT 1 0 
18 "cat(Alg,`_simple`)" }{MPLTEXT 1 0 34 "]);  #size of finite Cartan \+
matrix" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 6 "      " }{MPLTEXT 1 0 3 
"if " }{MPLTEXT 1 0 79 "evalb(op(1,op(4, eval(algebra))[(Alg,weight)])
=[seq(`r`||i, i=1..n),`k`]) then\n" }{MPLTEXT 1 0 28 "          # stan
dard grading" }{MPLTEXT 1 0 1 "\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
76 "         Temp := basis([Weight[1..nops(Weight)-1][],0],cat(Alg,`_s
imple`));\n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "         if( Temp = \+
[] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "            RETURN(Tem
p);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "         elif( op(0,Temp[1])
 = op(0,grab(cat(Alg,`_simple`))[1]) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 46 "            RETURN([op(0,Temp[1])[Weight[]]]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "         elif( Weight[nops(Weight)]
 = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "            RETURN([
map((e,k)->op(0,e)[op(e),k],Temp,Weight[nops(Weight)])[], grab(Alg)[3]
]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 76 "            RETURN(map((e,k)->op(0,e)[op(e),k]
,Temp,Weight[nops(Weight)])); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 " \+
        fi;\n" }{MPLTEXT 1 0 10 "         \n" }{MPLTEXT 1 0 12 "      \+
 else\n" }{MPLTEXT 1 0 32 "          #non-standard grading\n" }
{MPLTEXT 1 0 41 "          #look-up the weight of h_\{*,1\}\n" }
{MPLTEXT 1 0 24 "          nullweight := " }{MPLTEXT 1 0 49 "subs(k=1,
 op(4, eval(algebra))[(Alg,weight)][2]);" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 15 "          if ( " }{MPLTEXT 1 0 46 "nullweight &!= [se
q(0, i=1..nops(nullweight))]" }{MPLTEXT 1 0 8 " ) then\n" }{MPLTEXT 1 
0 100 "             ERROR(`Basis of affine algebra can not be determin
ed since nullroot has zero weight`);\n" }{MPLTEXT 1 0 15 "          el
se\n" }{MPLTEXT 1 0 55 "             # find a non-zero component of nu
llweight\n" }{MPLTEXT 1 0 24 "             mask := 1;\n" }{MPLTEXT 1 
0 49 "             while (mask <= nops(nullweight)) do\n" }{MPLTEXT 1 
0 43 "                quant := nullweight[mask];\n" }{MPLTEXT 1 0 37 "
                if (quant <> 0) then\n" }{MPLTEXT 1 0 26 "            \+
       break;\n" }{MPLTEXT 1 0 21 "                else\n" }{MPLTEXT 
1 0 37 "                   mask := mask + 1;\n" }{MPLTEXT 1 0 20 "    \+
            fi;\n" }{MPLTEXT 1 0 18 "             end;\n" }{MPLTEXT 1 
0 1 "\n" }{MPLTEXT 1 0 84 "             # find the maximum of mask-com
ponent of weights for the simple algebra\n" }{MPLTEXT 1 0 77 "        \+
     # extract the code name of the simple algebra and get its roots\n
" }{MPLTEXT 1 0 18 "             if ( " }{MPLTEXT 1 0 44 "substring(co
nvert(op(1,[op(4,eval(simple))[(" }{MPLTEXT 1 0 18 "cat(Alg,`_simple`)
" }{MPLTEXT 1 0 35 ",type)]]),string),1..1) = \"A\") then" }{MPLTEXT 
1 0 1 "\n" }{MPLTEXT 1 0 16 "                " }{MPLTEXT 1 0 65 "rts :
= roots(convert(substring(convert(op(2,[op(4,eval(simple))[(" }
{MPLTEXT 1 0 18 "cat(Alg,`_simple`)" }{MPLTEXT 1 0 34 ",type)]]),strin
g),6..6),name)[n]);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 18 "          \+
   else\n" }{MPLTEXT 1 0 16 "                " }{MPLTEXT 1 0 117 "rts \+
:= roots(convert(substring(convert(op(1,[op(4,eval(simple))[(cat(Alg,`
_simple`),type)]]),string),1..1),name)[n]);" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 16 "             fi;" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 
1 "\n" }{MPLTEXT 1 0 21 "             qmax := " }{MPLTEXT 1 0 51 "max(
map(x -> abs(x[mask]), map( t -> wt( op(0,grab(" }{MPLTEXT 1 0 18 "cat
(Alg,`_simple`)" }{MPLTEXT 1 0 12 ")[1])[t[]], " }{MPLTEXT 1 0 18 "cat
(Alg,`_simple`)" }{MPLTEXT 1 0 11 " ), rts)));" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 25 "             Temp := [];\n" }
{MPLTEXT 1 0 40 "             # start building the basis\n" }{MPLTEXT 
1 0 1 "\n" }{MPLTEXT 1 0 82 "             for lev from ceil( (Weight[m
ask] - sign(quant)*qmax)/quant) to floor(" }{MPLTEXT 1 0 45 " (Weight[
mask] + sign(quant)*qmax)/quant) do\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 
1 0 70 "                # Find basis of the difference for simple Lie \+
algebra\n" }{MPLTEXT 1 0 58 "                Fbasis := basis( Weight -
 lev*nullweight, " }{MPLTEXT 1 0 21 "cat(Alg,`_simple`));\n" }{MPLTEXT
 1 0 18 "                 \n" }{MPLTEXT 1 0 72 "                # add \+
extra dimension to basis elements and add to Temp\n" }{MPLTEXT 1 0 97 
"                Temp := [Temp[], seq( op(0, Fbasis[i])[op(Fbasis[i]),
 lev], i=1..nops(Fbasis) )];" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 18 " \+
            end;\n" }{MPLTEXT 1 0 27 "             RETURN(Temp);\n" }
{MPLTEXT 1 0 15 "          fi; \n" }{MPLTEXT 1 0 2 " \n" }{MPLTEXT 1 
0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 24 "   ### algebra is simple" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "   elif( type(Alg,`simple`) ) then\n" }{MPLTEXT 1 0 
24 "      # Correction 2019\n" }{MPLTEXT 1 0 75 "      # we need to di
stinguish cases of standard and non-standard gradings\n" }{MPLTEXT 1 
0 7 "      \n" }{MPLTEXT 1 0 73 "      # determine the code name of th
e simple algebra and find its roots\n" }{MPLTEXT 1 0 11 "      n := " 
}{MPLTEXT 1 0 55 "LinearAlgebra[RowDimension](op(4,eval(simple))[Alg])
;  " }{MPLTEXT 1 0 22 "#size of Cartan matrix" }{MPLTEXT 1 0 1 "\n" }
{MPLTEXT 1 0 11 "      if ( " }{MPLTEXT 1 0 82 "substring(convert(op(1
,[op(4,eval(simple))[(Alg,type)]]),string),1..1) = \"A\") then" }
{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 9 "         " }{MPLTEXT 1 0 102 "rts
 := roots(convert(substring(convert(op(2,[op(4,eval(simple))[(Alg,type
)]]),string),6..6),name)[n]);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 11 "
      else\n" }{MPLTEXT 1 0 9 "         " }{MPLTEXT 1 0 102 "rts := ro
ots(convert(substring(convert(op(1,[op(4,eval(simple))[(Alg,type)]]),s
tring),1..1),name)[n]);" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 10 "      \+
fi;\n" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 9 "      if " }{MPLTEXT 1 0 
75 "evalb(op(1,op(4, eval(algebra))[(Alg,weight)])=[seq(`k`||i, i=1..n
)]) then\n" }{MPLTEXT 1 0 28 "          # standard grading" }{MPLTEXT 
1 0 1 "\n" }{MPLTEXT 1 0 33 "          # if weight is non-zero" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "          if( Weight &!= [seq(0,i=W
eight)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "             RETU
RN([seq(op(0,grab(Alg)[2])[i], i=1..n)]); " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "
             Temp := op(0,grab(Alg)[1])[Weight[]];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 64 "             if( member(Weight,rts) or member(-Weig
ht,rts)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "                RE
TURN([Temp]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "             else"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "                RETURN([]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "             fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "        else\n" }{MPLTEXT 1 0 34 "           # non-standard gradin
g\n" }{MPLTEXT 1 0 19 "           if evalb" }{MPLTEXT 1 0 35 "( Weight
 = [seq(0,i=Weight)] ) then" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 0 23 "  \+
            Temp := [" }{MPLTEXT 1 0 78 "seq(op(0,grab(Alg)[2])[i], i=
1..n)];  # zero weight, include all h-generators\n" }{MPLTEXT 1 0 16 "
           else\n" }{MPLTEXT 1 0 26 "              Temp := [];\n" }
{MPLTEXT 1 0 15 "           fi;\n" }{MPLTEXT 1 0 67 "           # now \+
find all non-zero root vectors with a given weight" }{MPLTEXT 1 0 1 "
\n" }{MPLTEXT 1 0 40 "           for i from 1 to nops(rts) do\n" }
{MPLTEXT 1 0 30 "              indx := rts[i];\n" }{MPLTEXT 1 0 22 "  \+
            bvec := " }{MPLTEXT 1 0 28 "op(0,grab(Alg)[1])[indx[]];\n"
 }{MPLTEXT 1 0 52 "              if evalb(Weight = wt(bvec, Alg)) then
\n" }{MPLTEXT 1 0 41 "                 Temp := [Temp[], bvec];\n" }
{MPLTEXT 1 0 17 "              fi;" }{MPLTEXT 1 0 1 "\n" }{MPLTEXT 1 
0 14 "              " }{MPLTEXT 1 0 8 "bvec := " }{MPLTEXT 1 0 29 "op(
0,grab(Alg)[1])[-indx[]];\n" }{MPLTEXT 1 0 52 "              if evalb(
Weight = wt(bvec, Alg)) then\n" }{MPLTEXT 1 0 41 "                 Tem
p := [Temp[], bvec];\n" }{MPLTEXT 1 0 17 "              fi;" }{MPLTEXT
 1 0 1 "\n" }{MPLTEXT 1 0 16 "            od;\n" }{MPLTEXT 1 0 26 "   \+
         RETURN(Temp);\n" }{MPLTEXT 1 0 10 "      fi;\n" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 41 "   ### rules defined for free Lie algebra" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   elif( type(Alg,`withrules`) ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "      Temp := op(4,eval(algeb
ra))[Alg,`weight`];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "      if(mem
ber(`true`,map(x->hastype(x,`name`),Temp))) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "         Temp2 := grab(Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "         Temp := map((gw,rw)->if(type(gw[1],`indexed`
)) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                        \+
        map((i,w,rw)->" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "         \+
                         if(member(i,w,'Flag')) then rw[Flag]" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "                                  e
lse false" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "                      \+
            fi," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "                \+
                [op(gw[1])],gw[2],rw);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 34 "                              else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 38 "                                gw[1];" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 33 "                              fi," }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 68 "                 [seq([Temp2[i],Temp[i]],i=1
..nops(Temp))], Weight);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "         if( member(`false`,map(op,
Temp)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "            ERROR(
`basis for algebra %1 cannot be determined.`, Alg);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
33 "            RETURN(map((gi,a,w)->" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 83 "                     if(type(gi[1],indexed) and wt(op(0,gi[1])[g
i[2][]],a)=w) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "            \+
            op(0,gi[1])[gi[2][]]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 
"                     fi," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "      \+
            [seq([Temp2[i],Temp[i]],i=1..nops(Temp2))], Alg, Weight));
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 " \+
        RETURN(genhallmon(Weight,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 15 "   ### free Lie" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 35 "   elif( type(Alg,`algebra`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "      RETURN(genhallmon(Weight,Alg));" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "   ### id
eal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   elif( type(Alg,`ideal`) )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      RETURN(idealbasis(We
ight,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 16 "   ### submodule" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
37 "   elif( type(Alg,`submodule`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "      RETURN(submodulebasis(Weight,Alg));" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   ##
# quotient representation" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   eli
f( type(Alg,`quotrep`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "  \+
    RETURN(quotrepbasis(Weight,Alg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   ### use representation"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   elif( type(Alg,`hwrep`) ) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "      RETURN(repbasis(Weight,A
lg));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "   ### default" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 " \+
  else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "      ERROR(`%1 is not a \+
supported type of algebra to find a basis for.`, Alg);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> "
 0 "" {MPLTEXT 1 0 56 "LieAlg_Hidden[genhallmon] := proc(Weight::list(
integer))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copyright (
C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 42 "   description `Wrapper to dogenhallmon.`;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 43 "   local Add, Result, dogenhallmon, Alg, i;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 69 "   #----------------------------> subs <------------------------
-----" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "   dogenhallmon := proc(We
ight, Add, Alg)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "      descriptio
n `Generates Hall Monomials of the specified degree.`;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 22 "      ### declarations" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "      global ALGEBRA, GENERATORS;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 25 "      local Set, i, A, B;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "      ### give it memory" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 91 "      option `Copyright (C) 1999-2019 by Yuly Billig \+
and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      ### will hold gene
rated weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      B := [seq(0,
i=Weight)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 27 "      ### holds the results" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "      Set := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      ### we loop" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 29 "      while( B <> Weight ) do" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       \+
 ### creating B" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "        for i to
 nops(B) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "           ### curre
nt element of B is to be zeroed" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "
           if( B[i] = Weight[i] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 24 "              B[i] := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 
"           ### increment curr. element of B" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "           else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 
"              if( Add ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "  \+
               B[i] := B[i] + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 
"              else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "            \+
     B[i] := B[i] - 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "         \+
     fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "              break;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "           fi;" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 11 "        od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "        ### in this case we gener
ate subexpressions of lower weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
31 "        if( B <> Weight ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
57 "           ### loop through the returned sets, add to Set" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "           Set := [Set[],map((u,vl,
a)->" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "                     map((v
,u,a)->" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "                        \+
if((u &< v) and (isgenerator(v,a) or (type(v,`&*`) and u &>= op(1,v)))
) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "                           th
en evaln(u&*v);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "                \+
        fi," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "                    \+
 vl,u,a)[]," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "                  do
genhallmon(Weight-B,Add,Alg),dogenhallmon(B,Add,Alg),ALGEBRA)[]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "     od; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "     ### we might have to return a \+
generator (the base case)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "     #
## we can have more than one generator with the same weight" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "    \+
 ### return the results" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "     RET
URN([Set[],map((g,a,w)->if(wt(g,a) = w) then g; fi,GENERATORS,ALGEBRA,
Weight)[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 65 "   #------------------------- end of subs --
---------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 27 "   ### standard error check" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 24 "   if( nargs > 2 ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "   ### we have to using sg. other t
han the default algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif(
 nargs = 2 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := a
rgs[2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### we can use the de
fault algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 21 "      Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 71 "   ### checking whether we have to add or
 subtract from B to get Weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 " \+
  if( type(Weight,`mixedwt`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
17 "      RETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "   elif( W
eight &!>= [seq(0,i=Weight)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
18 "      Add := true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "      Add := false;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   ### set algebra, calculate, res
et algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "   using(Alg);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   Result := dogenhallmon(Weight, A
dd, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   using(`reset`);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
18 "   RETURN(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 55 "LieAlg_Hidden[quotbasis] := proc(Weight::list(intege
r))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "   description `Calculates t
he basis of a quotient algebras.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 95 "   local
 i, j, Table, Entries, Ideal, Alg, StableSet, Basis, DeleteIt, maximiz
e, Temp, FactAlg;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### give it
 memory" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   option `Copyright (C)
 1999-2019 by Yuly Billig and Matyas Mazzag.`, remember;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "   #----------------------> definit
ion of subprocedures <-------------------" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 57 "   ### creates a maximized version of two sets of wei
ghts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "   ### ie for input ([1,3,5
],[2,5,3]) the output is: [2,5,5]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
25 "   maximize := proc(A, B)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "  \+
    option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "      local i, Result;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 6 "      " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "
      if( nops(A) = nops(B) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
22 "         Result := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "     \+
    for i to nops(A) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        \+
    if( A[i] > B[i] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "     \+
          Result := [Result[],A[i]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 16 "            else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         \+
      Result := [Result[],B[i]]; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "            fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "      else   " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 67 "         ERROR(`weights %1 and %2 are of differen
t length.`, A, B);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      RETURN(Result);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "
   #-------------------------------end of subs------------------------
---" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 73 "   #-------------------------> main proc()'s  body <-
--------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 3 "   " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### standard check" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 23 "   if( nargs > 2 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 44 "      ERROR(`too many arguments %1.`, args);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   elif( type(Weight,`mixedwt`) ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      RETURN([]);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 25 "   elif( nargs = 2 ) then" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 25 "      FactAlg := args[2];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      Fa
ctAlg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
54 "   ### retrieving the quotient algebra from the table " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 54 "   ### given that we have at least one fact
alg defined" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   if( type(FactAlg,
`quotalg`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "      Table :=
 op(4, eval(quotalg)); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "      En
tries := [indices(Table)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "     \+
 Alg := Table[FactAlg][1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "     \+
 Ideal := Table[FactAlg][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   e
lse" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "      ERROR(`quotient algebr
a %1 isn't defined.`, FactAlg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 " \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "   ### find the stable set (generate it if we have to
)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "   if( member([(FactAlg,`stabl
eset`)], Entries, 'k') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "      ### if our stable set is com
puted for weight high enough, we're OK" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 83 "      if( (Weight &!<= [Table[Entries[k][]]][1] and Weight &!>
= [seq(0,i=Weight)]) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "        or
 (Weight &!>= [Table[Entries[k][]]][1] and Weight &!<= [seq(0,i=Weight
)]) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "         StableSet :=
 [Table[Entries[k][]]][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "      ### we have to recompute the \+
stable set for a larger weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 " \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "         ### Weight is
 not necessarely larger, only some elements" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 91 "         ### therefore we find a maximized weight and
 recalc. the stableset (for pos. wt-s)" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 94 "         if( not(Weight &!> [Table[Entries[k][]]][1]) and Weig
ht &!>= [seq(0,i=Weight)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 
"            Temp := maximize([Table[Entries[k][]]][1], Weight);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "            StableSet := stableset(
[op(4,eval(ideal))[Ideal]], Temp, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 73 "            ### once we computed it for a higher weight, we mi
ght as well" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "            ### add \+
it to the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "            quot
alg(FactAlg,`stableset`) := Temp, StableSet:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "         ### We
ight is not necesserily larger, only some elements" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 91 "         ### therefore we find a maximized weight a
nd recalc. the stableset (for neg. wt-s)" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 96 "         elif( not(Weight &!< [Table[Entries[k][]]][1]) and W
eight &!<= [seq(0,i=Weight)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
66 "            Temp := -maximize(-[Table[Entries[k][]]][1], -Weight);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "            StableSet := stable
set([op(4,eval(ideal))[Ideal]], Temp, Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 73 "            ### once we computed it for a higher weig
ht, we might as well" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "           \+
 ### add it to the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "       \+
     quotalg(FactAlg,`stableset`) := Temp, StableSet:" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "         #
## the weight is simply larger than the one we had, recalc. s-set" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "         else " }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 76 "            StableSet := stableset([op(4,eval(ideal)
)[Ideal]], Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "       \+
     ### once we computed it for a higher weight, we might as well" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "            ### add it to the table
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "            quotalg(FactAlg,`st
ableset`) := Weight, StableSet:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "
         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      ### stable set has to \+
be computed" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "      StableSet := s
tableset([op(4,eval(ideal))[Ideal]], Weight, Alg);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 67 "      ### once we computed it, we might as well add
 it to the table" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      quotalg(F
actAlg,`stableset`) := Weight, StableSet:" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 50 "   ### generate hall monomials of the giv
en weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   Basis := genhallmon
(Weight, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 46 "   ### pick out only the elements we will need" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   if( Weight &!>= [seq(0,i=Weight
)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "      StableSet := map
((x)->if(wt(leading(x,Alg),Alg) &!<= Weight) then x; fi, StableSet);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 90 "      StableSet := map((x)->if(wt(leading(x,Alg),Alg)
 &!>= Weight) then x; fi, StableSet);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 45 "   ### almost ready to loop, init. some stuff" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "   i := 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "   ### throw ou
t the hall monomials that have the leading term of an element" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "   ### from the stable set as a sub
word" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "   while( nops(Basis) > 0 a
nd i <= nops(Basis) ) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "      D
eleteIt := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "      j := 1;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 38 "      while( j <= nops(StableSet) ) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 61 "         if( subwd(StableSet[j], Basis[i], Alg) <> []
 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "            DeleteIt :=
 true;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "            break; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "         j := j + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 68 "      ### go ahead and delete current element, do
n't increment count" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      if( De
leteIt ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "         Basis := \+
subsop(i=NULL,Basis);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "      ### \+
increment count" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "         i := i + 1;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   od; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "   ### return the results" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "   RETURN(Basis);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "LieAlg_Hidden[stableset] := proc(R:
:list(algebraic),Alpha::homogwt)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 
"    description `Calculates the stableset.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "    ### decalarations" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 324 "    local Alg, i, j, k, S, Q, P, Temp, time0, time1, time2, t
ime3, time4, time5, time6, time7, timetot, timehall, timeloc, timered,
 timesub, timecomp, printcount, leadofTemp, Beta, Words, Next, Add, Te
rm, Lead, TempLead, PLead, Pwt, Swt, ii, jj, icanc, nQ, nP, shift, Qdb
l, newel, H, mon, coef1, coef2, i1, i2, flag, countQ," }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 76 "          rescale, insert, remidlead, double_lis
t; ### ==> our subprocedures" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "   \+
 ### give it memory" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 91 "    option `
Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, system, re
member;  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 75 "    #-------------------> definition of subprocedures
 <--------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "    ### t
his procedures rescales the given expression and its leading term" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "    rescale := proc(Expr)" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 74 "       option `Copyright (C) 1999-2019 by
 Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
23 "       ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "    \+
   local Temp, Lead;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 74 "       ### when there is a characteristic d
efined, we have to take the mod" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "
       ### of the expression before rescaling anything" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 39 "       Temp := applychar( Expr );      " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
75 "       ### applychar() could have returned zero or removed the lea
ding term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "       if( Temp = 0 ) \+
then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "          RETURN(0);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "          Lead := leading(Temp, ALGEBRA);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       ### doing the resca
ling" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "       if( type(Lead,`*`) )
 then \n" }{MPLTEXT 1 0 28 "          # Correction 2019\n" }{MPLTEXT 
1 0 36 "          # RETURN(Temp/op(1,Lead));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 43 "          RETURN(Temp/PickConstants(Lead));" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 23 "          RETURN(Temp);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 
"       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "   #--
---------------------------------------------------------------------"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "    ### insert() inserts an elem
ent into a list " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "    ### (depend
ing on the lexicographical position)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 24 "    insert := proc(E, L)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 " \+
      option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag
.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "       ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "       local Half, R;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "       \+
### finding half point" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "       Ha
lf := trunc(nops(L)/2);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "       ### if list is empty, expr i
s the only element" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "       if( L \+
= [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "          R := [E];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 86 "       ### if there is only one term in L, it's easy to determin
e the right spot for E" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "       el
if( nops(L) = 1 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "         \+
 if( E &< L[1] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "          \+
   R := [E, L[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "          else
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "             R := [L[], E];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "       ### else
 insert into the half that should contain E" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 32 "       elif( E &< L[Half] ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 63 "          R := [insert(E, L[1..Half-1])[], L[Half..n
ops(L)][]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "       elif( E &= L[
Half] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "          R := [L[1
..Half-1][], E, L[Half..nops(L)][]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 11 "       else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "          R :=
 [L[1..Half][], insert(E, L[Half+1..nops(L)])[]];" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "       ### return the results" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       RETURN(R);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 8 "    end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "    #------------------------------
-----------------------------------------" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 63 "    ### remidlead() eliminates the identical leading \+
terms in L" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "    remidlead := proc
(L)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "       option `Copyright (C)
 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "       ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 30 "       local i, Q, Temp, Next;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "       ### init. the loo
p-counter and our list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "       Q \+
:= L;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "       i := 1;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "     \+
  ### loop through the sorted list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
30 "       while( i < nops(Q) ) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "          ### takes care of \+
the displacement after an element is removed" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "          Next := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "          ### when two ele
ments in sequence have " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "        \+
  ### the same leading term subtract them..." }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "          if( Q[i] &= Q[i+1] ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 40 "             ### don't skip next element" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "             Next := 0;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "     \+
        ### we do the subtraction " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "             Temp := Q[i+1] - Q[i]; " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 13 "             " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "         \+
    ### when there isn't a cancellation, we rescale our stuff " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "             if( Temp <>  0 ) then"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                Temp := rescale(
Temp);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 74 "                ### throw the result back in the list
 in the correct place" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "          \+
      Q := [Q[1..i][], insert(Temp, Q[i+2..nops(Q)])[]];" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "       \+
      ### remove the element, since Q[i] = Q[i+1]" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 18 "             else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 41 "                Q := subsop(i = NULL, Q);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "             fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "          fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 29 "          ### increment count" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 24 "          i := i + Next;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "       od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    \+
   ### return the list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "       RE
TURN(Q);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "   #------
-----------------------------------------------------------------" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   double_list := proc(Sum)" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "       option `Copyright (C) 1999-2
019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 139 "       description `Converts a sum into a pair of lists - fir
st list is a list of monomials, the        second is the list of coeff
icients." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "             Returns: [
[list of monomials], [list of coefficients]]`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 23 "       ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 21 "       local L,T,S,i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "       L:=[]; T:=[]; S := [];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
24 "       ### we have a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   \+
    if( type(Sum, `+`) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 " \+
         S := [op(Sum)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "       \+
### sum has only one term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "      \+
 elif( Sum <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "         \+
 S := [Sum];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
26 "       for i to nops(S) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 " \+
         if (type(S[i], `*`) ) then\n" }{MPLTEXT 1 0 31 "             \+
# Correction 2019\n" }{MPLTEXT 1 0 38 "             # T := [T[], op(1,
S[i])];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "             # L := [L[]
, op(2,S[i])];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "             T :=
 [T[], PickConstants(S[i])];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   \+
          L := [L[], PickTerm(S[i])];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "           \+
  T := [T[], 1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "             L \+
:= [L[], S[i]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "      RETURN([
L,T]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 75 "   #---------------------------- end of subs -----
-------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "   #------------------------> main \+
proc()'s body <-------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "    if( nargs > 3 ) the
n " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "       ERROR(`too many argume
nts %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    elif( nargs
 = 3 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "       Alg := args[3
];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "       Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 27 "    ### set default algebra" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "    using(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    ### will hold generated wei
ghts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    Beta := [seq(0,i=Alpha)
];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 67 "    ### see what we'll have to do (add to Beta or subtract fr
om it)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "    if( Alpha &!>= Beta )
 then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "       Add := true;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 20 "       Add := false;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 12 "    S := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "
    Swt := [];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 23 "    for i to nops(R) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 36 "       Temp := lsimplify(R[i], Alg);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 35 "       ### getting the leading term" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 40 "       leadofTemp := leading(Temp, Alg);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "       ### checking for homogenouity" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 33 "       if( type(Temp, `+`) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 39 "          if( wt(Temp, Alg) = [] ) then" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 60 "             ERROR(`terms in %1 are not homog
enous.`, Temp) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       ### doin
g the rescaling" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "       Temp := r
escale(Temp); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 67 "       ### add element to S if its weight is not \+
greater than alpha" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "       if( Te
mp <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "          leadofT
emp := leading(Temp, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "     \+
     if( Add ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "            \+
 if( wt(leadofTemp, Alg) &!<= Alpha ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "                S := [S[], Temp];" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 52 "                Swt := [Swt[], wt(leadofTemp, Alg)]
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "             fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 14 "          else" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 54 "             if( wt(leadofTemp, Alg) &!>= Alpha ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "                S := [S[], Temp];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "                Swt := [Swt[], wt
(leadofTemp, Alg)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "            \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "    od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "    ### init. the list P, that holds our results" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "    P := [];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "    PLead := []; Pwt := [];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "    ### we loop
 and generate Betas" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    while( B
eta <> Alpha ) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 24 "       ### creating Beta" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 29 "       for i to nops(Beta) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 78 "          ### current element of Beta is to be zeroed
 if reached its max value" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      \+
    if( Beta[i] = Alpha[i] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
26 "             Beta[i] := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "          ### increment curr. ele
ment of B" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "          else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "             ### adding or subtract
ing, depending on what we need to do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 27 "             if( Add ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "                Beta[i] := Beta[i] + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 17 "             else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
39 "                Beta[i] := Beta[i] - 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 16 "             fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "             break;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "        \+
  fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       od;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "#######" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "# print(`==>`,Beta,`<==`,`time:`,t
ime());" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 93 "# if ( (op(4,eval(ranking)) <> NULL) and ( nops([indi
ces(op(4,eval(ranking)))]) > 30 ) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 62 "#    print(`Ranking:`, nops([indices(op(4,eval(ranking)))]) )
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "# fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "# if ( (op(4,ev
al(mainlsimplify)) <> NULL)  ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
74 "#    print(`Mainlsimplify:`, nops([indices(op(4,eval(mainlsimplify
)))]) );" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "# print( op(4,eval(main
lsimplify)) ); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 5 "# fi;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "#   if(op(4,eval(ranking)) <> NULL) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 38 "#        subsop(4=NULL,eval(ranking)):" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 7 "#   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 10 "#SWC := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 34 "       ### init. Q and our counter" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 15 "       Q := [];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "       i := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "
       countQ := 0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 31 "       while( i <= nops(S) ) do" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 57 "           ### dump elements of weight Beta \+
from S into Q" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "           ### and
 delete element from S, don't increment counter" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "           if( Swt[i] = Beta ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 31 "              Q := [Q[], S[i]];" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 36 "              S := subsop(i=NULL,S);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 40 "              Swt := subsop(i=NULL,Swt);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "           else" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 25 "              i := i + 1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 14 "           fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "
       od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "       ### rear
range Q in increasing order " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "   \+
    ### (in `<` decision is made dep. on the leading terms)" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 45 "       ### and remove identical leading te
rms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "       # Q := remidlead(sort
(Q, `&<`));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 37 "      #sort and rescale elements of Q" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 54 "      #create double list with elements in the
 format:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      # [[list of monom
ials],[list of coefficients]]" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 2 "  "
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      Qdbl := [];" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 25 "      for i to nops(Q) do" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 45 "       Qdbl := [op(Qdbl), double_list(Q[i])];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 18 "#timehall:=time();" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "      # generate and sort Hall monomials" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 43 "      H:=sort(genhallmon(Beta, Alg), `&<`);"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "#timehall:=time() - timehall;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "# print(`Hall monomials:`, timehal
l);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "      nP:= nops(P);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 21 "#      printcount:=0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "#timetot:=0; timeloc:=0;timered:=0;
timesub:=0;timecomp:=0;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "      while ((nops(Q)>0) and (nops(
H)>0)) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "#         time0:=time();" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "#time1:=time();" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 
"         mon := H[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "         \+
H := subsop(1=NULL,H);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "#        \+
 SWC := SWC + 1; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 56 "         # find elements of Q with mon as a le
ading term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "         # Temp is a \+
list with elements in format: " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 " \+
        # [position in Q, coeff at mon]" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "         Temp:=[];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         for i to nops(Q) do" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "           if ( member( mon, Qdbl[i
,1], 'jj') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "             T
emp := [op(Temp), [i,Qdbl[i,2,jj]] ];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 14 "           fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         od
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 53 "#time1:=time() - time1; time2:=0; time3:=0; time4:=0;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "         # if Temp is empty,
 skip to the next monomial" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "     \+
    # if Temp has more than one element, reduce using the first" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "         # if Temp has one element,
 try to find a composition" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "         if (nops(Temp) > 0) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 15 "#time2:=time();" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 27 "           i1 := Temp[1,1];" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 30 "           coef1 := Temp[1,2];" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "         \+
  if (nops(Temp) > 1) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "     \+
        for i from nops(Temp) by -1 to 2 do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "               i2 := Temp[i,1];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "               coef2 := Temp[i,2];" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "            \+
   # new reduced element of Q" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "############### !!!!!!!!!!!!!!!!!!
!!" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "               newel := apply
char(Q[i2] - (coef2/coef1)*Q[i1]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "############### !!!!!!!!!!!!!!!!!!!!" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "               if (newe
l = 0) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "                   #
delete if it vanished" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "          \+
         Q := subsop( i2=NULL, Q);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
50 "                   Qdbl := subsop( i2=NULL, Qdbl);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 21 "                 else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 27 "                   #replace" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "                   Q := subsop( i2=newel, Q);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "                   Qdbl := subsop( \+
i2=double_list(newel), Qdbl);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "  \+
             fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "              o
d;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "            fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "#time2:
=time() - time2; time3:=time();" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "            flag := 1;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 62 "            # if we find the composition,
 we switch flag to 0." }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "    \+
      ### init. the other loop count" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 18 "          j := 1; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "       \+
   while( (j <= nP) and (flag = 1) ) do " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 58 "             ### attempting to find P[j] hidden within mon" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "             ### (only if it's pos
sible for P[j] to be in mon)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "             if( (Add and (Pwt[j] &
!<= Beta))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "              or (not
(Add) and (Pwt[j] &!>= Beta )) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                Temp := su
bwd(P[j], mon, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 52 "                ### when found, take its co
mposition" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                if( Te
mp <> [] ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 57 "#time3:= time() - time3; time4:=time();        \+
          " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "                   fl
ag := 0; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "######################### !!!!!!!!!!!" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 95 "                   Q[i1] := applychar(Q[i1] - e
xpand(coef1*lsimplify(comp(Temp[], Alg), Alg)));" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "######################### !!!!!!!!!!!" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         \+
          ### the terms cancelled" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "                   if( Q[i1] = 0 ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 48 "                      Q := subsop(i1 = NULL, Q);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "                      Qdbl:=subsop(
i1 = NULL, Qdbl);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "              \+
     else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "                      \+
Qdbl:=subsop(i1 = double_list(Q[i1]), Qdbl);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "                   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 " #time4:= time() - time4
; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 17 "              fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "             j := j+1;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 13 "          od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 58 "          # if flag is still 1, move the e
lement of Q to P" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "         \+
 if (flag = 1) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 23 "#time3:=time() - time3;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "             P
 := [op(P), Q[i1]/coef1 ];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "     \+
        PLead := [op(PLead), mon];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
36 "             Pwt := [op(Pwt), Beta];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 40 "             Q := subsop( i1 = NULL, Q);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 46 "             Qdbl := subsop( i1 = NULL, Qdbl);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "             countQ := countQ + 1;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "          fi;" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 11 "        fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "#time0:=time() - time0; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
123 "#timeloc:=timeloc+time1; timered:=timered+time2; timesub:=timesub
+time3; #timecomp:=timecomp+time4; timetot:=timetot+time0;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 42 "#if (printcount = 200) then printcount:=0;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 141 "#       print(`iteration:`, SWC
, `time:`, timetot, `locate:`,timeloc,             #`reduce:`,timered,
 `subword:`,timesub, `comp:`, timecomp);" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 58 "#timetot:=0; timeloc:=0;timered:=0;timesub:=0;timecomp:=0;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "#   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "#    printcount:=printcount+1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 4 "#fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "##########" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 41 "# print(`Comp&simpl for subwords:`, SWC);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "#time5:=time();" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "       ### g
oing through P and new part of P (from Q)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 26 "       for i to nops(P) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 55 "          for j from nops(P) - countQ + 1 to nops(P) \+
do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "           " }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 38 "             ### checking for overlaps" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 45 "             if( PLead[i] &< PLead[j] ) th
en " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 63 "                ### the functions returns overlaps if
 found any" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 "                ### (
returned in form [[[a],[overlap],[b]],[...]])" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 58 "                Words := overlap(PLead[i], PLead[j], \+
Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 68 "                ### if there are overlaps and the wei
ght of the word" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "                \+
### a(overlap)b is less than alpha, our incoming weight" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 38 "                if( Words <> [] ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
53 "                   ### now we go through the overlaps" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 42 "                   for k to nops(Words) do" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "                     if( (Add and
 add(wt(l,Alg),l=[Words[k][1][]," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 
"                                                   Words[k][2][],Word
s[k][3][]]) &!<= Alpha) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "       \+
               or (not(Add) and add(wt(l,Alg),l=[Words[k][1][]," }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 99 "                                   \+
                Words[k][2][],Words[k][3][]]) &!>= Alpha) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
80 "                         Temp := lsimplify(comp([],P[i],Words[k][3
], Alg), Alg) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "                 \+
              - lsimplify(comp(Words[k][1],P[j],[], Alg), Alg);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
45 "                         if( Temp <> 0 ) then" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 50 "                            Temp := rescale(Temp);" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "                            S := \+
[S[], Temp];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "                   \+
         Swt := [Swt[], wt(leading(Temp, Alg))];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "                         fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 25 "                      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "                   od;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 19 "                fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 " " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "             ### the symmetric case
 to the previous" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "             el
if( PLead[i] &> PLead[j] ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "                ### the functio
ns returns overlaps if found any" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 66 
"                ### (returned in form [[[a],[overlap],[b]],[...]])" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "                Words := overlap(P
Lead[j], PLead[i], Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "                ### if there are ov
erlaps and the weight of the word" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
71 "                ### a(overlap)b is less than alpha, our incoming w
eight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                if( Words \+
<> [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "                   \+
### now we go through the overlaps" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
42 "                   for k to nops(Words) do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 65 "                     if( (Add and add(wt(l,Alg),l=[Wo
rds[k][1][]," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "                   \+
                                Words[k][2][],Words[k][3][]]) &!<= Alp
ha) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "                      or (n
ot(Add) and add(wt(l,Alg),l=[Words[k][1][]," }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 99 "                                                   Wo
rds[k][2][],Words[k][3][]]) &!>= Alpha) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "               \+
          Temp := lsimplify(comp([],P[j],Words[k][3], Alg), Alg) " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "                               - ls
implify(comp(Words[k][1],P[i],[], Alg), Alg);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "               \+
          if( Temp <> 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 " \+
                           Temp := rescale(Temp);" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 45 "                            S := [S[], Temp];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 67 "                            Swt := \+
[Swt[], wt(leading(Temp, Alg))];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 
"                         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "  \+
                    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "        \+
           od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "                f
i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "             fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 13 "          od;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 11 "       od; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 72 "# time5:=time()-time5; # print(`time for new
:`,time5);                  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    \+
od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "    ### set default back" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 19 "    using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "    ### returning our resu
lts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "    RETURN(P);" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0
 "> " 0 "" {MPLTEXT 1 0 76 "LieAlg_Hidden[comp] := proc(a::list(name),
unsimplV::algebraic,b::list(name))" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazza
g.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   description `Computes th
e composition of the expression.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
19 "   ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "   local
 U, Alg, i, Previ, BracketList, Least, LowMark, HighMark, V, leadofV, \+
Vinlist;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "   ### standard check" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 23 "   if( nargs > 4 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "
      ERROR(`too many arguments %1.`, args);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### use othe
r than default algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   elif( \+
nargs = 4 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := ar
gs[4];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 21 "      Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 26 "   ### set default algebra" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 14 "   using(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "   ### preparing the V p
art of the entry going in list U" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 
"   ### producing V from the unsimplified input" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "   V := lsimplify(unsimplV, Alg);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### gettin
g the leading term of V" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   leado
fV := leading(V, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 32 "   ### checking for homogenouity" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   if( type(V, `+`) ) then " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "      if( wt(V, Alg) = [] ) then" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "         ERROR(`terms in %1 are no
t homogenous.`, V) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "   ### some checks on input" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "
   elif( V = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      RETU
RN(0);\n" }{MPLTEXT 1 0 14 "   # JUL 2019\n" }{MPLTEXT 1 0 35 "   # el
if( type(V, constant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "   \+
elif( is(V, constant) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "   \+
   ERROR(`middle term in simplifies to a constant, which is not allowe
d.`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "   ### rescali
ng the sum if we have to" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "   if( \+
type(leadofV, `*`) ) then \n" }{MPLTEXT 1 0 24 "      # Correction 201
9\n" }{MPLTEXT 1 0 37 "      # V := (V) * (1/op(1,leadofV));" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 41 "      # leadofV := leadofV/op(1,leadofV);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "      V := expand(" }{MPLTEXT 
1 0 29 "(1/PickConstants(leadofV)) * " }{MPLTEXT 1 0 3 "V);" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 24 "      leadofV := expand(" }{MPLTEXT 1 0 
29 "(1/PickConstants(leadofV)) * " }{MPLTEXT 1 0 9 "leadofV);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### the part of V th
at goes in U\n" }{MPLTEXT 1 0 21 "   # Correction 2019\n" }{MPLTEXT 1 
0 99 "   # Vinlist := map(proc(x) if(type(x,`*`)) then op(2,x); else x
; fi; end, [extract(leadofV,Alg)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
101 "   Vinlist := map(proc(x) if(type(x,`*`)) then PickTerm(x); else \+
x; fi; end, [extract(leadofV,Alg)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   ### throwing everything
 in a list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "   U := [op(a), op(Vi
nlist), op(b)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 30 "   ### where V starts and ends" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 24 "   LowMark := nops(a)+1;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 37 "   HighMark := nops(a)+nops(Vinlist);" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   ### fi
nding smallest element in the list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
28 "   Least := sort(U,`&<`)[1];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   ### this is the list we're c
opying into" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   BracketList := []
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### loop counter" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 10 "   i := 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ### looping through t
he list, examining each element in it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 28 "   while( i <= nops(U) ) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      ### shows the first in a series of smallest elements" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      Previ := i;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "      ### w
e loop 'til current element is smallest" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 47 "      while( U[i] &= Least and i < nops(U) ) do" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 21 "         i := i + 1; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "      ### we have more than one sma
llest elements in row " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "      ###
 and they stretch over V" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      i
f( Previ <= LowMark and HighMark < i ) then " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "         BracketList := [BracketList[], [U[Previ..Low
Mark-1][], [[V], " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 97 "              \+
                                              lieconvert(U[HighMark+1.
.i], Alg)]]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 68 "      ### if the bracketing would fall inside V sk
ip to the end of V" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "      elif( P
revi <= LowMark and LowMark <= i ) then " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 38 "         ### Previ is right on the dot" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "         if( Previ = LowMark ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 48 "            BracketList := [BracketList[], [V]];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "         else" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 73 "            BracketList := [BracketList[], [U[Prev
i..LowMark-1][], [V]]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "        \+
 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "         ### since we grabb
ed the whole of V, increment i" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 " \+
        i := HighMark;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "        " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "      ### not a smallest element,
 just copy it over" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      elif( P
revi = i ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "         Bracke
tList := [BracketList[], U[i]];        " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "      ### sequence of sm
allest elements" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "         if( Previ = LowMark and i \+
= HighMark ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "            Br
acketList := [BracketList[], [V]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "            Br
acketList := [BracketList[], U[Previ..i]];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "         fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "   \+
   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "      i := i + 1;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "   ### generating the l
ie-expressions from the lists" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "  \+
 for i to nops(BracketList) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "
      ### single values are not in list form" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "      if( type(BracketList[i], `list`) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "         BracketList[i] := lieconve
rt(BracketList[i], Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "      e
lse " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "         BracketList[i] := \+
lieconvert([BracketList[i]], Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "   #
## now that the subparts are broken up, we can combine them" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 47 "   BracketList := lieconvert(BracketList, \+
Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 24 "   ### resetting default" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 18 "   using(`reset`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   ### not all input is acce
pted" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "   if( BracketList = [] ) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "      ERROR(`bad words, cann
ot be converted to a Hall Monomial`);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 28 "   ### returning our results" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "      RETURN(listtoli
e(BracketList, 0));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "LieAlg_
Hidden[independent] := proc(List::list) " }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas \+
Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 98 "   description `indepe
ndent([list of expressions]) picks out the linearly independent expres
sions " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "               from the l
ist`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "   ### declarations" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "   local i, j, k, SimplList, Vars, \+
Gens, Alg, Vectors, LinIndVectors, Result, addelement;" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 29 "   # option system, remember;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 92 "     #------------------------> definition \+
of subprocedures <-------------------------------" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "     ### adds \+
an element to a set if it's not a constant" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 96 "     ### also, it throws out the constant multiplier \+
of the element to be added, if there is one" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "     addelement
 := proc(Element, Set)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "        o
ption `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "        ### giving it memory" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        # option system, remember;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 76 "        ### we have a constant, we throw the constant part away,
 add element" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "        if( type(El
ement, `*`) ) then\n" }{MPLTEXT 1 0 29 "           # Correction 2019\n
" }{MPLTEXT 1 0 48 "           # RETURN(Set union \{op(2, Element)\});
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "           RETURN(Set union \{P
ickTerm(Element)\});" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 87 "        ### no constant multiplier, and ele
ment isn't a constant, we just add it as is\n" }{MPLTEXT 1 0 19 "     \+
   # JUL 2019\n" }{MPLTEXT 1 0 51 "        # elif( not(type(Element, c
onstant)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "        elif( n
ot(is(Element, constant)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 
"           RETURN(Set union \{Element\}); " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "        ### Ele
ment is a constant, don't add it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 
"        else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "           RETURN(
Set);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        fi;" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 9 "     end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 92 
"     #--------------------------------- end of subs -----------------
-----------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
92 "   #------------------------------> main proc()'s body <----------
--------------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   ### called with too many argumen
ts" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "   if (nargs > 2) then ERROR(
`too many arguments %1.`, args); fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "   ### if called with two \+
arguments, the second must be the algebra to use" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "   ### setting default algebra to be requested, savin
g current algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "   if( nargs =
 2 ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "      Alg := args[2];
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "      Alg := ALGEBRA;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 44 "   ### Vars holds the terms of an expression" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "   ### ie. for x + x&*y Vars = \{x,
 x&*y\}" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "   Vars := \{\};" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
64 "   ### SimplList holds the simplified terms of the original list" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "   ### (given the simplification \+
didn't result in a constant)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   \+
SimplList := array(1..nops(List));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "   ### looping through the l
ist starting with the first element" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
25 "   for i to nops(List) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "      ### simplifying each term in
 the list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "      SimplList[i] := \+
lsimplify(List[i],Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "      ### simplified expression is \+
a sum" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "      if( type(SimplList[i
], `+`) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 67 "         ### loop through the terms of the sum t
o add terms to Vars" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "         for
 j to nops(SimplList[i]) do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "            ### add element returns
 the set with the added term, it also" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 58 "            ### takes care of leading constant multipliers" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 58 "            Vars := addelement(op(j
, SimplList[i]), Vars);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "         od;          " }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "      \+
### simplified expression is not a sum of terms" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "         ### add element returns th
e set with the added term, it also" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
55 "         ### takes care of leading constant multipliers" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 48 "         Vars := addelement(SimplList[i], \+
Vars);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "   od; \+
 " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 71 "   ### we define a list of vectors that will hold the independ
ent terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "   ### (needs to be a \+
vector for the linear algebra procedures to work with them)" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 82 "   Vectors := [seq(linalg[vector](nops(Var
s),0),i=1..nops([indices(SimplList)]))];" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "   ### looping through \+
the simplified expression" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "   ###
 to fill the vector" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   for i to \+
nops([indices(SimplList)]) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "      ### looping through the dif
ferent terms we found" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 29 "      for \+
j to nops(Vars) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 36 "         ### expression can be a sum" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "         if( type(SimplList[i],`+`)
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 52 "            ### looping through the terms in the sum"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "            for k to nops(SimplL
ist[i]) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 71 "               ### we have to get the constant multi
plier from the term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 74 "            \+
   ### and set the corresponding vector element to that number" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "               if( type(op(k, SimplList[i]), `*`) ) then \n" }
{MPLTEXT 1 0 37 "                   # Correction 2019\n" }{MPLTEXT 1 
0 70 "                   # if( op(2, op(k, SimplList[i])) = Vars[j] ) \+
then  " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "                   if( Pi
ckTerm(op(k, SimplList[i])) = Vars[j] ) then  " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 82 "                      Vectors[i][j] := Vectors[i][j] \+
+ op(1, op(k, SimplList[i]));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "  \+
                 fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 44 "               ### the default constant is \+
1" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "               elif( op(k, Sim
plList[i]) = Vars[j] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "    \+
              Vectors[i][j] := Vectors[i][j] + 1;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 65 "         ### we have to get the constant m
ultiplier from the term" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "        \+
 ### and set the corresponding vector element to that number" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 80 "         elif( type(SimplList[i], `*`) an
d op(2, SimplList[i]) = Vars[j] ) then\n" }{MPLTEXT 1 0 31 "          \+
   # Correction 2019\n" }{MPLTEXT 1 0 69 "             # Vectors[i][j]
 := Vectors[i][j] + op(1, SimplList[i]); " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 75 "             Vectors[i][j] := Vectors[i][j] + PickCon
stants(SimplList[i]); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 40 "         ### the default constant is one"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "         elif( SimplList[i] = Va
rs[j] ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "             Vecto
rs[i][j] := Vectors[i][j] + 1; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 13 "
         fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      od;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 7 "   od; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "   ### this command picks ou
t the independent vectors" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "   Lin
IndVectors := linalg[basis](Vectors); " }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "   ### initializing the \+
result list" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "   Result := []; " }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
72 "   ### picking out the terms from the original list that are indep
endent" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "   ### (the vectors that \+
didn't change when the independent vectors were found)" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 35 "   for i to nops(LinIndVectors) do " }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "     \+
 ### we're looking for the vectors that are in both list" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 72 "      ### List and Vectors are parallel lists
 (at the place of constants" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "    \+
  ### Vectors contains a zero vector), so the k-th term matches the " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "      ### corresponding term in L
ist, which needs to be returned" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "
      if( member(LinIndVectors[i], Vectors, 'k') ) then " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 41 "         Result := [op(Result), List[k]];" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   od;" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "   \+
### returning the result" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   RETU
RN(Result);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 51 "LieAlg_Hidden[idealbasis] := proc(Weight::homogwt) " 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 96 "    description `idealbasis([weig
ht]) generates the basis of an algebra for a specified weight`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "    ### declarations" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 17 "    global IDEAL;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 70 "    local ispos, GenerateBasis, Ideal, Table, IdealGe
ns, AlgGens, Alg;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 44 "    ### give i
t memory to improve efficiency" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 " \+
   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`,
 remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 3 "   " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "      #-----
-------------------> definition of subprocedures <--------------------
-----------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 77 "      ### this subproc. is the part of the procedure
 that generates the basis" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      \+
### Weight: specified weight to find the basis for" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 53 "      ### IdealGens: generators of the ideal for th
e " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "      ### AlgGens: generators
 of the ideal's algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "      ##
# Alg: name of ideal's algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "      GenerateBasis := proc(Weigh
t,IdealGens,AlgGens,Alg,Neg) " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "  \+
      ### declarations" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "        l
ocal i, W, Temp, Result;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "       \+
 ### give it memory to improve efficiency" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 93 "        option `Copyright (C) 1999-2019 by Yuly Billi
g and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "        ### result is e
mpty at this point" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "        Resul
t := \{\}; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 65 "        ### looping through the generators of the id
eal's algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "        for i to n
ops(AlgGens) do " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 75 "           ### subtract the weight of the curre
nt generator from the weight" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 65 "   \+
        W := zip((x,y)->x-y, Weight, wt(AlgGens[i], Alg), 0); " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
75 "           ### checking for the weight to be positive after the su
btraction" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "           if( Neg and
 not(hastype(W, negative)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 
"" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "              ### call recursi
vely the function" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "              \+
Temp := GenerateBasis(W, IdealGens, AlgGens, Alg, Neg); " }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "       \+
       ### we add all elements of Temp multiplied by " }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 62 "              ### the current generator of the i
deal's algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "              Res
ult := Result union \{op(map(proc(x,y) evaln(y&*x) end, Temp, AlgGens[
i]))\}; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 72 "           ### checking for the weight to be negative
 after the addition" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "           e
lif( not(Neg) and not(hastype(W, positive)) ) then " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "            \+
  ### call recursively the function" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
70 "              Temp := GenerateBasis(W, IdealGens, AlgGens, Alg, Ne
g); " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 1 " " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 60 "              ### we add all elements of Temp multipl
ied by " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "              ### the cu
rrent generator of the ideal's algebra" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 93 "              Result := Result union \{op(map(proc(x,y) evaln(
y&*x) end, Temp, AlgGens[i]))\}; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
15 "           fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        od;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 47 "        ### loop through the ideal's generators" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 35 "        for i to nops(IdealGens) do" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "      \+
     ### add all those terms that have the same as the specified weigh
t" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "           if( Weight = wt(Ide
alGens[i], Alg) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "         \+
    Result := Result union \{IdealGens[i]\}; " }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 15 "           fi; " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "        od; " }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "        ### \+
return only the independent elements" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 46 "        RETURN(independent([op(Result)],Alg));" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 11 "      end: " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 
"      #--------------------------------- end of subs ----------------
---------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 4 "    " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "
    #-------------------------------> main proc()'s body <------------
--------------------" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 52 "    ### procedure was called with too many \+
arguments" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "    if (nargs > 2) the
n" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 45 "       ERROR(`too many argumen
ts %1.`, args);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 53 "    ### if no al
gebra specified, then use the default" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 53 "    elif( nargs = 2 and type(args[2],`ideal`) ) then " }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 24 "       Ideal := args[2];" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 9 "    else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "  \+
     Ideal := IDEAL;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }{TEXT 219 0 "" }{MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "    ### getting the name of the \+
algebra of the ideal" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "    Alg := \+
op(4,eval(ideal))[(Ideal,`algebra`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 44 "    AlgGens := [op(4, eval(algebra))[Alg]]; " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 45 "    IdealGens := [op(4,eval(ideal))[Ideal]]; " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
82 "    ### generating the basis (depending on the passed in weight, w
e pass on flags;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "    ### when pa
ssing `true`, it means we have to have to check for negative values in
 the " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 85 "    ### weight for quittin
g the loop in GenerateBasis, `false` means a check for pos)" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 44 "    if( Weight &!>= [seq(0,i=Weight)] ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "       ### checking for negat
ive weights for the generators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 " \+
      ### (this check is done to avoid an infinite loop in GenerateBas
is where" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "       ### the weight o
f generators is subtracted from Weight)" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 65 "       if( map(proc(x,y) if(wt(x,y) &!<= [seq(0,i=wt(x,y))]) t
hen" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 78 "                            \+
RETURN(false); fi; end, AlgGens, Alg) = [] ) then " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 72 "           RETURN(GenerateBasis(Weight, IdealGens, \+
AlgGens, Alg, true));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       els
e" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "           RETURN([]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "       fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "    ### generat
ing basis" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 59 "       ### checking for positive weights for t
he generators" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 79 "       ### (this c
heck is done to avoid an infinite loop in GenerateBasis where" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 62 "       ### the weight of generators
 is subtracted from Weight)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "    \+
   if( map(proc(x,y) if(wt(x,y) &!>= [seq(0,i=wt(x,y))]) then false;" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "                         fi; end,
 AlgGens, Alg) = [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "     \+
     RETURN(GenerateBasis(Weight, IdealGens, AlgGens, Alg, false));" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 21 "          RETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "LieAlg_
Hidden[repbasis] := proc(W::list(integer),Rep::hwrep)" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billi
g and Matyas Mazzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 
"   description `Calculates the basis for a representation.`;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   local R, dorepbasis;" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 57 "   #-
---------------> subs() <---------------------------" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 32 "   dorepbasis := proc(W,Alg,HWV)" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 88 "   option `Copyright (C) 1999-2019 by Yuly Billi
g and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 60 "   description `Calculates the basis for a representation.`;"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   local i, j, k, T, R;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
58 "      if( type(W,`mixedwt`) or (W &!> [seq(0,i=W)]) ) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "         RETURN([]);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 35 "      elif( W = [seq(0,i=W)] ) then" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 23 "         RETURN([HWV]);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 10 "      else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 " \+
       T := W;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "        R := [];"
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 39 "        for i to mul(abs(k)+1,k=W)-1 do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 40 "           R := [R[],map((x,wl,r,a,ow)->" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 75 "                          map(proc(w,x,r,a,o
w) local t; t:=[allop(w,`kt`)];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "
                                 if(w<>r and t[1] &< x) then" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 41 "                                    NULL;
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 38 "                               \+
  else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "                        \+
            convert(convert([x,t[]],`&@`),`&^`);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "                                 fi; end," }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 41 "                          wl,x,r,a,ow)[]," 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 "                 basis(T,Alg),dor
epbasis(W-T,Alg,HWV),HWV,Alg,W)[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "           for j from nops(T
) to 1 by -1 do" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "              if
( T[j] = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 30 "              \+
   T[j] := W[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "              e
lse" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "                 break;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "              fi;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 14 "           od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
27 "           if( j > 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 31 "
              T[j] := T[j] + 1;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "
           fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "        od;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "        RETURN(R);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 50 "#        RETURN(convert(convert(R,`set`),`list`)
);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   #---
-------------- end of subs" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   using(op(4,eval(hwrep))[Rep,`alg
ebra`][2]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 81 "   R := dorepbasis(W
,op(4,eval(hwrep))[Rep,`algebra`][2],op(4,eval(hwrep))[Rep]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   using(`reset`);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 13 "   RETURN(R);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 73 "LieAlg_Hidden[submodulebasis] := pr
oc(W::list(integer),SubMod::submodule)" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 80 "   option `Copyright (C) 1999-2019 by Yuly Billig and Matyas M
azzag.`, remember;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "   descriptio
n `Calculates the basis for a representation.`;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 45 "   local B, M, Rep, Alg, dosubmodulebasis, i;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
57 "   #----------------> subs() <---------------------------" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "   dosubmodulebasis := proc(W,Alg,H
WV,SubModGens)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 "   option `Copyri
ght (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`, system, remember
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   description `Calculates the
 basis for a submodule.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "   loc
al i, j, k, T, R;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 47 "      ### mixed weights in, or positive weight
s" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "      ### or weight that is la
rger than all generator weights" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 161 
"      if( type(W,`mixedwt`) or (W &!> [seq(0,i=W)]) or not(member(`fa
lse`,map((g,hwv,w,a)->evalb(wt(eval(subs(hwv=1,g)),a) &!< w),SubModGen
s,HWV,W,Alg))) ) then " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "         \+
RETURN([]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "      elif( W = [seq
(0,i=W)] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 23 "         RETURN(
[HWV]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "      else" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 97 "         T := map((g,hwv,w,a)->if(wt(eval(sub
s(hwv=1,g)),a) = w) then g fi,SubModGens,HWV,W,Alg);" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 27 "         if( T <> [] ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 22 "            RETURN(T);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 13 "         else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 19 "          \+
  T := W;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "            R := [];" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 43 "            for i to mul(abs(k)+1,k=W)-1 do" }}{PARA 0 "> " 0 ""
 {MPLTEXT 1 0 82 "               R := [R[],map((x,wl,r,a,ow)->map((w,x
,r,a,ow)->x&@w,wl,x,r,a,ow)[]," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 88 " \+
                   basis(T,Alg),dosubmodulebasis(W-T,Alg,HWV,SubModGen
s),HWV,Alg,W)[]];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 47 "               for j from nops(T) to 1 by -1 d
o" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "                  if( T[j] = 0
 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "                     T[j
] := W[j];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "                  els
e" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 27 "                     break;" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "                  fi;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 18 "               od;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "               if( j > 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "                  T[j] := T[j] + 1;" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 18 "               fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 15 "            od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "        \+
    RETURN(R);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 12 "         fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 9 "      fi;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 7 "   end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 33 "   #----
------------- end of subs" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   Rep := op(4,eval(submodule))[Sub
Mod,`algebra`];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "   Alg := op(4,e
val(hwrep))[Rep,`algebra`][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 51 "   ### calculating the basis for \+
the representation" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   B := basis
(W,Rep);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 80 "   ### calculating the basis for submodule and repsim
plifying the returned terms" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "   u
sing(Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 47 "   M := matrix(map(pr
oc(e,r,bl,bll) local s, k;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "     \+
       s := repsimplify(e,r);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "  \+
          if( type(s,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 
"               RETURN(map(proc(t,bl,bll) local k;\n" }{MPLTEXT 1 0 
46 "                            # Correction 2019\n" }{MPLTEXT 1 0 77 
"                            # if(type(t,`*`) and member(op(2,t),bl,'k
')) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 89 "                       \+
     #   RETURN([seq(0,i=1..k-1),op(1,t),seq(0,i=k+1..bll)]);     " }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "                            if(type
(t,`*`) and member(op(-1,t),bl,'k')) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 92 "                               RETURN([seq(0,i=1..k-1
),PickConstants(t),seq(0,i=k+1..bll)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 55 "                            elif(member(t,bl,'k')) then" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 77 "                               RETU
RN([seq(0,i=1..k-1),1,seq(0,i=k+1..bll)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "                            else " }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 70 "                               ERROR(`%1 is not in \+
basis %2.`, t, bl);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "            \+
                fi; end," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 40 "       \+
                     s,bl,bll));\n" }{MPLTEXT 1 0 30 "            # Co
rrection 2019\n" }{MPLTEXT 1 0 65 "            # elif( type(s,`*`) and
 member(op(2,s),bl,'k') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 68 " \+
           #   RETURN([seq(0,i=1..k-1),op(1,s),seq(0,i=k+1..bll)]);" }
}{PARA 0 "> " 0 "" {MPLTEXT 1 0 64 "            elif( type(s,`*`) and \+
member(op(-1,s),bl,'k') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 " \+
              RETURN([seq(0,i=1..k-1),PickConstants(s),seq(0,i=k+1..bl
l)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 41 "            elif( member(s
,bl,'k') ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "               R
ETURN([seq(0,i=1..k-1),1,seq(0,i=k+1..bll)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 30 "            elif( s = 0 ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 41 "               RETURN([seq(0,i=1..bll)]);" }}{PARA 0 
"> " 0 "" {MPLTEXT 1 0 16 "            else" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 54 "               ERROR(`%1 is not in basis %2.`, s, bl)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "            fi; end," }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 87 "        dosubmodulebasis(W,Alg,op(4,eval(
hwrep))[Rep],[op(4,eval(submodule))[SubMod]])," }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 12 "        Rep," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "  \+
      B," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "        nops(B)));" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "   using(`reset`);" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 10 "#print(M);
" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 20 "   ### reduce matrix" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 32 "   \+
if( CHARACTERISTIC = 0 ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 52 "  \+
    M := convert(linalg[gaussjord](M),`listlist`);" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 63 "      \+
M := convert(Gaussjord(M) mod CHARACTERISTIC,`listlist`);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 28 "   ### discard all zero rows" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 50 "   M := map(l->if(l<>[seq(0,i=l)]) \+
then l; fi, M);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 
0 "" {MPLTEXT 1 0 18 "#print(matrix(M));" }}{PARA 0 "> " 0 "" {MPLTEXT
 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 21 "   ### storing matrix" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 43 "   submodule(SubMod,W,CHARACTERIS
TIC) := M:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 75 "   RETURN(map((l,bl)->if(l<>[]) then add(l[i]*bl[i],i
=1..nops(l)) fi,M,B));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 ""
 {MPLTEXT 1 0 70 "LieAlg_Hidden[quotrepbasis] := proc(W::list(integer)
,QuotRep::quotrep)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 70 "   option `Co
pyright (C) 1999-2019 by Yuly Billig and Matyas Mazzag.`;" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 69 "   description `Calculates the basis for a q
uotient representation.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "   loc
al i, M, B, P;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 44 "   ### get reduced matrix of submodule basis" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 80 "   M := op(4,eval(submodule))[op(4,
eval(quotrep))[QuotRep][2],W,CHARACTERISTIC];" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 93 "   ### maybe su
bmodule basis was not yet calculated for the given weight and we have \+
to do it" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 37 "   if( not(type(M,`list
list`)) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 56 "      submoduleba
sis(W,op(4,eval(quotrep))[QuotRep][2]);" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 83 "      M := op(4,eval(submodule))[op(4,eval(quotrep))[QuotRep][
2],W,CHARACTERISTIC];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
41 "   ### calculate basis for representation" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 49 "   B := basis(W,op(4,eval(quotrep))[QuotRep][1]);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
20 "   if( M = [] ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 16 "      R
ETURN(B);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "   else" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 82 "      P := map(proc(l) local k; if(l<>[] and me
mber(1,l,'k')) then k; fi; end, M);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
38 "      for i from nops(P) to 1 by -1 do" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 34 "         B := subsop(P[i]=NULL,B);" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 9 "      od;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 15 "   \+
   RETURN(B)" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 6 "   fi;" }}{PARA 0 ">
 " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 75 "LieAlg[singularvec
tor] := proc(Weight::list(integer),List::list(algebraic))" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 89 "    option `Copyright (C) 1999-2019 by Yuly \+
Billig and Matyas Mazzag.`, system, remember;" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 74 "    description `Calculates the singular vectors for \+
the representation.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 34 "    local \+
Alg, B, M, HWV, NofR, i;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "    if( nargs > 3 ) then" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 45 "       ERROR(`too many arguments %1.`, arg
s);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "    elif( nargs = 3 ) then" 
}}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 "       if( type(args[3],`hwrep`) \+
) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "          NofR := args[3]
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 11 "       else" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 83 "          ERROR(`%1 is not a representation or quo
tient representation.`, args[3]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
10 "       fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 8 "    else" }}{PARA 
0 "> " 0 "" {MPLTEXT 1 0 30 "       NofR := REPRESENTATION;" }}{PARA 0
 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "    Alg := op(4,eval(hwrep))
[NofR,`algebra`][2];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 35 "    HWV := \+
op(4,eval(hwrep))[NofR];" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "    if(
 member([],map((e,a)->wt(e,a),List,Alg)) ) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 73 "       ERROR(`elements %1 of algebra %2 are not homog
enous.`, List, Alg);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "    fi;" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "    ### calculate basis for given weight" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 28 "    B := basis(Weight,NofR);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "    ### produce
 the matrix from the basis and the repsimplified terms" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 43 "    M := convert(<op(map((x,bl,w,r,a,hwv)->" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 54 "            <%|op(map(proc(u,x,vl,r
,a,hwv) local s, k;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "            \+
     s := repsimplify(x&@u,r);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 39 " \+
                if( type(s,`+`) ) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 59 "                    RETURN(<op(map(proc(t,vl,vll) local k;\n" 
}{MPLTEXT 1 0 59 "                                         # Correctio
n 2019\n" }{MPLTEXT 1 0 90 "                                         #
 if(type(t,`*`) and member(op(2,t),vl,'k')) then" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 97 "                                         #   RETURN([
seq(0,i=1..k-1),op(1,t),seq(0,i=k+1..vll)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 92 "                                         if(type(t,`*
`) and member(PickTerm(t),vl,'k')) then" }}{PARA 0 "> " 0 "" {MPLTEXT 
1 0 105 "                                            RETURN([seq(0,i=1
..k-1),PickConstants(t),seq(0,i=k+1..vll)]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 68 "                                         elif(member(
t,vl,'k')) then" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "                \+
                            RETURN([seq(0,i=1..k-1),1,seq(0,i=k+1..vll
)]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 46 "                           \+
              else " }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 83 "            \+
                                ERROR(`%1 is not in basis %2.`, t, vl)
;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 49 "                              \+
           fi; end," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 59 "            \+
                            s,vl,nops(vl)))>);\n" }{MPLTEXT 1 0 35 "  \+
               # Correction 2019\n" }{MPLTEXT 1 0 70 "                \+
 # elif( type(s,`*`) and member(op(2,s),vl,'k') ) then" }}{PARA 0 "> "
 0 "" {MPLTEXT 1 0 78 "                 #   RETURN(<seq(0,i=1..k-1),op
(1,s),seq(0,i=k+1..nops(vl))>);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 72 "
                 elif( type(s,`*`) and member(PickTerm(s),vl,'k') ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 86 "                    RETURN(<s
eq(0,i=1..k-1),PickConstants(s),seq(0,i=k+1..nops(vl))>);" }}{PARA 0 "
> " 0 "" {MPLTEXT 1 0 46 "                 elif( member(s,vl,'k') ) th
en" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 71 "                    RETURN(<s
eq(0,i=1..k-1),1,seq(0,i=k+1..nops(vl))>);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 35 "                 elif( s = 0 ) then" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 42 "                    RETURN(<seq(0,i=vl)>);" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 61 "                 else ERROR(`%1 is \+
not in basis %2.`, s, vl);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 25 "     \+
            fi; end," }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 48 "           \+
  bl,x,basis(wt(x,a)+w,r),r,a,hwv))>," }}{PARA 0 "> " 0 "" {MPLTEXT 1 
0 49 "         List,B,Weight,NofR,Alg,HWV))>,`matrix`);" }}{PARA 0 "> 
" 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 20 "#    pri
nt(eval(M));" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 93 "    ### find nullspace of matrix, convert the nulls
pace vectors to sum of elements from basis" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 33 "    if( CHARACTERISTIC = 0 ) then" }}{PARA 0 "> " 0 "
" {MPLTEXT 1 0 97 "      RETURN([map((v,b)->add(v[i]*b[i],i=1..nops(co
nvert(v,`list`))),linalg[nullspace](M),B)[]]);" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 8 "    else" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 108 "      \+
RETURN([map((v,b)->add(v[i]*b[i],i=1..nops(convert(v,`list`))),Nullspa
ce(M) mod CHARACTERISTIC,B)[]]);" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 7 "
    fi;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 4 "end:" }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
47 "LieAlg_Hidden[resettabs] := proc(l::list(name))" }}{PARA 0 "> " 0 
"" {MPLTEXT 1 0 70 "   option `Copyright (C) 1999-2019 by Yuly Billig \+
and Matyas Mazzag.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "   descript
ion `Deletes remember tables.`;" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 ""
 }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 60 "   ### delete the remember table
s of the required procedures" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "   \+
RETURN(map(proc(x) subsop(4=NULL, eval(x)) end, l));" }}{PARA 0 "> " 0
 "" {MPLTEXT 1 0 4 "end:" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 55 "#######
##################>  miscallenous procedures end" }}}{EXCHG {PARA 0 ">
 " 0 "" {MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}
{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 31 "### some stats (# of functions)" }}{PARA 0 "> " 0 "" 
{MPLTEXT 1 0 88 "#lg := indices(eval(LieAlg)); hn := indices(eval(LieA
lg_Hidden)); nops([lg])+nops([hn]);" }}}{EXCHG {PARA 0 "> " 0 "" 
{MPLTEXT 1 0 0 "" }}{PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 76 "#save(LieAlg, \"C:\\\\Users\\\\Yuly
\\\\Documents\\\\MAPLE\\\\LIEALG\\\\JUL19\\\\LieAlg.m\");" }}}{EXCHG 
{PARA 0 "> " 0 "" {MPLTEXT 1 0 90 "#save(LieAlg_Hidden, \"C:\\\\Users
\\\\Yuly\\\\Documents\\\\MAPLE\\\\LIEALG\\\\JUL19\\\\LieAlg_Hidden.m\"
);" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 26 "#save(LieAlg, \"LieAl
g.m\");" }{MPLTEXT 1 0 0 "" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 
40 "#save(LieAlg_Hidden, \"LieAlg_Hidden.m\");" }{MPLTEXT 1 0 0 "" }}}
{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "savelib(LieAlg,\"/home/yuly/
MAPLE/LIEALG\");" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 22 "savelib
(LieAlg_Hidden," }{MPLTEXT 1 0 25 "\"/home/yuly/MAPLE/LIEALG\"" }
{MPLTEXT 1 0 2 ");" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 0 "" }}}}

{MARK "0 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 1 1 1 1 }{PAGENUMBERS 0 1 2
 33 1 1 }